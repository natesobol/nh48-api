<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Long-Distance Trails – NH48</title>
  <meta name="description" content="Explore long-distance trail campaigns with interactive maps, segment details, and downloadable data on NH48.">
  <link rel="canonical" href="https://nh48.info/long-trails.html">
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    crossorigin=""
  />
  <style>
    * {
      box-sizing: border-box;
    }

    :root {
      --bg-primary: #1a1d23;
      --bg-secondary: #25282f;
      --bg-tertiary: #2d3039;
      --border-color: #3d4048;
      --text-primary: #ffffff;
      --text-secondary: #d9dde5;
      --accent: #4a9eff;
    }

    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background-color: var(--bg-primary);
      color: var(--text-primary);
    }

    .page-header {
      max-width: 1200px;
      margin: 1.5rem auto 0;
      padding: 0 20px;
    }

    .page-header h1 {
      margin: 0 0 0.35rem;
      font-size: 2rem;
    }

    .page-header p {
      margin: 0.2rem 0;
      color: var(--text-secondary);
      line-height: 1.5;
    }

    #app {
      max-width: 1200px;
      margin: 1.5rem auto 2rem;
      padding: 0 20px;
      display: grid;
      grid-template-columns: minmax(280px, 360px) 1fr;
      gap: 16px;
      height: 70vh;
    }

    .sidebar {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      padding: 16px;
      overflow-y: auto;
    }

    .map-panel {
      border: 1px solid var(--border-color);
      border-radius: 12px;
      overflow: hidden;
      background: var(--bg-secondary);
    }

    #map {
      height: 100%;
      width: 100%;
      min-height: 360px;
    }

    .filter-panel {
      display: flex;
      flex-direction: column;
      gap: 10px;
      padding: 12px;
      border-radius: 10px;
      border: 1px solid var(--border-color);
      background: var(--bg-tertiary);
      margin-bottom: 16px;
    }

    .filter-label {
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-secondary);
    }

    .filter-select {
      padding: 10px 12px;
      border-radius: 8px;
      border: 1px solid var(--border-color);
      background: #20242b;
      color: var(--text-primary);
      font-size: 0.95rem;
    }

    .section-details {
      padding: 12px;
      border-radius: 10px;
      border: 1px solid var(--border-color);
      background: var(--bg-tertiary);
      margin-bottom: 16px;
      min-height: 72px;
    }

    .color-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      display: inline-block;
    }

    .section-title {
      font-weight: 600;
      margin-bottom: 4px;
    }

    .section-subtitle {
      font-size: 0.85rem;
      color: var(--text-secondary);
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    .legend {
      margin-top: 16px;
      padding-top: 12px;
      border-top: 1px solid var(--border-color);
    }

    .legend h2 {
      font-size: 1rem;
      margin: 0 0 8px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.9rem;
      margin-bottom: 6px;
    }

    .empty-state {
      padding: 16px;
      border-radius: 8px;
      background: #20242b;
      border: 1px dashed var(--border-color);
      color: var(--text-secondary);
      margin-top: 12px;
    }

    @media (max-width: 900px){
      #app {
        grid-template-columns: 1fr;
        height: auto;
      }

      .map-panel {
        height: 60vh;
      }
    }
  </style>
</head>
<body>
  <header class="page-header">
    <h1>Long-Distance Trails</h1>
    <p>Explore multi-day trail campaigns with interactive maps, segment details, and color-coded highlights.</p>
    <p>Use the dropdowns to focus the map on a trail section and inspect its stats.</p>
  </header>

  <main id="app">
    <aside class="sidebar" aria-live="polite">
      <div class="filter-panel">
        <label class="filter-label" for="trailSelect">Select a trail</label>
        <select id="trailSelect" class="filter-select"></select>
        <label class="filter-label" for="sectionSelect">Select a section</label>
        <select id="sectionSelect" class="filter-select" disabled></select>
      </div>
      <div id="sectionDetails" class="section-details"></div>
      <div class="legend">
        <h2>Trail colors</h2>
        <div id="legendList"></div>
      </div>
    </aside>
    <section class="map-panel">
      <div id="map"></div>
    </section>
  </main>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script>
    const MANIFEST_URLS = [
      '../data/long-trails-manifest.json',
      '/data/long-trails-manifest.json'
    ];

    const TRAIL_COLORS = {
      'appalachian-trail': '#008A5E',
      'tuscarora-trail': '#0065A4',
      'allegheny-trail': '#8b5cf6',
      'long-trail': '#16a34a',
      'north-country-trail': '#f97316',
      'finger-lakes-trail': '#db2777',
      'quehanna-trail': '#0ea5e9',
      'mid-state-trail': '#facc15'
    };

    const FALLBACK_PALETTE = [
      '#1f77b4',
      '#ff7f0e',
      '#2ca02c',
      '#d62728',
      '#9467bd',
      '#8c564b',
      '#e377c2',
      '#7f7f7f',
      '#bcbd22',
      '#17becf'
    ];

    let map;
    let activeSection = null;
    let activeTrail = null;
    let trailData = [];
    let globalBounds = null;
    const sectionLayers = new Map();
    const trailLayers = new Map();
    const usedColors = new Set();

    function createMap(){
      map = L.map('map', { zoomControl: true });
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
      }).addTo(map);
    }

    function fitBounds(bounds){
      if(!bounds){
        map.setView([44.0, -71.4], 7);
        return;
      }
      const southWest = [bounds.minLat, bounds.minLon];
      const northEast = [bounds.maxLat, bounds.maxLon];
      map.fitBounds([southWest, northEast], { padding: [20, 20] });
    }

    function buildSectionLabel(section){
      if(section.name){
        return section.name;
      }
      const start = section.start && section.start.name ? section.start.name : 'Start';
      const end = section.end && section.end.name ? section.end.name : 'End';
      return `${start} → ${end}`;
    }

    function resetActiveSection(){
      if(!activeSection) return;
      const previous = sectionLayers.get(activeSection.id);
      if(previous){
        previous.lines.forEach(line => line.setStyle({ weight: 3, opacity: 0.7 }));
        previous.markers.forEach(marker => marker.setStyle({ radius: 6, opacity: 0.9, fillOpacity: 0.9 }));
      }
      activeSection = null;
    }

    function setActiveSection(section){
      resetActiveSection();
      activeSection = section;
      const layer = sectionLayers.get(section.id);
      if(layer){
        layer.lines.forEach(line => line.setStyle({ weight: 5, opacity: 1 }));
        layer.markers.forEach(marker => marker.setStyle({ radius: 8, opacity: 1, fillOpacity: 1 }));
      }
    }

    function focusSection(section){
      setActiveSection(section);
      if(section.bounds){
        fitBounds(section.bounds);
      }else if(section.center){
        map.setView([section.center.lat, section.center.lon], 11);
      }
    }

    function addSectionLayers(trail, section){
      const color = trail.color || '#4a9eff';
      const markers = [];
      const lines = [];

      if(section.start && section.start.lat && section.start.lon){
        markers.push(L.circleMarker([section.start.lat, section.start.lon], {
          radius: 6,
          color,
          fillColor: color,
          fillOpacity: 0.9
        }).bindTooltip(`Start: ${section.start.name || ''}`.trim()));
      }
      if(section.end && section.end.lat && section.end.lon){
        markers.push(L.circleMarker([section.end.lat, section.end.lon], {
          radius: 6,
          color,
          fillColor: color,
          fillOpacity: 0.9
        }).bindTooltip(`End: ${section.end.name || ''}`.trim()));
      }

      if(section.gpxGeoJson){
        const line = L.geoJSON(section.gpxGeoJson, {
          style: { color, weight: 3, opacity: 0.7 }
        });
        lines.push(line);
      }

      markers.forEach(marker => marker.addTo(trail.layer));
      lines.forEach(line => line.addTo(trail.layer));
      sectionLayers.set(section.id, { markers, lines });
    }

    function toNumber(value){
      const num = Number(value);
      return Number.isFinite(num) ? num : null;
    }

    function normalizeBounds(input){
      if(!input){
        return null;
      }
      if(Array.isArray(input) && input.length === 4){
        const [minLat, minLon, maxLat, maxLon] = input;
        return {
          minLat: toNumber(minLat),
          minLon: toNumber(minLon),
          maxLat: toNumber(maxLat),
          maxLon: toNumber(maxLon)
        };
      }
      if(typeof input === 'object'){
        return {
          minLat: toNumber(input.minLat ?? input.south ?? input.min_lat),
          minLon: toNumber(input.minLon ?? input.west ?? input.min_lon),
          maxLat: toNumber(input.maxLat ?? input.north ?? input.max_lat),
          maxLon: toNumber(input.maxLon ?? input.east ?? input.max_lon)
        };
      }
      return null;
    }

    function mergeBounds(a, b){
      if(!a) return b;
      if(!b) return a;
      return {
        minLat: Math.min(a.minLat, b.minLat),
        minLon: Math.min(a.minLon, b.minLon),
        maxLat: Math.max(a.maxLat, b.maxLat),
        maxLon: Math.max(a.maxLon, b.maxLon)
      };
    }

    function normalizeEndpoints(stats){
      if(!stats) return null;
      const endpoints = stats.endpoints;
      if(Array.isArray(endpoints) && endpoints.length >= 2){
        return { start: endpoints[0], end: endpoints[endpoints.length - 1] };
      }
      if(typeof endpoints === 'object'){
        return endpoints;
      }
      return null;
    }

    function sectionCenter(section){
      if(section.start && section.end){
        const lat = (toNumber(section.start.lat) + toNumber(section.end.lat)) / 2;
        const lon = (toNumber(section.start.lon) + toNumber(section.end.lon)) / 2;
        if(Number.isFinite(lat) && Number.isFinite(lon)){
          return { lat, lon };
        }
      }
      return null;
    }

    function resolveColor(slug){
      if(TRAIL_COLORS[slug]){
        return TRAIL_COLORS[slug];
      }
      const color = FALLBACK_PALETTE[usedColors.size % FALLBACK_PALETTE.length];
      usedColors.add(color);
      return color;
    }

    function normalizeSection(section, index, trailSlug){
      const start = section.start || null;
      const end = section.end || null;
      const bounds = normalizeBounds(section.geometry || section.bounds || section.bbox);
      const center = sectionCenter({ start, end });
      const id = section.id || `${trailSlug}-section-${index + 1}`;
      return {
        ...section,
        id,
        start,
        end,
        bounds,
        center
      };
    }

    function normalizeTrail(trail, index, fileName){
      const slug = trail.slug || trail.id || (fileName ? fileName.replace(/\\.json$/i, '') : `trail-${index + 1}`);
      const color = resolveColor(slug);
      const sections = (trail.sections || []).map((section, sectionIndex) => normalizeSection(section, sectionIndex, slug)).sort((a, b) => {
        return (a.order ?? 0) - (b.order ?? 0);
      });

      let trailBounds = null;
      sections.forEach(section => {
        trailBounds = mergeBounds(trailBounds, section.bounds);
      });
      trailBounds = mergeBounds(trailBounds, normalizeBounds(trail.map && (trail.map.bbox || trail.map.bounds)));
      globalBounds = mergeBounds(globalBounds, trailBounds);

      return {
        ...trail,
        slug,
        color,
        bounds: trailBounds,
        stats: {
          ...trail.stats,
          endpoints: normalizeEndpoints(trail.stats)
        },
        map: {
          ...trail.map,
          bounds: normalizeBounds(trail.map && (trail.map.bbox || trail.map.bounds))
        },
        sections,
        layer: L.layerGroup()
      };
    }

    function renderLegend(trails){
      const legend = document.getElementById('legendList');
      legend.innerHTML = '';
      trails.forEach(trail => {
        const item = document.createElement('div');
        item.className = 'legend-item';
        item.innerHTML = `<span class="color-dot" style="background:${trail.color}"></span>${trail.name}`;
        legend.appendChild(item);
      });
    }

    function renderTrailSelect(trails){
      const select = document.getElementById('trailSelect');
      select.innerHTML = '';

      if(trails.length === 0){
        const option = document.createElement('option');
        option.textContent = 'No trails found';
        option.value = '';
        select.appendChild(option);
        select.disabled = true;
        return;
      }

      trails.forEach(trail => {
        const option = document.createElement('option');
        option.value = trail.slug;
        option.textContent = trail.name || trail.slug;
        select.appendChild(option);
      });

      select.disabled = false;
    }

    function renderSectionSelect(trail){
      const select = document.getElementById('sectionSelect');
      select.innerHTML = '';

      if(!trail || !trail.sections || trail.sections.length === 0){
        const option = document.createElement('option');
        option.textContent = 'No sections available';
        option.value = '';
        select.appendChild(option);
        select.disabled = true;
        return;
      }

      trail.sections.forEach(section => {
        const option = document.createElement('option');
        option.value = section.id;
        option.textContent = buildSectionLabel(section);
        select.appendChild(option);
      });

      select.disabled = false;
    }

    function renderSectionDetails(section){
      const container = document.getElementById('sectionDetails');
      if(!section){
        container.innerHTML = '<div class="empty-state">Select a section to see details.</div>';
        return;
      }
      const distance = section.distance ? `${section.distance} mi` : null;
      const difficulty = section.difficulty && section.difficulty.rating ? `Difficulty: ${section.difficulty.rating}` : null;
      const jurisdictions = section.jurisdictions && section.jurisdictions.length ? section.jurisdictions.join(', ') : null;
      container.innerHTML = `
        <div class="section-title">${buildSectionLabel(section)}</div>
        <div class="section-subtitle">
          ${[distance, difficulty, jurisdictions].filter(Boolean).map(item => `<span>${item}</span>`).join('')}
        </div>
      `;
    }

    function showTrailLayer(trail){
      if(activeTrail && trailLayers.has(activeTrail.slug)){
        map.removeLayer(trailLayers.get(activeTrail.slug));
      }
      if(trail && trailLayers.has(trail.slug)){
        map.addLayer(trailLayers.get(trail.slug));
      }
      activeTrail = trail || null;
    }

    function handleTrailChange(slug){
      const trail = trailData.find(item => item.slug === slug);
      if(!trail) return;
      showTrailLayer(trail);
      renderSectionSelect(trail);
      renderSectionDetails(null);
      resetActiveSection();
      fitBounds(trail.bounds || trail.map.bounds || null);
      if(trail.sections && trail.sections.length > 0){
        const sectionSelect = document.getElementById('sectionSelect');
        sectionSelect.value = trail.sections[0].id;
        handleSectionChange(trail.sections[0].id);
      }
    }

    function handleSectionChange(sectionId){
      if(!activeTrail) return;
      const section = activeTrail.sections.find(item => item.id === sectionId);
      if(!section) return;
      focusSection(section);
      renderSectionDetails(section);
    }

    async function loadManifest(){
      for(const url of MANIFEST_URLS){
        try{
          const response = await fetch(url);
          if(!response.ok) continue;
          return await response.json();
        }catch(error){
          console.warn('Unable to load trail manifest:', error);
        }
      }
      return { files: [] };
    }

    async function loadTrailsFromManifest(){
      const manifest = await loadManifest();
      if(!manifest || !manifest.files || manifest.files.length === 0){
        return [];
      }
      const results = await Promise.all(manifest.files.map(async (file) => {
        try{
          const urlCandidates = [
            `../data/long-trails/${file}`,
            `/data/long-trails/${file}`
          ];
          let response = null;
          for(const url of urlCandidates){
            const candidate = await fetch(url);
            if(candidate.ok){
              response = candidate;
              break;
            }
          }
          if(!response) return null;
          const data = await response.json();
          return { data, file };
        }catch(error){
          console.warn('Unable to load trail data:', error);
          return null;
        }
      }));
      return results.filter(Boolean);
    }

    async function init(){
      createMap();
      const trailFiles = await loadTrailsFromManifest();
      trailData = trailFiles.map((entry, index) => normalizeTrail(entry.data, index, entry.file));
      trailData.forEach(trail => {
        trailLayers.set(trail.slug, trail.layer);
        (trail.sections || []).forEach(section => addSectionLayers(trail, section));
      });
      renderTrailSelect(trailData);
      renderLegend(trailData);

      if(trailData.length > 0){
        handleTrailChange(trailData[0].slug);
        document.getElementById('trailSelect').value = trailData[0].slug;
      }else{
        fitBounds(globalBounds);
        renderSectionDetails(null);
      }

      document.getElementById('trailSelect').addEventListener('change', (event) => {
        handleTrailChange(event.target.value);
      });
      document.getElementById('sectionSelect').addEventListener('change', (event) => {
        handleSectionChange(event.target.value);
      });
    }

    window.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
