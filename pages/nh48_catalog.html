<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Browse the NH48 Peak Catalog with elevation, prominence, range, difficulty and photo thumbnails for all 48 four-thousand-foot peaks in New Hampshire. Search, filter and sort using this open dataset. Open API and datasets for New Hampshire’s 4,000-foot mountains.">
    <meta name="keywords" content="NH48 API, New Hampshire 4000 footers, peak catalog, White Mountains data, hiking database, open hiking API, peak metadata, mountain photos, NH 48 peaks dataset, White Mountain peak list, open source hiking API">
    <meta name="robots" content="index,follow">
    <link rel="canonical" href="https://nh48.info/catalog.html">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://nh48.info/catalog.html">
    <meta property="og:title" content="NH48 Peak Catalog – Data &amp; photos for New Hampshire’s 4000-footers">
    <meta property="og:description" content="Browse the NH48 Peak Catalog with elevation, prominence, range, difficulty and photo thumbnails for all 48 four-thousand-foot peaks in New Hampshire. Search, filter and sort using this open dataset. Open API and datasets for New Hampshire’s 4,000-foot mountains.">
    <meta property="og:image" content="https://cdn.jsdelivr.net/gh/natesobol/nh48-api@main/nh48-preview.png">
    
    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://nh48.info/catalog.html">
    <meta name="twitter:title" content="NH48 Peak Catalog – Data &amp; photos for New Hampshire's 4000-footers">
    <meta name="twitter:description" content="Browse the NH48 Peak Catalog with elevation, prominence, range, difficulty and photo thumbnails for all 48 four-thousand-foot peaks in New Hampshire. Search, filter and sort using this open dataset. Open API and datasets for New Hampshire’s 4,000-foot mountains.">
    <meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/natesobol/nh48-api@main/nh48-preview.png">
    
    <title>NH48 Peak Catalog – Data &amp; photos for New Hampshire’s 4000-footers</title>
    <link rel="icon" type="image/png" href="../nh48API_logo.png">
    <link rel="stylesheet" href="../css/nh48_catalog.css">
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "Dataset",
        "name": "NH48 API – New Hampshire 4000-Footers Data",
        "description": "Structured data and photos for the 48 four-thousand-foot peaks of the White Mountain National Forest, including elevation, prominence, difficulty, routes and rich photo metadata.",
        "url": "https://nh48.info/",
        "license": "https://opensource.org/licenses/MIT",
        "creator": {
          "@type": "Person",
          "name": "Nathan Sobol",
          "url": "https://www.nh48pics.com/"
        },
        "keywords": ["NH48", "White Mountains", "4000 footers", "hiking data", "peak metadata", "photo metadata", "open dataset"],
        "distribution": {
          "@type": "DataDownload",
          "contentUrl": "https://cdn.jsdelivr.net/gh/natesobol/nh48-api@main/data/nh48.json",
          "encodingFormat": "application/json"
        },
        "temporalCoverage": "2025-12-06/2025-12-06",
        "spatialCoverage": {
          "@type": "Place",
          "name": "White Mountain National Forest",
          "geo": {"@type": "GeoShape", "circle": "44.15 -71.34 50km"}
        }
      }
    </script>
    <!--
      Enhanced catalog page for the NH48 peak list.

      This version adds:
        • Larger cards in a 2-column layout.
        • Sort-by dropdown covering all general info API fields.
        • A two-tier filter: 1) choose field, 2) choose value (Range, Difficulty, Trail Type, Exposure).
        • Cards display the same "General Peak Info" as the details page.
    -->
  </head>
  <body data-page="catalog">
    <div id="nav-placeholder"></div>
    <script>
      // Load shared navigation
      const navPlaceholder = document.getElementById('nav-placeholder');
      fetch('nav.html')
        .then(response => response.text())
        .then(html => {
          navPlaceholder.innerHTML = html;
          const activeRoute = document.body.dataset.page;
          const activeLink = navPlaceholder.querySelector(`[data-route="${activeRoute}"]`);
          if (activeLink) {
            activeLink.classList.add('active');
          }
        })
        .catch(err => console.error('Failed to load navigation:', err));
    </script>
    <div class="wrap">
      <header>
        <h1>NH48 Peak Catalog</h1>
        <p>Browse New Hampshire's forty-eight 4000-footers. Click a peak to view more details. If errors occur, details will appear below. Open API and datasets for New Hampshire’s 4,000-foot mountains.</p>
      </header>

      <!-- search with datalist for suggestions -->
      <div class="search">
        <input type="text" id="searchInput" list="nameSuggestions" placeholder="Search peaks by name…" aria-label="Search peaks by name" />
        <datalist id="nameSuggestions"></datalist>
      </div>

      <!-- controls for sorting, filtering, and columns (desktop only) -->
      <div class="controls">
        <div class="control">
          <label for="sortSelect">Sort by:</label>
          <select id="sortSelect" aria-label="Sort peaks by attribute">
            <option value="name">Name (A–Z)</option>
            <option value="elev-asc">Elevation ↑</option>
            <option value="elev-desc">Elevation ↓</option>
            <option value="prom-asc">Prominence ↑</option>
            <option value="prom-desc">Prominence ↓</option>
            <option value="difficulty-asc">Difficulty A–Z</option>
            <option value="difficulty-desc">Difficulty Z–A</option>
            <option value="range-asc">Range A–Z</option>
            <option value="trail-asc">Trail Type A–Z</option>
            <option value="exposure-asc">Exposure A–Z</option>
          </select>
        </div>

        <!-- Two-tier filter: choose field + value -->
        <div class="control">
          <label for="filterField">Filter by:</label>
          <select id="filterField" aria-label="Select field to filter peaks">
            <option value="">None</option>
            <option value="range">Range</option>
            <option value="difficulty">Difficulty</option>
            <option value="trail">Trail Type</option>
            <option value="exposure">Exposure</option>
          </select>
        </div>
        <div class="control">
          <label for="filterValue">Value:</label>
          <select id="filterValue" disabled aria-label="Select value for chosen filter">
            <option value="">All</option>
          </select>
        </div>

        <!-- Column selector -->
        <div class="control column-selector-control">
          <label for="columnSelect">Columns:</label>
          <select id="columnSelect" aria-label="Select number of catalog columns">
            <option value="2">2</option>
            <option value="3" selected>3</option>
            <option value="4">4</option>
            <option value="5">5</option>
          </select>
        </div>
      </div>

      <div id="grid" class="grid"></div>
      <nav id="pagination" class="pagination"></nav>
      <div id="emptyMessage" class="empty" hidden>No peaks found.</div>
    </div>

    <script>
      // API endpoints to attempt in order.
      const API_URLS = [
        'https://cdn.jsdelivr.net/gh/natesobol/nh48-api@main/data/nh48.json',
        'https://raw.githubusercontent.com/natesobol/nh48-api/main/data/nh48.json'
      ];

      // Placeholder image when no photo is available
      const PLACEHOLDER = 'data:image/svg+xml;utf8,' + encodeURIComponent(
        `<svg xmlns="http://www.w3.org/2000/svg" width="1200" height="800"><rect width="100%" height="100%" fill="#172032"/><text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="#64748b" font-family="system-ui" font-size="22">no image</text></svg>`
      );

      // Pagination
      const ITEMS_PER_PAGE = 30;
      let currentPage = 1;

      let peaks = [];
      let activeSort = 'name';

      // two-tier filter state
      const filters = {
        field: '',
        value: ''
      };

      // options per filter field (built after loading peaks)
      const filterOptions = {
        range: [],
        difficulty: [],
        trail: [],
        exposure: []
      };

      function cleanJSON(raw){
        let cleaned = raw.replace(/:contentReference\[.*?\]\{index=\d+\}/g, '');
        cleaned = cleaned.replace(/\/\*\s*Lines?\s+\d+[\d\-,\s]*omitted\s*\*\//g, '');
        return cleaned;
      }

      async function fetchPeaks(){
        for(let i=0;i<API_URLS.length;i++){
          const url = API_URLS[i];
          try{
            const res = await fetch(url, { mode:'cors' });
            if(!res.ok){
              console.log(`Attempt ${i+1}: Status ${res.status} ${res.statusText}`);
              continue;
            }
            const text = await res.text();
            const cleaned = cleanJSON(text);
            let obj;
            try{
              obj = JSON.parse(cleaned);
            }catch(err){
              console.error(`JSON parse error: ${err.message}`);
              continue;
            }
            const arr = Object.keys(obj).map(slug => {
              const p = obj[slug] || {};
              p.slug = slug;
              p.peakName = p.peakName || p['Peak Name'] || slug;
              return p;
            });
            console.log(`Loaded ${arr.length} peaks from ${url}`);
            return arr;
          }catch(err){
            console.error(`Fetch error: ${err.message || err}`);
          }
        }
        throw new Error('All API endpoints failed');
      }

      function buildPhotoAlt(p, photo){
        if(photo && typeof photo === 'object'){
          const parts = [p.peakName];
          if(photo.caption){
            parts.push(photo.caption);
          }
          if(photo.season){
            parts.push(photo.season);
          }
          if(photo.timeOfDay){
            parts.push(photo.timeOfDay);
          }
          if(photo.orientation){
            parts.push(`${photo.orientation} orientation`);
          }
          return parts.filter(Boolean).join(' — ');
        }
        return `${p.peakName} photo`;
      }

      function createCard(p){
        const card = document.createElement('article');
        card.className = 'card';

        // Thumbnail
        let thumbSrc = PLACEHOLDER;
        let thumbAlt = `${p.peakName} thumbnail photo`;
        if (Array.isArray(p.photos) && p.photos.length > 0) {
          const first = p.photos[0];
          thumbAlt = buildPhotoAlt(p, first);
          if (typeof first === 'string') {
            thumbSrc = first;
          } else if (first && first.url) {
            thumbSrc = first.url;
          }
        }

        const elev = p['Elevation (ft)'];
        const prom = p['Prominence (ft)'];
        const range = p['Range / Subrange'] || '—';
        const trail = p['Trail Type'] || '—';
        const difficulty = p['Difficulty'] || '—';
        const exposure = p['Exposure Level'] || p['Weather Exposure Rating'] || '—';

        card.innerHTML = `
          <div class="thumb">
            <img src="${thumbSrc}" alt="${thumbAlt}" loading="lazy" decoding="async">
          </div>
          <div class="body">
            <h3>${p.peakName}</h3>
            <div class="card-meta">
              <div class="meta-row"><span class="meta-label">Elevation</span><span class="meta-value">${elev ? elev + "'" : '—'}</span></div>
              <div class="meta-row"><span class="meta-label">Prominence</span><span class="meta-value">${prom ? prom + "'" : '—'}</span></div>
              <div class="meta-row"><span class="meta-label">Range</span><span class="meta-value">${range}</span></div>
              <div class="meta-row"><span class="meta-label">Trail Type</span><span class="meta-value">${trail}</span></div>
              <div class="meta-row"><span class="meta-label">Difficulty</span><span class="meta-value">${difficulty}</span></div>
              <div class="meta-row"><span class="meta-label">Exposure</span><span class="meta-value">${exposure}</span></div>
            </div>
          </div>`;

        card.addEventListener('click', () => {
          window.location.href = `/pages/nh48_peak.html?slug=${encodeURIComponent(p.slug)}`;
        });

        return card;
      }

      function setupLazyLoading(){
        if (!('IntersectionObserver' in window)) return;
        const observer = new IntersectionObserver((entries, obs) => {
          entries.forEach(entry => {
            if(entry.isIntersecting){
              const img = entry.target;
              const real = img.getAttribute('data-src');
              if(real){ img.src = real; img.removeAttribute('data-src'); }
              obs.unobserve(img);
            }
          });
        }, { rootMargin: '200px' });
        document.querySelectorAll('img[data-src]').forEach(img => observer.observe(img));
      }

      function renderGrid(list){
        const grid = document.getElementById('grid');
        const empty = document.getElementById('emptyMessage');
        grid.innerHTML = '';
        if(!list || list.length === 0){
          empty.hidden = false;
          return;
        }
        empty.hidden = true;
        list.forEach(p => grid.appendChild(createCard(p)));
        setupLazyLoading();
      }

      // Build suggestions list, stripping common words
      function updateSuggestions(){
        const list = peaks.map(p => p.peakName.replace(/\b(Mount|Mountain|Peak)\b/gi, '').trim()).filter(Boolean);
        const seen = new Set();
        const unique = [];
        list.forEach(name => {
          const key = name.toLowerCase();
          if(!seen.has(key)){
            seen.add(key);
            unique.push(name);
          }
        });
        const dl = document.getElementById('nameSuggestions');
        dl.innerHTML = unique.sort().map(name => `<option value="${name}"></option>`).join('');
      }

      // Build filter options for each field
      function buildFilterOptions(){
        const ranges = new Set();
        const diffs = new Set();
        const trails = new Set();
        const exposures = new Set();

        peaks.forEach(p => {
          const r = p['Range / Subrange'];
          if(r) ranges.add(r);
          const d = p['Difficulty'] || p.Difficulty;
          if(d) diffs.add(d);
          const t = p['Trail Type'];
          if(t) trails.add(t);
          const e = p['Exposure Level'] || p['Weather Exposure Rating'];
          if(e) exposures.add(e);
        });

        filterOptions.range = Array.from(ranges).sort();
        filterOptions.difficulty = Array.from(diffs).sort();
        filterOptions.trail = Array.from(trails).sort();
        filterOptions.exposure = Array.from(exposures).sort();
      }

      function populateFilterValueSelect(field){
        const valueSel = document.getElementById('filterValue');
        valueSel.innerHTML = '<option value=\"\">All</option>';

        if(!field){
          valueSel.disabled = true;
          return;
        }

        const opts = filterOptions[field] || [];
        opts.forEach(v => {
          const opt = document.createElement('option');
          opt.value = v;
          opt.textContent = v;
          valueSel.appendChild(opt);
        });

        valueSel.disabled = false;
      }

      function applyFilters(list){
        if(!filters.field || !filters.value) return list;

        const val = filters.value;
        return list.filter(p => {
          switch(filters.field){
            case 'range':
              return (p['Range / Subrange'] || '') === val;
            case 'difficulty':
              return (p['Difficulty'] || p.Difficulty || '') === val;
            case 'trail':
              return (p['Trail Type'] || '') === val;
            case 'exposure':
              return (p['Exposure Level'] || p['Weather Exposure Rating'] || '') === val;
          }
          return true;
        });
      }

      function sortPeaks(list){
        const arr = list.slice();
        arr.sort((a, b) => {
          switch(activeSort){
            case 'name':
              return (a.peakName || '').localeCompare(b.peakName || '');
            case 'elev-asc':
              return (a['Elevation (ft)'] || 0) - (b['Elevation (ft)'] || 0);
            case 'elev-desc':
              return (b['Elevation (ft)'] || 0) - (a['Elevation (ft)'] || 0);
            case 'prom-asc':
              return (a['Prominence (ft)'] || 0) - (b['Prominence (ft)'] || 0);
            case 'prom-desc':
              return (b['Prominence (ft)'] || 0) - (a['Prominence (ft)'] || 0);
            case 'difficulty-asc':
              return ((a['Difficulty'] || '')).localeCompare((b['Difficulty'] || ''));
            case 'difficulty-desc':
              return ((b['Difficulty'] || '')).localeCompare((a['Difficulty'] || ''));
            case 'range-asc':
              return ((a['Range / Subrange'] || '')).localeCompare((b['Range / Subrange'] || ''));
            case 'trail-asc':
              return ((a['Trail Type'] || '')).localeCompare((b['Trail Type'] || ''));
            case 'exposure-asc':
              return ((a['Exposure Level'] || a['Weather Exposure Rating'] || ''))
                .localeCompare((b['Exposure Level'] || b['Weather Exposure Rating'] || ''));
          }
          return 0;
        });
        return arr;
      }

      // Render pagination controls
      function renderPagination(totalPages){
        const nav = document.getElementById('pagination');
        nav.innerHTML = '';
        if(totalPages <= 1){
          return;
        }
        const makeBtn = (label, page) => {
          const btn = document.createElement('button');
          btn.textContent = label;
          if(page === currentPage){
            btn.disabled = true;
            btn.classList.add('active');
          }
          btn.addEventListener('click', () => {
            currentPage = page;
            updateDisplay();
          });
          return btn;
        };
        // First and previous
        nav.appendChild(makeBtn('«', 1));
        nav.appendChild(makeBtn('‹', Math.max(1, currentPage - 1)));
        // Window of pages
        const delta = 2;
        const start = Math.max(1, currentPage - delta);
        const end = Math.min(totalPages, currentPage + delta);
        for(let i=start; i<=end; i++){
          nav.appendChild(makeBtn(i.toString(), i));
        }
        // Next and last
        nav.appendChild(makeBtn('›', Math.min(totalPages, currentPage + 1)));
        nav.appendChild(makeBtn('»', totalPages));
      }

      function updateDisplay(){
        let list = peaks;

        // Search filter from input
        const searchVal = document.getElementById('searchInput').value.trim().toLowerCase();
        if(searchVal){
          list = list.filter(p => p.peakName && p.peakName.toLowerCase().includes(searchVal));
        }

        list = applyFilters(list);
        list = sortPeaks(list);

        // Pagination
        const totalPages = Math.ceil(list.length / ITEMS_PER_PAGE);
        if(currentPage > totalPages){
          currentPage = totalPages || 1;
        }
        const startIdx = (currentPage - 1) * ITEMS_PER_PAGE;
        const endIdx = startIdx + ITEMS_PER_PAGE;
        const pageItems = list.slice(startIdx, endIdx);

        renderGrid(pageItems);
        renderPagination(totalPages);
      }

      async function init(){
        try{
          peaks = await fetchPeaks();
          updateSuggestions();
          buildFilterOptions();
          updateDisplay();
        }catch(err){
          console.error('Error loading peaks:', err);
          const emptyMessage = document.getElementById('emptyMessage');
          if (emptyMessage) {
            emptyMessage.textContent = 'Error loading peaks';
            emptyMessage.hidden = false;
          }
        }

        const searchInput = document.getElementById('searchInput');
        if (searchInput) {
          searchInput.addEventListener('input', () => {
            currentPage = 1;
            updateDisplay();
          });
        }

        const sortSelect = document.getElementById('sortSelect');
        if (sortSelect) {
          sortSelect.addEventListener('change', (e) => {
            activeSort = e.target.value;
            currentPage = 1;
            updateDisplay();
          });
        }

        const filterField = document.getElementById('filterField');
        if (filterField) {
          filterField.addEventListener('change', (e) => {
            filters.field = e.target.value;
            filters.value = '';
            populateFilterValueSelect(filters.field);
            currentPage = 1;
            updateDisplay();
          });
        }

        const filterValue = document.getElementById('filterValue');
        if (filterValue) {
          filterValue.addEventListener('change', (e) => {
            filters.value = e.target.value;
            currentPage = 1;
            updateDisplay();
          });
        }
      }

      window.addEventListener('load', init);

      // Column selector handler
      const columnSelect = document.getElementById('columnSelect');
      const grid = document.getElementById('grid');
      
      // Load saved column preference
      const savedColumns = localStorage.getItem('nh48-catalog-columns');
      if (savedColumns && ['2', '3', '4', '5'].includes(savedColumns)) {
        columnSelect.value = savedColumns;
        grid.setAttribute('data-columns', savedColumns);
      } else {
        grid.setAttribute('data-columns', '3');
      }
      
      columnSelect.addEventListener('change', function() {
        const columns = this.value;
        grid.setAttribute('data-columns', columns);
        localStorage.setItem('nh48-catalog-columns', columns);
      });
    </script>
    <script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-app.js";
      import { getAnalytics, logEvent } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-analytics.js";

      const firebaseConfig = {
        apiKey: "AIzaSyCUSHYxwXVGEDNzMeIwSFmDaYeXSqRK4A",
        authDomain: "nh48-info.firebaseapp.com",
        projectId: "nh48-info",
        storageBucket: "nh48-info.firebasestorage.app",
        messagingSenderId: "732743288228",
        appId: "1:732743288228:web:d82d62cae0c3999ee5ad31",
        measurementId: "G-Q9F2W8YB7D"
      };

      const app = initializeApp(firebaseConfig);
      const analytics = getAnalytics(app);

      // Expose globally for app scripts
      window.NH48_INFO_ANALYTICS = {
        analytics,
        logEvent
      };

      // Base page-load event
      logEvent(analytics, "page_loaded", {
        site: "nh48-info",
        page: location.pathname
      });
    </script>
  </body>
</html>
