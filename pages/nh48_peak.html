<!doctype html> 
<html lang="en">
  <head>
    <meta charset="utf-8">
    <!-- Favicons - ICO format preferred for Google compatibility -->
    <link rel="icon" href="/favicons/favicon.ico" sizes="48x48">
    <link rel="icon" type="image/x-icon" href="/favicons/favicon.ico">
    <link rel="shortcut icon" href="/favicons/favicon.ico">
    <link rel="icon" type="image/x-icon" sizes="16x16" href="/favicons/favicon-16x16.ico">
    <link rel="icon" type="image/x-icon" sizes="32x32" href="/favicons/favicon-32x32.ico">
    <link rel="icon" type="image/x-icon" sizes="48x48" href="/favicons/favicon-48x48.ico">
    <link rel="icon" type="image/x-icon" sizes="96x96" href="/favicons/favicon-96x96.ico">
    <!-- PNG fallbacks for browsers that prefer PNG -->
    <link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32.png">
    <link rel="icon" type="image/png" sizes="48x48" href="/favicons/favicon-48x48.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/favicons/favicon-96x96.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
    <link rel="manifest" href="/manifest.json">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta id="dynamicDescription" name="description" content="NH48 API – peak-level details, routes, terrain notes and photography for New Hampshire’s 4000-footers. Open API and datasets for New Hampshire’s 4,000-foot mountains.">
    <meta name="keywords" content="NH48 API, New Hampshire 4000 footers, peak details, mountain routes, White Mountains data, hiking API, peak metadata, mountain photos">
    <meta name="robots" content="index,follow,max-image-preview:large">
    <link id="dynamicCanonical" rel="canonical" href="https://nh48.info/peak">
    <link id="hreflangEn" rel="alternate" hreflang="en" href="https://nh48.info/peak">
    <link id="hreflangFr" rel="alternate" hreflang="fr" href="https://nh48.info/fr/peak">
    <link id="hreflangDefault" rel="alternate" hreflang="x-default" href="https://nh48.info/peak">
    <meta property="og:type" content="website">
    <meta id="dynamicOgUrl" property="og:url" content="https://nh48.info/peak">
    <meta id="dynamicOgTitle" property="og:title" content="NH48 API – Peak details, routes &amp; photos">
    <meta id="dynamicOgDescription" property="og:description" content="Detailed information for each NH48 peak including elevation, prominence, difficulty, exposure, trail types, routes, terrain description and photo metadata. Open API and datasets for New Hampshire’s 4,000-foot mountains.">
    <meta id="dynamicOgImage" property="og:image" content="https://photos.nh48.info/cdn-cgi/image/format=jpg,quality=85,width=1200/mount-jefferson/mount-jefferson__001.jpg">
    
    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://nh48.info/peak">
    <meta id="dynamicTwitterTitle" name="twitter:title" content="NH48 API – Peak details, routes &amp; photos">
    <meta id="dynamicTwitterDescription" name="twitter:description" content="Detailed information for each NH48 peak including elevation, prominence, difficulty, exposure, trail types, routes, terrain description and photo metadata. Open API and datasets for New Hampshire’s 4,000-foot mountains.">
    <meta id="dynamicTwitterImage" name="twitter:image" content="https://photos.nh48.info/cdn-cgi/image/format=jpg,quality=85,width=1200/mount-jefferson/mount-jefferson__001.jpg">
    <script id="peakJsonLd" type="application/ld+json"></script>
    <script id="breadcrumbJsonLd" type="application/ld+json"></script>
    <script id="mapJsonLd" type="application/ld+json"></script>

    <title id="dynamicTitle">NH48 API – Peak details, routes &amp; photos</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      crossorigin=""
    >
    <script src="/js/unified-footer.js" defer></script>
    <script>
      function getRouteInfo(pathname){
        const parts = pathname.split('/').filter(Boolean);
        const isFrench = parts[0] === 'fr';
        const slug = parts[isFrench ? 2 : 1] || '';
        return { slug, isFrench };
      }

      const params = new URLSearchParams(window.location.search);
      const requestedLang = params.get('lang');
      if (requestedLang) {
        localStorage.setItem('nh48_lang', requestedLang);
      }

      const routeInfo = getRouteInfo(window.location.pathname);
      const slugParam = routeInfo.slug || params.get('slug');
      const langHint = (requestedLang || localStorage.getItem('nh48_lang') || '').toLowerCase();
      const canonicalBaseEarly = (langHint.startsWith('fr') || routeInfo.isFrench) ? 'https://nh48.info/fr/peak' : 'https://nh48.info/peak';
      const canonicalUrlEarly = slugParam ? `${canonicalBaseEarly}/${encodeURIComponent(slugParam)}/` : `${canonicalBaseEarly}/`;
      const canonicalEl = document.getElementById('dynamicCanonical');
      if (canonicalEl) {
        canonicalEl.setAttribute('href', canonicalUrlEarly);
      }
      const hreflangEnEarly = document.getElementById('hreflangEn');
      if (hreflangEnEarly) {
        hreflangEnEarly.setAttribute('href', slugParam ? `https://nh48.info/peak/${encodeURIComponent(slugParam)}/` : 'https://nh48.info/peak/');
      }
      const hreflangFrEarly = document.getElementById('hreflangFr');
      if (hreflangFrEarly) {
        hreflangFrEarly.setAttribute('href', slugParam ? `https://nh48.info/fr/peak/${encodeURIComponent(slugParam)}/` : 'https://nh48.info/fr/peak/');
      }
      const hreflangDefaultEarly = document.getElementById('hreflangDefault');
      if (hreflangDefaultEarly) {
        hreflangDefaultEarly.setAttribute('href', slugParam ? `https://nh48.info/peak/${encodeURIComponent(slugParam)}/` : 'https://nh48.info/peak/');
      }

      window.NH48_ROUTE_INFO = routeInfo;
    </script>
    <script type="module" src="/js/i18n.js"></script>
    <!--
      Standalone details view for a single NH48 peak with robust error handling.
      This version adds:
        • A photo carousel with a circular countdown timer.
        • A “Current Photo Metadata” panel that updates per slide.
        • A “General Peak Info” panel with dotted-line rows.
        • Side-by-side layout of metadata + general info on larger screens.
    -->
    <style>
      :root{
        --bg:#0a0a0a;
        --panel:#12121a;
        --card:#171a22;
        --ink:#ffffff;
        --muted:#a5b4c3;
        --stroke:#ffffff33;
        --accent:#22c55e;
        --accent-strong:#4ade80;
      }
      body{
        margin:0;
        background:var(--bg);
        color:var(--ink);
        font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
        -webkit-font-smoothing:antialiased;
        text-rendering:optimizeLegibility;
      }

      /* Navigation Menu - using shared nav from nav.html */
      .top-nav{
        background:var(--panel);
        border-bottom:1px solid var(--stroke);
        padding:12px 0;
        margin-bottom:16px;
      }
      .nav-container{
        max-width:1100px;
        margin:0 auto;
        padding:0 16px;
        display:flex;
        justify-content:space-between;
        align-items:center;
      }
      .nav-brand{
        display:flex;
        align-items:center;
        text-decoration:none;
      }
      .nav-brand img{
        height:40px;
        width:auto;
      }
      .sr-only{
        position:absolute;
        width:1px;
        height:1px;
        padding:0;
        margin:-1px;
        overflow:hidden;
        clip:rect(0,0,0,0);
        border:0;
        white-space:nowrap;
      }
      .nav-links{
        display:flex;
        gap:24px;
        align-items:center;
      }
      .nav-links a{
        color:var(--ink);
        text-decoration:none;
        font-size:0.95rem;
        transition:color 0.2s ease;
        white-space:nowrap;
      }
      .nav-links a:hover{
        color:var(--accent);
      }
      .nav-toggle{
        display:none;
        background:none;
        border:none;
        color:var(--ink);
        font-size:1.5rem;
        cursor:pointer;
        padding:4px;
      }
      @media(max-width:640px){
        .top-nav{ padding:10px 0; margin-bottom:12px; }
        .nav-container{ padding:0 12px; flex-wrap:wrap; }
        .nav-toggle{ display:block; }
        .nav-links{
          display:none;
          width:100%;
          flex-direction:column;
          gap:12px;
          margin-top:12px;
          padding-top:12px;
          border-top:1px solid var(--stroke);
          align-items:flex-start;
        }
        .nav-links.active{
          display:flex;
        }
        .nav-brand img{ height:32px; }
      }
      .wrap{
        max-width:900px;
        margin:0 auto;
        padding:16px;
      }
      @media(max-width:640px){
        .wrap{ padding:12px; }
      }
      .breadcrumb-nav{
        margin:0 0 12px 0;
        color:var(--muted);
        font-size:0.9rem;
      }
      .breadcrumb-nav ol{
        list-style:none;
        padding:0;
        margin:0;
        display:flex;
        flex-wrap:wrap;
        gap:6px;
        align-items:center;
      }
      .breadcrumb-nav li{
        display:flex;
        align-items:center;
        gap:6px;
      }
      .breadcrumb-nav li+li::before{
        content:'/';
        color:var(--muted);
        opacity:0.5;
      }
      .breadcrumb-nav a{
        color:var(--accent);
        font-weight:700;
        text-decoration:none;
      }
      .breadcrumb-nav a:hover{
        color:var(--accent-strong);
      }
      .controls-row{
        display:flex;
        align-items:flex-start;
        gap:16px 20px;
        flex-wrap:wrap;
        margin:12px 0 16px;
      }
      .nh48-lang{
        display:flex;
        align-items:center;
        gap:6px;
        flex-wrap:wrap;
        margin:0;
      }
      .nh48-lang-menu{
        position:relative;
      }
      .nh48-lang-toggle{
        display:inline-flex;
        align-items:center;
        gap:8px;
        min-height:36px;
        padding:4px 10px;
        border-radius:10px;
        border:2px solid #ffffff;
        background:var(--card);
        color:var(--ink);
        cursor:pointer;
        font-size:0.85rem;
        text-transform:uppercase;
        letter-spacing:0.6px;
      }
      .nh48-lang-toggle .flag{
        font-size:18px;
      }
      .nh48-lang-toggle-text{
        white-space:nowrap;
      }
      .nh48-lang-caret{
        font-size:0.65rem;
        margin-left:2px;
        opacity:0.8;
      }
      .nh48-lang-options{
        position:absolute;
        right:0;
        top:calc(100% + 8px);
        background:var(--card);
        border:2px solid #ffffff;
        border-radius:12px;
        padding:8px;
        display:grid;
        grid-template-columns:repeat(4, minmax(0, 1fr));
        gap:6px;
        min-width:220px;
        box-shadow:0 12px 28px rgba(15, 23, 42, 0.35);
        opacity:0;
        pointer-events:none;
        transform:translateY(-6px);
        transition:opacity 0.15s ease, transform 0.15s ease;
        z-index:4;
      }
      .nh48-lang-menu.open .nh48-lang-options{
        opacity:1;
        pointer-events:auto;
        transform:translateY(0);
      }
      .units-control{
        display:flex;
        align-items:center;
        gap:8px;
        margin:0;
      }
      .units-control label{
        font-size:0.75rem;
        color:#ffffff;
        text-transform:uppercase;
        letter-spacing:0.8px;
      }
      .units-control select{
        background:var(--card);
        color:var(--ink);
        border:2px solid #ffffff;
        border-radius:10px;
        padding:6px 10px;
        font-size:0.85rem;
        appearance:none;
        -webkit-appearance:none;
        -moz-appearance:none;
        padding-right:34px;
        background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='8' viewBox='0 0 12 8'%3E%3Cpath fill='%23ffffff' d='M1 1l5 5 5-5'/%3E%3C/svg%3E");
        background-repeat:no-repeat;
        background-position:right 10px center;
        background-size:12px;
      }
      .nh48-lang-label{
        font-size:0.75rem;
        color:#ffffff;
        text-transform:uppercase;
        letter-spacing:0.8px;
        margin-right:4px;
      }
      .nh48-flag{
        width:34px;
        height:34px;
        border-radius:8px;
        border:2px solid #ffffff;
        background:var(--card);
        color:var(--ink);
        display:flex;
        align-items:center;
        justify-content:center;
        cursor:pointer;
        transition:border-color 0.2s ease, box-shadow 0.2s ease, transform 0.2s ease;
      }
      .nh48-flag .flag{
        font-size:18px;
        line-height:1;
      }
      .nh48-flag.active{
        border-color:var(--accent);
        box-shadow:0 0 0 2px rgba(34, 197, 94, 0.25);
      }
      .nh48-flag:focus-visible{
        outline:2px solid var(--accent);
        outline-offset:2px;
      }
      .seo-links{
        display:flex;
        flex-direction:column;
        gap:6px;
        margin-bottom:16px;
      }
      .seo-links a{
        color:var(--accent);
        text-decoration:none;
        font-size:0.95rem;
      }
      .back-guide{
        display:inline-flex;
        align-items:center;
        gap:6px;
        color:var(--ink);
        text-decoration:none;
        font-weight:800;
        margin:4px 0 16px;
        letter-spacing:0.2px;
      }
      .back-guide:hover{
        color:var(--accent);
      }
      .related-trails{
        margin:16px 0 20px;
        padding:12px 16px;
        background:var(--panel);
        border:1px solid var(--stroke);
        border-radius:10px;
      }
      .related-trails h2{
        margin:0 0 8px;
        font-size:1rem;
      }
      .related-trails ul{
        margin:0;
        padding-left:1.1rem;
        color:var(--ink);
        font-size:0.9rem;
      }
      .related-trails a{
        color:var(--accent);
        text-decoration:none;
      }
      h1{
        margin:0 0 16px;
        font-size:clamp(22px,4vw,30px);
        line-height:1.2;
      }
      @media(max-width:640px){
        h1{ margin:0 0 12px; font-size:clamp(18px,5vw,24px); }
      }

      /* MEDIA / CAROUSEL ---------------------------------------------------- */
      .media{
        background:var(--card);
        border:1px solid var(--stroke);
        border-radius:12px;
        overflow:hidden;
        margin-bottom:16px;
        position:relative;
        aspect-ratio:4/3;
        min-height:clamp(240px, 60vw, 520px);
        max-height:min(65vh, 640px);
        box-sizing:border-box;
        box-shadow:0 18px 46px rgba(0,0,0,0.35);
      }
      .media-loading{
        position:absolute;
        inset:0;
        display:flex;
        align-items:center;
        justify-content:center;
        gap:10px;
        background:rgba(10, 10, 10, 0.6);
        color:var(--accent);
        z-index:4;
      }
      .media-loading[hidden]{
        display:none;
      }
      .loading-spinner{
        width:22px;
        height:22px;
        border-radius:50%;
        border:3px solid rgba(34, 197, 94, 0.25);
        border-top-color:var(--accent);
        animation:spin 0.9s linear infinite;
      }
      .loading-text{
        font-size:0.9rem;
        color:var(--muted);
      }
      .carousel{
        position:relative;
        width:100%;
        height:100%;
        overflow:hidden;
      }
      .slide{
        position:absolute;
        inset:0;
        opacity:0;
        transition:opacity .35s ease;
      }
      .slide.active{ opacity:1; }
      .slide figure{
        margin:0;
        display:flex;
        align-items:center;
        justify-content:center;
        padding:6px;
        box-sizing:border-box;
        height:100%;
      }
      .slide figure img{
        max-height:100%;
        width:100%;
        height:100%;
        object-fit:contain;
        object-position:center;
        display:block;
        border-radius:8px;
      }
      .dots{
        position:absolute;
        bottom:12px;
        left:12px;
        right:12px;
        display:flex;
        gap:10px;
        padding:10px;
        background:rgba(10,10,10,0.55);
        border:1px solid rgba(255,255,255,0.18);
        border-radius:12px;
        backdrop-filter:blur(6px);
        overflow-x:auto;
        z-index:2;
      }
      .dot{
        width:70px;
        height:46px;
        border-radius:10px;
        border:1px solid rgba(255,255,255,0.35);
        background-size:cover;
        background-position:center;
        background-repeat:no-repeat;
        background-color:#0f1118;
        cursor:pointer;
        opacity:0.8;
        transition:transform 0.2s ease, opacity 0.2s ease, border-color 0.2s ease;
        flex:0 0 auto;
        padding:0;
        appearance:none;
      }
      .dot:focus-visible{
        outline:2px solid var(--accent);
        outline-offset:2px;
      }
      .dot:hover{ opacity:1; transform:translateY(-2px); }
      .dot.active{
        opacity:1;
        border-color:var(--accent);
        box-shadow:0 10px 24px rgba(0,0,0,0.35);
      }
      .ctrls{
        position:absolute;
        inset:0;
        display:flex;
        justify-content:space-between;
        align-items:center;
        pointer-events:none;
      }
      .ctrls button{
        background:rgba(10,10,10,0.5);
        border:1px solid rgba(255,255,255,0.45);
        color:#ffffff;
        border-radius:50%;
        width:42px;
        height:42px;
        padding:0;
        margin:0 10px;
        cursor:pointer;
        pointer-events:auto;
        display:flex;
        align-items:center;
        justify-content:center;
        font-size:1.25rem;
        box-shadow:0 12px 28px rgba(0,0,0,0.35);
        transition:transform 0.2s ease, background 0.2s ease, border-color 0.2s ease;
      }
      .ctrls button:hover{ background:rgba(10,10,10,0.7); border-color:var(--accent); transform:translateY(-1px); }
      .ctrls button:focus-visible{ outline:2px solid var(--accent); outline-offset:2px; }

      /* Countdown timer styles ---------------------------------------------- */
      .timer{
        position:absolute;
        top:8px;
        right:8px;
        display:flex;
        align-items:center;
        gap:8px;
        padding:6px 8px;
        background:rgba(0,0,0,0.35);
        border-radius:12px;
        z-index:3;
      }
      .timer-visual{
        position:relative;
        width:56px;
        height:56px;
        display:flex;
        align-items:center;
        justify-content:center;
      }
      .timer svg{
        width:100%;
        height:100%;
        transform:rotate(-90deg);
      }
      .timer-ring{
        fill:none;
        stroke:var(--accent);
        stroke-width:4;
        stroke-linecap:round;
        transition:stroke-dashoffset 0.1s linear;
      }
      .timer-text{
        position:absolute;
        color:var(--accent);
        font-size:0.8rem;
        font-weight:600;
        pointer-events:none;
      }
      .timer-pause{
        background:rgba(255,255,255,0.15);
        color:var(--accent);
        border:1px solid rgba(255,255,255,0.25);
        border-radius:50%;
        width:32px;
        height:32px;
        display:flex;
        align-items:center;
        justify-content:center;
        font-weight:700;
        cursor:pointer;
        transition:background 0.2s ease, transform 0.2s ease;
      }
      .timer-pause:focus-visible{
        outline:2px solid var(--accent);
        outline-offset:2px;
      }
      .timer-pause:hover{
        background:rgba(255,255,255,0.25);
        transform:scale(1.02);
      }

      /* SHARED PANEL + ROW STYLE -------------------------------------------- */
      .meta-info-row{
        display:grid;
        grid-template-columns:1fr 1fr;
        gap:12px;
        margin-bottom:16px;
      }
      @media(max-width:800px){
        .meta-info-row{
          grid-template-columns:1fr;
        }
      }
      .metadata-panel{
        background:var(--panel);
        border:1px solid var(--stroke);
        border-radius:10px;
        padding:12px;
        font-size:0.9rem;
        word-wrap:break-word;
        white-space:normal;
        width:100%;
        box-sizing:border-box;
        box-shadow:0 12px 30px rgba(0,0,0,0.3);
      }
      .metadata-header{
        display:flex;
        justify-content:space-between;
        align-items:center;
        margin-bottom:6px;
        gap:8px;
      }
      .metadata-title{
        font-weight:600;
        color:var(--accent);
        font-size:0.85rem;
        text-transform:uppercase;
        letter-spacing:0.5px;
      }
      .meta-toggle{
        background:transparent;
        border:none;
        color:var(--muted);
        font-size:0.8rem;
        cursor:pointer;
        padding:0;
      }
      .metadata-primary,
      .metadata-extra{
        width:100%;
      }
      .metadata-extra{
        display:none;
        margin-top:4px;
      }
      .metadata-extra.open{
        display:block;
      }
      .metadata-row{
        display:flex;
        justify-content:space-between;
        align-items:flex-start;
        gap:12px;
        padding:6px 0;
        border-bottom:1px dotted var(--stroke);
      }
      .metadata-row:last-child{
        border-bottom:none;
      }
      .metadata-label{
        font-weight:600;
        color:var(--muted);
        font-size:0.8rem;
        text-transform:uppercase;
        letter-spacing:0.3px;
        max-width:45%;
      }
      .metadata-value{
        color:var(--ink);
        font-size:0.9rem;
        text-align:right;
        flex:1 1 auto;
        word-break:break-word;
      }
      .description-body{
        font-size:1rem;
        line-height:1.6;
        color:var(--ink);
        margin-top:4px;
      }

      h1#peakTitle{
        margin:12px 0 6px 0;
        font-size:1.75rem;
      }
      .section-title{
        margin:20px 0 12px 0;
        font-size:1.05rem;
        font-weight:700;
        color:var(--accent);
        text-transform:uppercase;
        letter-spacing:0.5px;
      }
      @media(max-width:640px){
        .section-title{ margin:16px 0 10px 0; font-size:0.95rem; }
      }
      .info-grid{
        display:grid;
        gap:10px;
        grid-template-columns:1fr;
        margin-bottom:16px;
      }
      .info-panel{
        background:var(--panel);
        border:1px solid var(--stroke);
        border-radius:10px;
        padding:12px;
        font-size:0.9rem;
        width:100%;
        box-sizing:border-box;
        box-shadow:0 10px 24px rgba(0,0,0,0.25);
      }
      @media(max-width:640px){
        .info-panel{ padding:10px; font-size:0.85rem; }
      }
      .info-label{
        font-weight:600;
        color:var(--accent);
        font-size:0.85rem;
        margin-bottom:6px;
        text-transform:uppercase;
        letter-spacing:0.5px;
      }
      @media(max-width:640px){
        .info-label{ font-size:0.8rem; margin-bottom:4px; }
      }
      .info-value{
        color:var(--ink);
        font-size:0.9rem;
        word-wrap:break-word;
        white-space:normal;
      }
      .trail-list{
        margin:0;
        padding-left:1.1rem;
        color:var(--ink);
        font-size:0.9rem;
        line-height:1.5;
      }
      .trail-branding{
        display:flex;
        align-items:center;
        gap:10px;
        margin:6px 0 10px;
        padding:10px;
        border:1px solid var(--stroke);
        border-radius:8px;
        background:linear-gradient(135deg, rgba(34,197,94,0.08), rgba(10,10,10,0.35));
        text-decoration:none;
        color:var(--ink);
      }
      .trail-branding img{
        width:52px;
        height:auto;
        border-radius:8px;
        background:#0a0a0a;
        border:1px solid rgba(255,255,255,0.2);
        padding:4px;
        box-shadow:0 6px 14px rgba(0,0,0,0.35);
      }
      .trail-branding-text{
        display:flex;
        flex-direction:column;
        gap:2px;
        font-size:0.85rem;
      }
      .trail-branding-text strong{
        color:var(--accent);
        font-size:0.9rem;
      }
      .trail-list a{
        color:var(--ink);
        text-decoration:underline;
        text-decoration-color:var(--stroke);
        text-underline-offset:3px;
        text-decoration-thickness:1px;
        transition:color 0.2s ease, text-decoration-color 0.2s ease;
      }
      .trail-list a:hover{
        color:var(--accent);
        text-decoration-color:var(--accent);
      }
      .peak-map-panel{
        border:1px solid var(--stroke);
        border-radius:12px;
        background:linear-gradient(160deg, rgba(18,18,26,0.95), rgba(10,10,10,0.85));
        padding:14px;
        margin-bottom:16px;
        box-shadow:0 12px 28px rgba(0,0,0,0.35);
      }
      .peak-map-header{
        display:flex;
        align-items:flex-start;
        justify-content:space-between;
        gap:16px;
        margin-bottom:10px;
        flex-wrap:wrap;
      }
      .peak-map-title{
        font-size:0.95rem;
        font-weight:700;
        color:var(--ink);
      }
      .peak-map-subtitle{
        font-size:0.8rem;
        color:var(--muted);
        margin-top:2px;
      }
      .peak-map-cta{
        display:inline-flex;
        align-items:center;
        gap:6px;
        padding:8px 14px;
        border-radius:999px;
        border:1px solid rgba(34,197,94,0.8);
        background:rgba(34,197,94,0.15);
        color:var(--accent);
        font-weight:700;
        text-decoration:none;
        transition:all 0.2s ease;
        white-space:nowrap;
      }
      .peak-map-cta:hover{
        background:rgba(34,197,94,0.25);
        color:var(--accent-strong);
        border-color:rgba(34,197,94,1);
      }
      .peak-map-frame{
        position:relative;
        width:100%;
        height:320px;
        border-radius:10px;
        overflow:hidden;
        border:1px solid rgba(255,255,255,0.15);
        background:#0b0b10;
      }
      .peak-map-canvas{
        position:absolute;
        inset:0;
      }
      .peak-map-status{
        position:absolute;
        inset:auto 12px 12px 12px;
        background:rgba(10,10,10,0.75);
        border:1px solid rgba(255,255,255,0.1);
        border-radius:8px;
        padding:6px 10px;
        font-size:0.78rem;
        color:var(--muted);
      }
      .peak-map-tooltip{
        background:rgba(10,10,10,0.8);
        border:1px solid rgba(34,197,94,0.8);
        color:var(--ink);
        font-weight:700;
        font-size:0.78rem;
        padding:4px 8px;
        border-radius:8px;
        box-shadow:0 6px 16px rgba(0,0,0,0.3);
      }
      .leaflet-container{
        background:#0b0b10;
      }
      @keyframes spin{
        to{ transform:rotate(360deg); }
      }
    </style>
  </head>
  <body data-route="peak" data-page="peak">
    <script>
      window.NH48_ROUTE_INFO = window.NH48_ROUTE_INFO || (function(){
        return {
          slug: '',
          isFrench: false
        };
      })();
    </script>
    <div id="nav-placeholder"></div>
    <script>
      document.addEventListener('DOMContentLoaded', () => {
        const navPlaceholder = document.getElementById('nav-placeholder');
        const activeRoute = document.body.dataset.route || document.body.dataset.page;

        if (navPlaceholder) {
          fetch('/pages/nav.html')
            .then(response => response.text())
            .then(html => {
              navPlaceholder.innerHTML = html;
              const links = navPlaceholder.querySelectorAll('.site-nav-links a');
              links.forEach(link => {
                const routes = (link.dataset.routes || link.dataset.route || '')
                  .split(',')
                  .map(value => value.trim())
                  .filter(Boolean);

                if (routes.includes(activeRoute)) {
                  link.classList.add('active');
                  link.setAttribute('aria-current', 'page');
                }
              });
              if (window.NH48_I18N && window.NH48_I18N.refreshLangPicker) {
                window.NH48_I18N.refreshLangPicker();
              }
            })
            .catch(err => console.error('Failed to load navigation:', err));
        }
      });
    </script>
    <div class="wrap">
      <nav class="breadcrumb-nav" aria-label="Breadcrumb" id="breadcrumbNav">
        <ol itemscope itemtype="https://schema.org/BreadcrumbList">
          <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
            <a itemprop="item" href="/" id="breadcrumbHomeLink"><span itemprop="name" data-i18n="common.home">Home</span></a>
            <meta itemprop="position" content="1">
          </li>
          <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
            <a itemprop="item" href="/catalog" id="breadcrumbCatalogLink"><span itemprop="name" data-i18n="peak.catalog">Peak Catalog</span></a>
            <meta itemprop="position" content="2">
          </li>
          <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
            <span itemprop="name" id="breadcrumbCurrent" data-i18n="peak.loading">Loading…</span>
            <meta id="breadcrumbCurrentUrl" itemprop="item" content="">
            <meta itemprop="position" content="3">
          </li>
        </ol>
      </nav>
      <div class="seo-links">
        <a href="/catalog" data-i18n="peak.back">Back to NH48 Peak Catalog</a>
      </div>
      <div class="controls-row">
        <div class="units-control">
          <label for="unitsSelect" data-i18n="common.unitsLabel">Units</label>
          <select id="unitsSelect" data-i18n="common.units" data-i18n-attr="aria-label" aria-label="Select units">
            <option value="feet" data-i18n="common.unitsFeet">Feet</option>
          <option value="meters" data-i18n="common.unitsMeters">Meters</option>
          </select>
        </div>
      </div>
      <a class="back-guide" href="/nh-4000-footers-guide">NH48 Info</a>
      <h1 id="peakTitle" data-i18n="peak.loading">Loading…</h1>

      <!-- MEDIA / CAROUSEL ---------------------------------------------------->
      <div class="media" id="media" hidden>
        <div class="media-loading" id="mediaLoading">
          <span class="loading-spinner" aria-hidden="true"></span>
          <span class="loading-text" data-i18n="common.loading">Loading…</span>
        </div>
        <div class="carousel" id="carousel"></div>
        <div class="dots" id="dots"></div>
        <div class="ctrls">
          <button id="prevBtn" data-i18n="peak.carousel.prev" data-i18n-attr="aria-label" aria-label="Previous image">‹</button>
          <button id="nextBtn" data-i18n="peak.carousel.next" data-i18n-attr="aria-label" aria-label="Next image">›</button>
        </div>
        <!-- Countdown timer overlay -->
        <div class="timer" id="carouselTimer" hidden>
          <div class="timer-visual">
            <svg viewBox="0 0 40 40">
              <circle id="timerRing" class="timer-ring" cx="20" cy="20" r="18"></circle>
            </svg>
            <span id="timerText" class="timer-text"></span>
          </div>
          <button id="carouselPauseBtn" type="button" class="timer-pause" aria-label="Pause carousel" aria-pressed="false" title="Pause carousel">❚❚</button>
        </div>
      </div>


      <div id="peakDescriptionPanel" class="metadata-panel" hidden style="margin-bottom:16px;"></div>
      <!-- GENERAL INFO ABOVE METADATA PANEL (STACKED, FULL WIDTH) ------------->
      <div id="generalInfoPanel" class="metadata-panel" hidden style="margin-bottom:16px;"></div>
      <div id="photoMetadataPanel" class="metadata-panel" hidden></div>

      <!-- OTHER SECTIONS ------------------------------------------------------>
      <section aria-labelledby="routesHeading">
        <h2 id="routesHeading" class="section-title" data-i18n="peak.section.routes">Hiking Routes</h2>
        <div class="peak-map-panel" id="peakMapPanel" hidden>
          <span id="peak-trail-map" class="sr-only">Peak trail map</span>
          <div class="peak-map-header">
            <div>
              <div class="peak-map-title" id="peakMapTitle">Peak Trail Map</div>
              <div class="peak-map-subtitle" id="peakMapSubtitle">OpenStreetMap topographic view with WMNF trail overlays.</div>
            </div>
            <a class="peak-map-cta" id="peakMapCta" href="/trails">White Mountain Trails →</a>
          </div>
          <div class="peak-map-frame">
            <div class="peak-map-canvas" id="peakMap" role="img" aria-label="Topographic map of the peak area"></div>
            <div class="peak-map-status" id="peakMapStatus">Loading trail map…</div>
          </div>
        </div>
        <div class="info-grid" id="routesGrid" hidden></div>
      </section>

      <section aria-labelledby="relatedTrailsHeading">
        <h2 id="relatedTrailsHeading" class="section-title" data-i18n="peak.relatedTrails.title">Related Trails &amp; Routes</h2>
        <div class="info-grid" id="relatedTrailsGrid" hidden></div>
      </section>

      <section aria-labelledby="trailNamesHeading">
        <h2 id="trailNamesHeading" class="section-title" data-i18n="peak.section.trails">Associated Trails</h2>
        <div class="info-grid" id="trailNamesGrid" hidden></div>
      </section>

      <section aria-labelledby="terrainHeading">
        <h2 id="terrainHeading" class="section-title" data-i18n="peak.section.terrain">Trail &amp; Terrain</h2>
        <div class="info-grid" id="terrainGrid" hidden></div>
      </section>

      <section aria-labelledby="conditionsHeading">
        <h2 id="conditionsHeading" class="section-title" data-i18n="peak.section.conditions">Conditions &amp; Access</h2>
        <div class="info-grid" id="conditionsGrid" hidden></div>
      </section>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
    <script>
      /* API endpoints */
      const API_URLS = [
        'https://cdn.jsdelivr.net/gh/natesobol/nh48-api@main/data/nh48.json',
        'https://raw.githubusercontent.com/natesobol/nh48-api/main/data/nh48.json',
        '/data/nh48.json'
      ];
      const TRAIL_API_URLS = [
        '/data/wmnf-trails/wmnf-normalized.json',
        'https://cdn.jsdelivr.net/gh/natesobol/nh48-api@main/data/wmnf-trails/wmnf-normalized.json',
        'https://raw.githubusercontent.com/natesobol/nh48-api/main/data/wmnf-trails/wmnf-normalized.json'
      ];
      const MAP_RADIUS_MILES = 2.5;

      const t = (key, vars) => (window.NH48_I18N && window.NH48_I18N.t ? window.NH48_I18N.t(key, vars) : key);

      const translateWithFallback = (key, fallback, vars = {}) => {
        const translated = t(key, vars);
        return translated === key ? fallback : translated;
      };

      const trackEvent = (name, params = {}) => {
        const analytics = window.NH48_INFO_ANALYTICS;
        if (analytics && analytics.logEvent && analytics.analytics) {
          analytics.logEvent(analytics.analytics, name, {
            page: location.pathname,
            ...params
          });
        }
      };

      const UNIT_STORAGE_KEY = 'nh48_units';
      const UNITS = {
        FEET: 'feet',
        METERS: 'meters'
      };
      const TRAIL_KEYWORDS = [
        'Trail',
        'Path',
        'Ridge',
        'Brook',
        'River',
        'Notch',
        'Road',
        'Cutoff',
        'Loop',
        'Slide',
        'Spur',
        'Connector'
      ];
      let currentUnits = UNITS.FEET;

      /* Fallback image */
      function getPlaceholder() {
        return 'data:image/svg+xml;utf8,' + encodeURIComponent(
          `<svg xmlns="http://www.w3.org/2000/svg" width="1200" height="800"><rect width="100%" height="100%" fill="#172032"/><text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="#64748b" font-family="system-ui" font-size="22">${t('common.noImage')}</text></svg>`
        );
      }

      const BASE_CANONICAL = 'https://nh48.info/peak';
      const BASE_CANONICAL_FR = 'https://nh48.info/fr/peak';
      const HOME_URL = 'https://nh48.info/';
      const CATALOG_URL = 'https://nh48.info/catalog';
      const DEFAULT_OG_IMAGE = 'https://nh48.info/nh48API_logo.png';
      const IMAGE_TRANSFORM_OPTIONS = 'format=webp,quality=85';
      const PHOTO_BASE_URL = 'https://photos.nh48.info';
      const PHOTO_BASE = new URL(PHOTO_BASE_URL);
      const IMAGE_TRANSFORM_PREFIX = `${PHOTO_BASE.origin}/cdn-cgi/image/${IMAGE_TRANSFORM_OPTIONS}`;
      const PHOTO_PATH_PREFIX = '/nh48-photos/';

      function getResolvedSlug(){
        const info = window.NH48_ROUTE_INFO || getRouteInfo(window.location.pathname);
        if(info && info.slug){
          return info.slug;
        }
        const params = new URLSearchParams(window.location.search);
        return params.get('slug');
      }

      function applyImageTransform(url){
        if(!url) return url;
        try {
          const parsed = new URL(url, window.location.origin);
          if(parsed.hostname === PHOTO_BASE.hostname){
            const normalizedPath = parsed.pathname.startsWith('/') ? parsed.pathname : `/${parsed.pathname}`;
            return `${IMAGE_TRANSFORM_PREFIX}${normalizedPath}`;
          }
        } catch (error) {
          console.warn('Unable to normalize photo URL', url, error);
        }
        return url;
      }

      function normalizePhotoUrl(url){
        if(!url) return url;
        if(url.startsWith(PHOTO_BASE_URL)) return applyImageTransform(url);
        const isJsdelivrPhoto = url.includes('cdn.jsdelivr.net/gh/natesobol/nh48-api@main/photos/');
        const isGithubRawPhoto = url.includes('raw.githubusercontent.com/natesobol/nh48-api/main/photos/');
        const isR2PathStyle = url.includes('r2.cloudflarestorage.com/nh48-photos/');
        const isR2BucketHost = url.includes('r2.cloudflarestorage.com/') && !url.includes('/nh48-photos/');
        let normalized = url;
        if(isR2PathStyle){
          const [, tail] = url.split(PHOTO_PATH_PREFIX);
          normalized = tail ? `${PHOTO_BASE_URL}/${tail}` : url;
        }
        if(isR2BucketHost){
          const bucketTail = url.split('r2.cloudflarestorage.com/')[1];
          if(bucketTail){
            const normalizedTail = bucketTail.replace(/^nh48-photos\//, '');
            normalized = `${PHOTO_BASE_URL}/${normalizedTail}`;
          }
        }
        if(isJsdelivrPhoto || isGithubRawPhoto){
          const [, tail] = url.split('/photos/');
          normalized = tail ? `${PHOTO_BASE_URL}/${tail}` : url;
        }
        if(normalized.startsWith(PHOTO_BASE_URL)){
          return applyImageTransform(normalized);
        }
        return normalized;
      }

      function setMeta(name, content){
        let el = document.querySelector(`meta[name="${name}"]`);
        if(!el){
          el = document.createElement('meta');
          el.setAttribute('name', name);
          document.head.appendChild(el);
        }
        el.setAttribute('content', content);
      }

      function setMetaProperty(property, content){
        let el = document.querySelector(`meta[property="${property}"]`);
        if(!el){
          el = document.createElement('meta');
          el.setAttribute('property', property);
          document.head.appendChild(el);
        }
        el.setAttribute('content', content);
      }

      function updatePeakTitle(name){
        const peakTitle = document.getElementById('peakTitle');
        if(!peakTitle) return;
        peakTitle.textContent = name;
        if(peakTitle.hasAttribute('data-i18n')){
          peakTitle.removeAttribute('data-i18n');
        }
      }

      function parseCoordinates(coordStr){
        if(!coordStr) return null;
        const cleaned = coordStr.split(':')[0].trim();
        const [lat, lon] = cleaned.split(',').map(v => parseFloat(v));
        if(Number.isFinite(lat) && Number.isFinite(lon)){
          return { lat, lon };
        }
        return null;
      }

      function escapeHtml(value){
        return String(value || '')
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;');
      }

      function safeText(value){
        if(value === undefined || value === null) return '';
        if(typeof value === 'string' || typeof value === 'number') return String(value);
        if(typeof value === 'object'){
          const localized = value.en || value.fr || value.default || value.text;
          if(typeof localized === 'string' || typeof localized === 'number'){
            return String(localized);
          }
        }
        return '';
      }

      function parseDimensions(value){
        if(!value) return { width: null, height: null };
        const match = String(value).replace(/×/g, 'x').match(/(\d+)\s*x\s*(\d+)/i);
        if(!match) return { width: null, height: null };
        return { width: Number(match[1]), height: Number(match[2]) };
      }

      function numberFrom(value){
        if(value === undefined || value === null) return null;
        const match = String(value).match(/-?\d+(?:\.\d+)?/);
        return match ? Number(match[0]) : null;
      }

      function normalizeToken(value){
        return String(value || '').trim().toLowerCase();
      }

      function translateSeason(value){
        const key = normalizeToken(value);
        const map = {
          spring: 'season.spring',
          summer: 'season.summer',
          fall: 'season.fall',
          autumn: 'season.autumn',
          winter: 'season.winter'
        };
        return map[key] ? t(map[key]) : value;
      }

      function translateTimeOfDay(value){
        const key = normalizeToken(value);
        const map = {
          sunrise: 'time.sunrise',
          sunset: 'time.sunset',
          morning: 'time.morning',
          afternoon: 'time.afternoon',
          evening: 'time.evening',
          night: 'time.night',
          day: 'time.day',
          dawn: 'time.dawn',
          dusk: 'time.dusk'
        };
        return map[key] ? t(map[key]) : value;
      }

      const TRAIL_TYPE_TRANSLATIONS = {
        'Loop': 'values.trailType.loop',
        'Loop or Out & back': 'values.trailType.loop_or_out_back',
        'Loop or traverse': 'values.trailType.loop_or_traverse',
        'Loop or traverse along ridge': 'values.trailType.loop_or_traverse_along_ridge',
        'Out & back': 'values.trailType.out_back',
        'Out & back  - common.': 'values.trailType.out_back_common',
        'Out & back  - common. or long traverse': 'values.trailType.out_back_common_or_long_traverse',
        'Out & back  - common. or loop with connector trails': 'values.trailType.out_back_common_or_loop_with_connector_trails',
        'Out & back  - common. or small loop including Mt Webster': 'values.trailType.out_back_common_or_small_loop_including_mt_webster',
        'Out & back  - commonly.': 'values.trailType.out_back_commonly',
        'Out & back or loop': 'values.trailType.out_back_or_loop',
        'Out & back or loop  - with Tom and Willey.': 'values.trailType.out_back_or_loop_with_tom_and_willey',
        'Out & back or loop combining trails': 'values.trailType.out_back_or_loop_combining_trails',
        'Out & back or loop options': 'values.trailType.out_back_or_loop_options',
        'Out & back or point-to-point traverse': 'values.trailType.out_back_or_point_to_point_traverse',
        'Out & back or traverse': 'values.trailType.out_back_or_traverse'
      };

      const DIFFICULTY_TRANSLATIONS = {
        'Moderate': 'values.difficulty.moderate',
        'Moderate/Difficult': 'values.difficulty.moderate_difficult',
        'Difficult': 'values.difficulty.difficult',
        'Very Difficult': 'values.difficulty.very_difficult',
        'Very difficult': 'values.difficulty.very_difficult',
        'Extremely Difficult': 'values.difficulty.extremely_difficult'
      };

      function translateTrailType(value){
        if(!value) return value;
        const raw = String(value);
        const key = raw.startsWith('values.trailType.') ? raw : TRAIL_TYPE_TRANSLATIONS[raw];
        if(!key) return value;
        const translated = t(key);
        return translated && translated !== key && !translated.startsWith('values.') ? translated : value;
      }

      function translateDifficulty(value){
        if(!value) return value;
        const raw = String(value);
        const key = raw.startsWith('values.difficulty.') ? raw : DIFFICULTY_TRANSLATIONS[raw];
        if(!key) return value;
        const translated = t(key);
        return translated && translated !== key && !translated.startsWith('values.') ? translated : value;
      }

      function translateExposure(value){
        if(!value) return value;
        const trimmed = String(value).trim();
        if(trimmed.startsWith('values.exposure.')){
          const translated = t(trimmed);
          if(translated && translated !== trimmed && !translated.startsWith('values.exposure')){
            return translated;
          }
          return value;
        }
        const match = trimmed.match(/^(Low to Medium|Low|Medium|High)/i);
        if(!match) return value;
        const normalized = match[1].toLowerCase().replace(/\s+/g, '_');
        const translated = t(`values.exposure.${normalized}`);
        if(!translated || translated.startsWith('values.exposure')) return value;
        return trimmed.replace(match[1], translated);
      }

      function getSeoLang(){
        const params = new URLSearchParams(window.location.search);
        const paramLang = params.get('lang');
        const normalizedParam = paramLang ? paramLang.toLowerCase() : '';
        if(normalizedParam.startsWith('fr')) return 'fr';

        if(window.NH48_ROUTE_INFO && window.NH48_ROUTE_INFO.isFrench) return 'fr';

        const storedLang = localStorage.getItem('nh48_lang');
        if(storedLang && storedLang.toLowerCase().startsWith('fr')) return 'fr';

        const currentLang = window.NH48_I18N && window.NH48_I18N.getLang ? window.NH48_I18N.getLang() : 'en';
        if(currentLang && currentLang.toLowerCase().startsWith('fr')) return 'fr';
        return 'en';
      }

      function buildCanonicalUrl(slug, langCode){
        const base = langCode === 'fr' ? BASE_CANONICAL_FR : BASE_CANONICAL;
        if(!slug){
          return `${base}/`;
        }
        return `${base}/${encodeURIComponent(slug)}/`;
      }

      function updateHreflangLinks(slug){
        const enLink = document.getElementById('hreflangEn');
        const frLink = document.getElementById('hreflangFr');
        const defaultLink = document.getElementById('hreflangDefault');
        const enUrl = buildCanonicalUrl(slug, 'en');
        const frUrl = buildCanonicalUrl(slug, 'fr');

        if(enLink){
          enLink.setAttribute('href', enUrl);
        }
        if(frLink){
          frLink.setAttribute('href', frUrl);
        }
        if(defaultLink){
          defaultLink.setAttribute('href', enUrl);
        }
      }

      function updateBreadcrumbNav(name, canonicalUrl){
        const current = document.getElementById('breadcrumbCurrent');
        if(current){
          current.textContent = name;
          if(current.hasAttribute('data-i18n')){
            current.removeAttribute('data-i18n');
          }
        }
        const currentUrlMeta = document.getElementById('breadcrumbCurrentUrl');
        if(currentUrlMeta && canonicalUrl){
          currentUrlMeta.setAttribute('content', canonicalUrl);
        }
        const catalogLink = document.getElementById('breadcrumbCatalogLink');
        if(catalogLink){
          catalogLink.href = CATALOG_URL;
        }
        const homeLink = document.getElementById('breadcrumbHomeLink');
        if(homeLink){
          const langCode = getSeoLang();
          homeLink.href = langCode === 'fr' ? `${HOME_URL}fr/` : HOME_URL;
        }
      }

      function setBreadcrumbJsonLd(name, canonicalUrl){
        const langCode = getSeoLang();
        const homeUrl = langCode === 'fr' ? `${HOME_URL}fr/` : HOME_URL;
        const homeLabel = window.NH48_I18N && window.NH48_I18N.t ? window.NH48_I18N.t('common.home') : 'Home';
        const catalogLabel = window.NH48_I18N && window.NH48_I18N.t ? window.NH48_I18N.t('peak.catalog') : 'Peak Catalog';
        const breadcrumbSchema = {
          '@context': 'https://schema.org',
          '@type': 'BreadcrumbList',
          itemListElement: [
            {
              '@type': 'ListItem',
              position: 1,
              name: homeLabel,
              item: homeUrl
            },
            {
              '@type': 'ListItem',
              position: 2,
              name: catalogLabel,
              item: CATALOG_URL
            },
            {
              '@type': 'ListItem',
              position: 3,
              name,
              item: canonicalUrl
            }
          ]
        };

        let ld = document.getElementById('breadcrumbJsonLd');
        if(!ld){
          ld = document.createElement('script');
          ld.type = 'application/ld+json';
          ld.id = 'breadcrumbJsonLd';
          document.head.appendChild(ld);
        }
        ld.textContent = JSON.stringify(breadcrumbSchema);
      }

      function formatFeetValue(value){
        const num = numberFrom(value);
        if(num === null) return '—';
        if(currentUnits === UNITS.METERS){
          return `${Math.round(num * 0.3048)} m`;
        }
        return `${num} ft`;
      }

      function formatDistanceMiles(value){
        const num = numberFrom(value);
        if(num === null) return '—';
        if(currentUnits === UNITS.METERS){
          return `${(num * 1.60934).toFixed(1)} km`;
        }
        return `${num} mi`;
      }

      function setUnits(units, { persist = true } = {}){
        if(!Object.values(UNITS).includes(units)){
          units = UNITS.FEET;
        }
        currentUnits = units;
        const select = document.getElementById('unitsSelect');
        if(select){
          select.value = units;
        }
        if(persist){
          localStorage.setItem(UNIT_STORAGE_KEY, units);
        }
      }

      function syncUnitsWithLanguage(lang){
        if(lang && lang !== 'en'){
          setUnits(UNITS.METERS, { persist: false });
        }else{
          const stored = localStorage.getItem(UNIT_STORAGE_KEY);
          setUnits(stored || UNITS.FEET, { persist: false });
        }
      }

      function setMediaLoading(isLoading){
        const loading = document.getElementById('mediaLoading');
        if(loading){
          loading.hidden = !isLoading;
        }
      }

      function cleanAltValue(value){
        return (safeText(value) || '').replace(/\s+/g, ' ').trim();
      }

      function pickLocalizedText(meta, lang, keys){
        if(!meta || typeof meta !== 'object') return null;
        for(const key of keys){
          if(lang === 'fr'){
            const frCandidate = cleanAltValue(
              meta[`${key}_fr`] || meta[`${key}Fr`] || meta[`fr_${key}`]
            );
            if(frCandidate){
              return { text: frCandidate, lang: 'fr' };
            }
          }
          const base = cleanAltValue(meta[key]);
          if(base){
            return { text: base, lang: lang === 'fr' ? 'en' : (lang || 'en') };
          }
        }
        return null;
      }

      function pickPhotoLocalizedText(photo, keys){
        const lang = getSeoLang();
        if(!photo || typeof photo !== 'object') return null;
        const sources = [];
        if(photo.meta && typeof photo.meta === 'object') sources.push(photo.meta);
        if(photo.iptc && typeof photo.iptc === 'object') sources.push(photo.iptc);
        sources.push(photo);
        for(const source of sources){
          const candidate = pickLocalizedText(source, lang, keys);
          if(candidate) return candidate;
        }
        return null;
      }

      function buildPhotoAltText(name, photo){
        const lang = getSeoLang();
        const explicit = pickPhotoLocalizedText(photo, ['altText', 'alt']);
        if(explicit) return explicit;

        const described = pickPhotoLocalizedText(photo, [
          'headline',
          'title',
          'caption',
          'description',
          'extendedDescription',
        ]);
        if(described) return described;

        const tagsSource = photo && typeof photo === 'object' ? (photo.meta || photo) : null;
        const tags = Array.isArray(tagsSource && tagsSource.tags) ? tagsSource.tags.filter(Boolean) : [];
        if(tags.length){
          return { text: `${name} – ${tags.join(', ')}`, lang: lang === 'fr' ? 'fr' : (lang || 'en') };
        }

        return { text: `${name} in the White Mountains`, lang: lang === 'fr' ? 'en' : (lang || 'en') };
      }

      function buildPhotoExtendedDescription(photo){
        return (
          pickPhotoLocalizedText(photo, [
            'extendedDescription',
            'description',
            'caption',
            'headline',
          ]) || null
        );
      }

      function deferImageSrcSwap(root){
        if(!root) return;
        const imgs = Array.from(root.querySelectorAll('img[data-src]'));
        if(!imgs.length) return;
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            imgs.forEach(img => {
              const real = img.getAttribute('data-src');
              if(real){
                img.src = real;
                img.removeAttribute('data-src');
              }
            });
          });
        });
      }

      function buildMountainSchema(p, name, canonicalUrl, primaryPhoto, descriptionText){
        const coords = parseCoordinates(p['Coordinates']);
        const elevationFt = numberFrom(p['Elevation (ft)']);
        const prominenceFt = numberFrom(p['Prominence (ft)']);
        const difficulty = p['Difficulty'];
        const range = p['Range / Subrange'];
        const trailType = p['Trail Type'];
        const enriched = primaryPhoto ? enrichMetadata(primaryPhoto, primaryPhoto.iptc) : null;
        const photoAlt = primaryPhoto ? buildPhotoAltText(name, primaryPhoto) : null;
        const photoDescription = primaryPhoto ? buildPhotoExtendedDescription(primaryPhoto) : null;
        const photoUrl = primaryPhoto && (primaryPhoto.originalUrl || primaryPhoto.url);
        const photoContentUrl = primaryPhoto && primaryPhoto.url;
        const imageObject = primaryPhoto && primaryPhoto.url
          ? {
            '@type': 'ImageObject',
            url: photoUrl,
            contentUrl: photoContentUrl,
            name: (enriched && enriched.headline) || `${name} — White Mountain National Forest`,
            caption: (photoDescription && photoDescription.text) || descriptionText,
            creditText: (enriched && enriched.creditLine) || '© Nathan Sobol',
            creator: enriched && enriched.creator ? { '@type': 'Person', name: enriched.creator } : undefined,
            license: (enriched && enriched.rightsUsageTerms) || undefined,
            alternateName: photoAlt ? photoAlt.text : undefined,
            width: primaryPhoto.width || undefined,
            height: primaryPhoto.height || undefined
          }
          : null;
        const additionalProperty = [
          prominenceFt != null ? {
            '@type': 'PropertyValue',
            name: 'Prominence (ft)',
            value: prominenceFt,
            unitText: 'FT'
          } : null,
          difficulty ? {
            '@type': 'PropertyValue',
            name: 'Difficulty',
            value: difficulty
          } : null,
          range ? {
            '@type': 'PropertyValue',
            name: 'Range / Subrange',
            value: range
          } : null,
          trailType ? {
            '@type': 'PropertyValue',
            name: 'Trail Type',
            value: trailType
          } : null
        ].filter(Boolean);

        const schema = {
          '@context': 'https://schema.org',
          '@type': 'Mountain',
          name,
          description: descriptionText,
          url: canonicalUrl,
          image: imageObject ? [imageObject] : undefined,
          creator: enriched && enriched.creator ? { '@type': 'Person', name: enriched.creator } : undefined,
          publisher: enriched ? { '@type': 'Organization', name: 'NH48pics.com' } : undefined,
          license: enriched && enriched.rightsUsageTerms ? enriched.rightsUsageTerms : undefined,
          geo: coords ? { '@type': 'GeoCoordinates', latitude: coords.lat, longitude: coords.lon } : undefined,
          elevation: elevationFt != null ? {
            '@type': 'QuantitativeValue',
            value: elevationFt,
            unitText: 'FT'
          } : undefined,
          containedInPlace: range ? { '@type': 'Place', name: 'White Mountain National Forest' } : undefined,
          additionalProperty: additionalProperty.length ? additionalProperty : undefined
        };

        Object.keys(schema).forEach(key => {
          if(schema[key] === undefined){
            delete schema[key];
          }
        });

        let ld = document.getElementById('peakJsonLd');
        if(!ld){
          ld = document.createElement('script');
          ld.type = 'application/ld+json';
          ld.id = 'peakJsonLd';
          document.head.appendChild(ld);
        }
        ld.textContent = JSON.stringify(schema);
      }

      function cleanJSON(raw){
        let cleaned = raw.replace(/:contentReference\[.*?\]\{index=\d+\}/g, '');
        cleaned = cleaned.replace(/\/\*\s*Lines?\s+\d+[\d\-,\s]*omitted\s*\*\//g, '');
        return cleaned;
      }

      async function fetchPeaks(){
        for(let i=0; i<API_URLS.length; i++){
          const url = API_URLS[i];
          try{
            const res = await fetch(url, { mode:'cors' });
            if(!res.ok){
              console.log(`Attempt ${i+1}: Status ${res.status} ${res.statusText}`);
              continue;
            }
            const text = await res.text();
            const cleaned = cleanJSON(text);
            let data;
            try{
              data = JSON.parse(cleaned);
            }catch(err){
              console.error(`JSON parse error: ${err.message}`);
              continue;
            }
            console.log(`Loaded peak data from ${url}`);
            trackEvent('peak_data_loaded', { source: url });
            return data;
          }catch(err){
            console.error(`Fetch error: ${err.message || err}`);
            trackEvent('peak_data_fetch_error', { source: url });
          }
        }
        throw new Error('All API endpoints failed');
      }

      /* CAROUSEL + TIMER STATE ----------------------------------------------- */
      let carouselImgs = [];
      let carouselIdx = 0;
      let carouselTimer = null;
      let timerInterval = null;
      let photoMetaData = [];
      let currentDelay = 8000;
      const BASE_DELAY = 8000; // doubled from 4s
      let currentPeak = null;
      let currentSlug = null;
      let currentImages = [];
      let currentMeta = [];
      let currentPrimaryMeta = null;
      let currentPrimaryPhoto = null;
      let metadataExpanded = false;
      const metadataMobileQuery = window.matchMedia('(max-width: 720px)');
      let isCarouselPaused = false;
      const LANGUAGE_READY_TIMEOUT = 2000;
      let peakMap = null;
      let peakMapTrailsLayer = null;
      let peakMapMarker = null;
      let peakMapLabel = null;
      let peakMapBounds = null;
      let peakMapTrailDataPromise = null;

      async function waitForI18NReady(timeoutMs = LANGUAGE_READY_TIMEOUT){
        return new Promise((resolve) => {
          let resolved = false;
          const finish = () => {
            if(resolved) return;
            resolved = true;
            resolve();
          };

          const start = performance.now();
          const check = () => {
            const i18n = window.NH48_I18N;
            if(i18n && typeof i18n.t === 'function'){
              const sample = i18n.t('peak.generalInfo.title');
              if(sample && sample !== 'peak.generalInfo.title'){
                finish();
                return;
              }
            }
            if(performance.now() - start >= timeoutMs){
              finish();
              return;
            }
            requestAnimationFrame(check);
          };

          if(window.NH48_I18N && typeof window.NH48_I18N.onLangChange === 'function'){
            window.NH48_I18N.onLangChange(() => finish());
          }

          check();
        });
      }

      /* METADATA PANEL -------------------------------------------------------- */
      function enrichMetadata(meta = {}, iptc = {}){
        if(!meta || typeof meta !== 'object') return meta;

        const safeIptc = iptc && typeof iptc === 'object'
          ? iptc
          : (meta.iptc && typeof meta.iptc === 'object' ? meta.iptc : {});
        const pickText = (...values) => {
          for(const v of values){
            if(v !== undefined && v !== null && String(v).trim() !== ''){
              return v;
            }
          }
          return undefined;
        };

        const merged = {
          ...safeIptc,
          ...meta,
          altText: pickText(meta.altText, safeIptc.altText, safeIptc.description),
          alt: pickText(meta.alt, safeIptc.altText, safeIptc.description),
          extendedAlt: pickText(
            meta.extendedAlt,
            meta.extendedDescription,
            safeIptc.extendedDescription,
            safeIptc.description
          ),
          headline: pickText(meta.headline, safeIptc.headline),
          caption: pickText(meta.caption, safeIptc.description),
          description: pickText(meta.description, safeIptc.description),
          extendedDescription: pickText(meta.extendedDescription, safeIptc.extendedDescription),
          creator: pickText(meta.creator, safeIptc.creator, meta.author),
          creditLine: pickText(meta.creditLine, safeIptc.creditLine),
          source: pickText(meta.source, safeIptc.source),
          copyrightNotice: pickText(meta.copyrightNotice, safeIptc.copyrightNotice),
          copyrightStatus: pickText(meta.copyrightStatus, safeIptc.copyrightStatus),
          rightsUsageTerms: pickText(meta.rightsUsageTerms, safeIptc.rightsUsageTerms)
        };

        if(!merged.creator) merged.creator = 'Nathan Sobol';
        if(!merged.creditLine) merged.creditLine = '© Nathan Sobol / NH48pics.com';
        if(!merged.source) merged.source = 'nh48.info';
        if(!merged.copyrightNotice) merged.copyrightNotice = '© Nathan Sobol';
        if(!merged.copyrightStatus) merged.copyrightStatus = 'Copyrighted';
        if(!merged.rightsUsageTerms){
          merged.rightsUsageTerms =
            'No Unauthorized Reprint or Resale – Free to Reference Online';
        }
        if(meta.license) merged.license = meta.license;
        if(meta.credentials) merged.credentials = meta.credentials;

        const normalizePerson = (value) => {
          if(value === undefined || value === null) return '';
          return String(value).trim().toLowerCase();
        };
        const normalizedAuthor = normalizePerson(merged.author);
        const normalizedCreator = normalizePerson(merged.creator);
        if(normalizedAuthor && normalizedCreator && normalizedAuthor === normalizedCreator){
          delete merged.creator;
        }

        return merged;
      }

      function makeRow(label, value){
        const row = document.createElement('div');
        row.className = 'metadata-row';

        const lab = document.createElement('div');
        lab.className = 'metadata-label';
        lab.textContent = label;

        const val = document.createElement('div');
        val.className = 'metadata-value';
        val.textContent = value;

        row.appendChild(lab);
        row.appendChild(val);
        return row;
      }

      function humanLabelFromKey(key){
        const map = {
          season: 'peak.metadata.labels.season',
          timeOfDay: 'peak.metadata.labels.timeOfDay',
          orientation: 'peak.metadata.labels.orientation',
          captureDate: 'peak.metadata.labels.captureDate',
          cameraMaker: 'peak.metadata.labels.cameraMaker',
          cameraModel: 'peak.metadata.labels.cameraModel',
          camera: 'peak.metadata.labels.camera',
          lens: 'peak.metadata.labels.lens',
          fStop: 'peak.metadata.labels.fStop',
          shutterSpeed: 'peak.metadata.labels.shutterSpeed',
          iso: 'peak.metadata.labels.iso',
          exposureBias: 'peak.metadata.labels.exposureBias',
          focalLength: 'peak.metadata.labels.focalLength',
          flashMode: 'peak.metadata.labels.flashMode',
          meteringMode: 'peak.metadata.labels.meteringMode',
          maxAperture: 'peak.metadata.labels.maxAperture',
          author: 'peak.metadata.labels.author',
          dimensions: 'peak.metadata.labels.dimensions',
          fileSize: 'peak.metadata.labels.fileSize',
          fileCreateDate: 'peak.metadata.labels.fileCreateDate',
          fileModifiedDate: 'peak.metadata.labels.fileModifiedDate',
          rating: 'peak.metadata.labels.rating',
          metadata: 'peak.metadata.labels.metadata',
          creator: 'peak.metadata.labels.author',
          creditLine: 'peak.metadata.labels.creditLine',
          source: 'peak.metadata.labels.source',
          copyrightNotice: 'peak.metadata.labels.copyrightNotice',
          copyrightStatus: 'peak.metadata.labels.copyrightStatus',
          rightsUsageTerms: 'peak.metadata.labels.rightsUsageTerms',
          altText: 'peak.metadata.labels.altText',
          alt: 'peak.metadata.labels.alt',
          extendedAlt: 'peak.metadata.labels.extendedAlt',
          caption: 'peak.metadata.labels.caption',
          headline: 'peak.metadata.labels.headline',
          extendedDescription: 'peak.metadata.labels.extendedDescription',
          description: 'peak.metadata.labels.description'
        };
        if(map[key]) return t(map[key]);
        return key.replace(/([A-Z])/g, ' $1').replace(/^./, s => s.toUpperCase());
      }

      function entriesFromObject(prefixLabel, obj){
        const entries = [];
        if(!obj || typeof obj !== 'object') return entries;
        Object.entries(obj).forEach(([key, val]) => {
          if(val === undefined || val === null) return;
          if(typeof val === 'object' && !Array.isArray(val)){
            entries.push(...entriesFromObject(`${prefixLabel} — ${humanLabelFromKey(key)}`, val));
          }else{
            const valueText = Array.isArray(val) ? val.join(', ') : String(val).trim();
            if(valueText){
              entries.push([`${prefixLabel} — ${humanLabelFromKey(key)}`, valueText]);
            }
          }
        });
        return entries;
      }

      // Always-visible keys
      const PRIMARY_META_KEYS = [
        'captureDate',
        'season',
        'timeOfDay',
        'author',
        'creditLine'
      ];
      const SKIP_META_KEYS = new Set(['photoId','filename','url','isPrimary']);

      function applyMetadataState(open, extraWrap, toggleBtn, { track=false } = {}){
        metadataExpanded = open;
        if(extraWrap){
          extraWrap.classList.toggle('open', open);
        }
        if(toggleBtn){
          toggleBtn.textContent = open ? t('peak.metadata.lessDetails') : t('peak.metadata.moreDetails');
        }
        if(open){
          pauseCarousel('metadata_panel');
        }else{
          resumeCarousel('metadata_panel');
        }
        if(track){
          trackEvent('peak_metadata_toggle', { open });
        }
      }

      function applyMetadataState(open, extraWrap, toggleBtn, { track=false } = {}){
        metadataExpanded = open;
        if(extraWrap){
          extraWrap.classList.toggle('open', open);
        }
        if(toggleBtn){
          toggleBtn.textContent = open ? t('peak.metadata.lessDetails') : t('peak.metadata.moreDetails');
        }
        if(open){
          pauseCarousel('metadata_panel');
        }else{
          resumeCarousel('metadata_panel');
        }
        if(track){
          trackEvent('peak_metadata_toggle', { open });
        }
      }

      // --- Enhanced updateMetadata: group fields by type, show all, stacked layout ---
      function updateMetadata(i){
        const panel = document.getElementById('photoMetadataPanel');
        panel.innerHTML = '';

        const header = document.createElement('div');
        header.className = 'metadata-header';

        const title = document.createElement('div');
        title.className = 'metadata-title';
        title.textContent = t('peak.metadata.title');

        header.appendChild(title);
        panel.appendChild(header);

        const meta = (photoMetaData && photoMetaData[i]) || null;
        const enrichedMeta = enrichMetadata(meta);
        if(metadataMobileQuery.matches){
          metadataExpanded = false;
        }
        if(!meta || typeof meta !== 'object'){
          const empty = document.createElement('div');
          empty.className = 'metadata-primary';
          empty.appendChild(makeRow(t('peak.metadata.labels.metadata'), t('peak.metadata.notAvailable')));
          panel.appendChild(empty);
          metadataExpanded = false;
          resumeCarousel('metadata_panel');
          panel.hidden = false;
          return;
        }

        // Grouping keys by type (EXIF, IPTC, SEO, File Info, etc.)
        const GROUPS = [
          { label: 'Descriptions & Accessibility', keys: ['headline','caption','description','extendedDescription','altText','alt','extendedAlt','title','subject'] },
          { label: 'EXIF', keys: ['captureDate','cameraMaker','cameraModel','camera','lens','fStop','shutterSpeed','iso','exposureBias','focalLength','flashMode','meteringMode','maxAperture','focalLength35mm','rating','dimensions'] },
          { label: 'File Info', keys: ['fileSize','fileCreateDate','fileModifiedDate','author','creator','creditLine','source','title','subject'] },
          { label: 'Tags & Attributes', keys: ['tags','season','timeOfDay','orientation','isPrimary'] },
          { label: 'Rights & Licensing', keys: ['copyrightNotice','copyrightStatus','rightsUsageTerms'] },
          { label: 'IPTC', keys: ['iptc'] },
        ];

        const displayMeta = (enrichedMeta && typeof enrichedMeta === 'object') ? enrichedMeta : meta;

        // Collapsed: show only primary keys
        const primaryWrap = document.createElement('div');
        primaryWrap.className = 'metadata-primary';
        let hasPrimary = false;
        PRIMARY_META_KEYS.forEach(key => {
          if(enrichedMeta && enrichedMeta[key] !== undefined && enrichedMeta[key] !== null && String(enrichedMeta[key]).trim() !== ''){
            primaryWrap.appendChild(makeRow(humanLabelFromKey(key), String(enrichedMeta[key])));
            hasPrimary = true;
          }
        });
        if(!hasPrimary){
          primaryWrap.appendChild(makeRow(t('peak.metadata.labels.metadata'), t('peak.metadata.notAvailable')));
        }
        panel.appendChild(primaryWrap);

        // Expanded: show all fields, grouped by type, skipping duplicates
        const extraWrap = document.createElement('div');
        extraWrap.className = 'metadata-extra';
        let shown = new Set(PRIMARY_META_KEYS);
        GROUPS.forEach(group => {
          if(group.label === 'IPTC'){
            const iptc = enrichedMeta && enrichedMeta.iptc;
            if(iptc && typeof iptc === 'object'){
              shown.add('iptc');

              const groupHeader = document.createElement('div');
              groupHeader.className = 'metadata-label';
              groupHeader.style.marginTop = '10px';
              groupHeader.style.fontWeight = 'bold';
              groupHeader.textContent = group.label;
              extraWrap.appendChild(groupHeader);

              const creatorFields = [
                ['Creator', iptc.creator, 'creator'],
                ['Creator Job Title', iptc.creatorJobTitle, 'creatorJobTitle'],
                ['Creator Email', iptc.creatorEmail, 'creatorEmail'],
                ['Creator Website', iptc.creatorWebsite, 'creatorWebsite'],
                ['Featured Org Name', iptc.featuredOrgName, 'featuredOrgName']
              ].filter(([,v]) => v !== undefined && v !== null && String(v).trim() !== '');

              if(creatorFields.length){
                const subHeader = document.createElement('div');
                subHeader.className = 'metadata-label';
                subHeader.style.marginTop = '6px';
                subHeader.textContent = 'Creator & Credits';
                extraWrap.appendChild(subHeader);
                creatorFields.forEach(([label, value, key]) => {
                  extraWrap.appendChild(makeRow(label, String(value)));
                  if(key) shown.add(key);
                });
              }

              const rightsFields = [
                ['Credit Line', iptc.creditLine, 'creditLine'],
                ['Source', iptc.source, 'source'],
                ['Copyright Notice', iptc.copyrightNotice, 'copyrightNotice'],
                ['Copyright Status', iptc.copyrightStatus, 'copyrightStatus'],
                ['Rights Usage Terms', iptc.rightsUsageTerms, 'rightsUsageTerms'],
                ['Intellectual Genre', iptc.intellectualGenre, 'intellectualGenre'],
                ['IPTC Subject Code', iptc.iptcSubjectCode, 'iptcSubjectCode']
              ].filter(([,v]) => v !== undefined && v !== null && String(v).trim() !== '');

              if(rightsFields.length){
                const subHeader = document.createElement('div');
                subHeader.className = 'metadata-label';
                subHeader.style.marginTop = '6px';
                subHeader.textContent = 'Rights & Licensing';
                extraWrap.appendChild(subHeader);
                rightsFields.forEach(([label, value, key]) => {
                  extraWrap.appendChild(makeRow(label, String(value)));
                  if(key) shown.add(key);
                });
              }

              if(Array.isArray(iptc.keywords) && iptc.keywords.length){
                const subHeader = document.createElement('div');
                subHeader.className = 'metadata-label';
                subHeader.style.marginTop = '6px';
                subHeader.textContent = 'Keywords';
                extraWrap.appendChild(subHeader);
                extraWrap.appendChild(makeRow('Keywords', iptc.keywords.join(', ')));
                shown.add('keywords');
              }

              const locationCreatedRows = entriesFromObject('Location Created', iptc.locationCreated);
              const locationShownRows = entriesFromObject('Location Shown', iptc.locationShown);
              const locationRows = [...locationCreatedRows, ...locationShownRows];
              if(locationRows.length){
                const subHeader = document.createElement('div');
                subHeader.className = 'metadata-label';
                subHeader.style.marginTop = '6px';
                subHeader.textContent = 'Locations';
                extraWrap.appendChild(subHeader);
                locationRows.forEach(([label, value]) => extraWrap.appendChild(makeRow(label, value)));
                shown.add('locationCreated');
                shown.add('locationShown');
              }

              const miscIptc = { ...iptc };
              delete miscIptc.locationCreated;
              delete miscIptc.locationShown;
              delete miscIptc.keywords;
              delete miscIptc.altText;
              delete miscIptc.headline;
              delete miscIptc.description;
              delete miscIptc.extendedDescription;
              delete miscIptc.creator;
              delete miscIptc.creatorJobTitle;
              delete miscIptc.creatorEmail;
              delete miscIptc.creatorWebsite;
              delete miscIptc.featuredOrgName;
              delete miscIptc.creditLine;
              delete miscIptc.source;
              delete miscIptc.copyrightNotice;
              delete miscIptc.copyrightStatus;
              delete miscIptc.rightsUsageTerms;
              delete miscIptc.intellectualGenre;
              delete miscIptc.iptcSubjectCode;
              Object.entries(miscIptc).forEach(([key, val]) => {
                if(val === undefined || val === null) return;
                const valueText = Array.isArray(val) ? val.join(', ') : String(val).trim();
                if(valueText){
                  extraWrap.appendChild(makeRow(humanLabelFromKey(key), valueText));
                  shown.add(key);
                }
              });
            }
            return;
          }

          let groupFields = [];
          group.keys.forEach(key => {
            if(SKIP_META_KEYS.has(key)) return;
            if(displayMeta[key] !== undefined && displayMeta[key] !== null && String(displayMeta[key]).trim() !== '' && !shown.has(key)){
              groupFields.push([key, displayMeta[key]]);
              shown.add(key);
            }
          });
          if(groupFields.length > 0){
            const groupHeader = document.createElement('div');
            groupHeader.className = 'metadata-label';
            groupHeader.style.marginTop = '10px';
            groupHeader.style.fontWeight = 'bold';
            groupHeader.textContent = group.label;
            extraWrap.appendChild(groupHeader);
            groupFields.forEach(([key, val]) => {
              if(Array.isArray(val)){
                extraWrap.appendChild(makeRow(humanLabelFromKey(key), val.join(', ')));
              }else if(typeof val === 'object'){
                extraWrap.appendChild(makeRow(humanLabelFromKey(key), JSON.stringify(val, null, 2)));
              }else{
                extraWrap.appendChild(makeRow(humanLabelFromKey(key), String(val)));
              }
            });
          }
        });
        // Add any remaining fields not in groups
        Object.entries(displayMeta).forEach(([key, val]) => {
          if(SKIP_META_KEYS.has(key) || shown.has(key)) return;
          if(val === undefined || val === null || String(val).trim() === '') return;
          if(Array.isArray(val)){
            extraWrap.appendChild(makeRow(humanLabelFromKey(key), val.join(', ')));
          }else if(typeof val === 'object'){
            extraWrap.appendChild(makeRow(humanLabelFromKey(key), JSON.stringify(val, null, 2)));
          }else{
            extraWrap.appendChild(makeRow(humanLabelFromKey(key), String(val)));
          }
          shown.add(key);
        });

        if(extraWrap.childNodes.length > 0){
          const toggleBtn = document.createElement('button');
          toggleBtn.type = 'button';
          toggleBtn.className = 'meta-toggle';
          header.appendChild(toggleBtn);
          panel.appendChild(extraWrap);
          applyMetadataState(metadataExpanded, extraWrap, toggleBtn);
          toggleBtn.addEventListener('click', () => {
            const open = !extraWrap.classList.contains('open');
            applyMetadataState(open, extraWrap, toggleBtn, { track: true });
          });
        }else{
          metadataExpanded = false;
          resumeCarousel('metadata_panel');
        }
        panel.hidden = false;
      }

      function buildPeakDescription(p){
        const panel = document.getElementById('peakDescriptionPanel');
        if(!panel) return;
        panel.innerHTML = '';

        const description = safeText(p.description || p['Description']).trim();
        if(!description){
          panel.hidden = true;
          return;
        }

        const header = document.createElement('div');
        header.className = 'metadata-header';

        const title = document.createElement('div');
        title.className = 'metadata-title';
        title.textContent = translateWithFallback('peak.description.title', 'Mountain Overview');
        header.appendChild(title);

        const body = document.createElement('div');
        body.className = 'description-body';
        body.textContent = description;

        panel.appendChild(header);
        panel.appendChild(body);
        panel.hidden = false;
      }

      /* GENERAL PEAK INFO PANEL ---------------------------------------------- */
      function buildGeneralInfo(p){
        const panel = document.getElementById('generalInfoPanel');
        panel.innerHTML = '';

        const header = document.createElement('div');
        header.className = 'metadata-header';

        const title = document.createElement('div');
        title.className = 'metadata-title';
        title.textContent = t('peak.generalInfo.title');

        header.appendChild(title);
        panel.appendChild(header);

        const body = document.createElement('div');
        body.className = 'metadata-primary';
        panel.appendChild(body);

        const elev = p['Elevation (ft)'];
        const prom = p['Prominence (ft)'];

        body.appendChild(makeRow(t('peak.generalInfo.elevation'), formatFeetValue(elev)));
        body.appendChild(makeRow(t('peak.generalInfo.prominence'), formatFeetValue(prom)));
        body.appendChild(makeRow(t('peak.generalInfo.range'), p['Range / Subrange'] || '—'));
        body.appendChild(makeRow(t('peak.generalInfo.trailType'), translateTrailType(p['Trail Type']) || '—'));
        body.appendChild(makeRow(t('peak.generalInfo.difficulty'), translateDifficulty(p['Difficulty']) || '—'));
        body.appendChild(makeRow(t('peak.generalInfo.exposure'), translateExposure(p['Exposure Level'] || p['Weather Exposure Rating']) || '—'));

        panel.hidden = false;
        trackEvent('peak_general_info_rendered', { slug: currentSlug });
      }

      function renderRoutes(routes){
        const routesGrid = document.getElementById('routesGrid');
        if(!routesGrid) return;
        routesGrid.innerHTML = '';
        if(!Array.isArray(routes) || routes.length === 0){
          routesGrid.hidden = true;
          trackEvent('peak_routes_empty', { slug: currentSlug });
          return;
        }
        routes.forEach(r => {
          const div = document.createElement('div');
          div.className = 'info-panel';
          const dist  = formatDistanceMiles(r['Distance (mi)']);
          const gain  = formatFeetValue(r['Elevation Gain (ft)']);
          const diff  = translateDifficulty(r['Difficulty']) || '—';
          div.innerHTML = `
            <div class="info-label">${r['Route Name']}</div>
            <div class="info-value">
              <strong>${t('peak.routes.distance')}:</strong> ${dist} • 
              <strong>${t('peak.routes.gain')}:</strong> ${gain} • 
              <strong>${t('peak.routes.difficulty')}:</strong> ${diff}
            </div>`;
          routesGrid.appendChild(div);
        });
        routesGrid.hidden = false;
        trackEvent('peak_routes_rendered', { slug: currentSlug, count: routes.length });
      }

      function extractRelatedTrailNames(routes){
        if(!Array.isArray(routes)) return [];
        const keywords = TRAIL_KEYWORDS.join('|');
        const endPattern = new RegExp(`\\b(?:${keywords})\\b$`, 'i');
        const names = new Set();

        routes.forEach(route => {
          const raw = (route['Route Name'] || route.name || '').trim();
          if(!raw) return;
          const parts = raw
            .replace(/[()]/g, ' ')
            .split(/\s*(?:>|via|to|,|;|\/|&)\s*/i);
          parts.forEach(part => {
            const cleaned = part.replace(/[^\w\s'-]/g, ' ').replace(/\s+/g, ' ').trim();
            if(!cleaned) return;
            const words = cleaned.split(' ').filter(Boolean);
            if(words.length < 2 || words.length > 4) return;
            if(!endPattern.test(cleaned)) return;
            const formatted = words.map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
            names.add(formatted);
          });
        });

        return Array.from(names);
      }

      function buildTrailLink(name){
        const encoded = encodeURIComponent(name);
        const link = document.createElement('a');
        link.href = `https://nh48.info/trails?trail=${encoded}`;
        link.target = '_blank';
        link.rel = 'noopener';
        link.textContent = translateWithFallback('peak.relatedTrails.link', `${name} route`, { name });
        link.setAttribute('aria-label', translateWithFallback('peak.relatedTrails.link', `${name} route`, { name }));
        link.addEventListener('click', () => {
          trackEvent('peak_trail_link_click', { trail: name, slug: currentSlug });
        });
        return link;
      }

      function renderRelatedTrails(routes, trailNames = []){
        const relatedGrid = document.getElementById('relatedTrailsGrid');
        if(!relatedGrid) return;
        relatedGrid.innerHTML = '';

        const relatedNames = extractRelatedTrailNames(routes);
        const additionalNames = Array.isArray(trailNames) ? trailNames : [];
        const combinedNames = Array.from(new Set([...relatedNames, ...additionalNames]
          .map(name => (name || '').toString().trim())
          .filter(Boolean)))
          .sort((a, b) => a.localeCompare(b));

        const panel = document.createElement('div');
        panel.className = 'info-panel';

        const label = document.createElement('div');
        label.className = 'info-label';
        label.textContent = translateWithFallback('peak.relatedTrails.title', 'Related Trails & Routes');
        panel.appendChild(label);

        const branding = document.createElement('a');
        branding.className = 'trail-branding';
        branding.href = 'https://nh48.info/trails';
        branding.target = '_blank';
        branding.rel = 'noopener';
        branding.title = 'Explore White Mountain National Forest trails map and dataset';
        branding.setAttribute('aria-label', 'Explore White Mountain National Forest trails map and dataset');

        const logo = document.createElement('img');
        logo.src = '/WMNF_Trails_API_logo.png';
        logo.alt = 'White Mountain National Forest Trails API logo badge';
        logo.loading = 'lazy';
        logo.decoding = 'async';
        branding.appendChild(logo);

        const brandingCopy = document.createElement('div');
        brandingCopy.className = 'trail-branding-text';
        brandingCopy.innerHTML = `<strong>White Mountain Trails Map</strong><span>Interactive WMNF trail list with GPX-backed route details</span>`;
        branding.appendChild(brandingCopy);

        panel.appendChild(branding);

        const list = document.createElement('ul');
        list.className = 'trail-list';

        if(!combinedNames.length){
          const emptyItem = document.createElement('li');
          emptyItem.textContent = translateWithFallback('peak.relatedTrails.none', 'No related trails listed yet.');
          list.appendChild(emptyItem);
          trackEvent('peak_related_trails_empty', { slug: currentSlug });
        }else{
          combinedNames.forEach(name => {
            const li = document.createElement('li');
            li.appendChild(buildTrailLink(name));
            list.appendChild(li);
          });
          trackEvent('peak_related_trails_rendered', { slug: currentSlug, count: combinedNames.length });
        }

        panel.appendChild(list);
        relatedGrid.appendChild(panel);
        relatedGrid.hidden = false;
      }

      function getPeakMapElements(){
        return {
          panel: document.getElementById('peakMapPanel'),
          map: document.getElementById('peakMap'),
          status: document.getElementById('peakMapStatus'),
          title: document.getElementById('peakMapTitle'),
          subtitle: document.getElementById('peakMapSubtitle'),
          cta: document.getElementById('peakMapCta')
        };
      }

      function updatePeakMapStatus(message, show = true){
        const { status } = getPeakMapElements();
        if(!status) return;
        status.textContent = message;
        status.style.display = show ? 'block' : 'none';
      }

      function getPeakMapBounds(coords){
        const latDelta = MAP_RADIUS_MILES / 69;
        const lonDivisor = Math.max(Math.cos(coords.lat * Math.PI / 180), 0.2);
        const lonDelta = MAP_RADIUS_MILES / (69 * lonDivisor);
        return {
          south: coords.lat - latDelta,
          west: coords.lon - lonDelta,
          north: coords.lat + latDelta,
          east: coords.lon + lonDelta
        };
      }

      function ensureLeafletReady(){
        if(window.L) return Promise.resolve(true);
        return new Promise(resolve => {
          const start = performance.now();
          const check = () => {
            if(window.L){
              resolve(true);
              return;
            }
            if(performance.now() - start > 4000){
              resolve(false);
              return;
            }
            requestAnimationFrame(check);
          };
          check();
        });
      }

      async function fetchTrailData(){
        if(peakMapTrailDataPromise) return peakMapTrailDataPromise;
        peakMapTrailDataPromise = (async () => {
          for(const url of TRAIL_API_URLS){
            try{
              const res = await fetch(url, { mode: 'cors' });
              if(!res.ok) continue;
              const text = await res.text();
              const cleaned = text.replace(/^\uFEFF/, '');
              const data = JSON.parse(cleaned);
              if(Array.isArray(data)){
                trackEvent('peak_map_trails_loaded', { source: url, count: data.length });
                return data;
              }
            }catch(err){
              console.warn('Trail data fetch failed', url, err);
            }
          }
          trackEvent('peak_map_trails_failed');
          return [];
        })();
        return peakMapTrailDataPromise;
      }

      function normalizeTrailName(value){
        return String(value || '')
          .toLowerCase()
          .replace(/[()]/g, ' ')
          .replace(/[^\w\s'-]/g, '')
          .replace(/\s+/g, ' ')
          .trim();
      }

      function buildTrailNameCandidates(routes, trailNames){
        const related = extractRelatedTrailNames(routes);
        const manual = Array.isArray(trailNames) ? trailNames : [];
        const combined = [...related, ...manual]
          .map(name => String(name || '').trim())
          .filter(Boolean);

        const suffixes = ['trail', 'loop', 'cutoff', 'road', 'path', 'connector', 'summit', 'route'];
        const candidates = new Set();
        combined.forEach(name => {
          const normalized = normalizeTrailName(name);
          if(normalized) candidates.add(normalized);
          const withoutSuffix = normalized.replace(new RegExp(`\\b(${suffixes.join('|')})\\b`, 'gi'), '').trim();
          if(withoutSuffix) candidates.add(withoutSuffix);
        });
        return candidates;
      }

      function trailWithinBounds(trail, bounds){
        if(trail && trail.bounds){
          return !(
            trail.bounds.maxlat < bounds.south ||
            trail.bounds.minlat > bounds.north ||
            trail.bounds.maxlon < bounds.west ||
            trail.bounds.minlon > bounds.east
          );
        }
        if(!Array.isArray(trail.geometry)) return false;
        return trail.geometry.some(point => point.lat >= bounds.south && point.lat <= bounds.north &&
          point.lon >= bounds.west && point.lon <= bounds.east);
      }

      function setMapJsonLd(name, canonicalUrl, coords, bounds){
        const mapSchema = {
          '@context': 'https://schema.org',
          '@type': 'Map',
          name: `Topographic trail map for ${name}`,
          description: `Interactive map showing White Mountain National Forest trails near ${name}.`,
          url: `${canonicalUrl}#peak-trail-map`,
          isPartOf: {
            '@type': 'WebPage',
            '@id': canonicalUrl
          },
          about: {
            '@type': 'Mountain',
            name,
            url: canonicalUrl
          },
          spatialCoverage: {
            '@type': 'Place',
            geo: {
              '@type': 'GeoShape',
              box: `${bounds.south} ${bounds.west} ${bounds.north} ${bounds.east}`
            }
          },
          contentLocation: {
            '@type': 'Place',
            geo: {
              '@type': 'GeoCoordinates',
              latitude: coords.lat,
              longitude: coords.lon
            }
          }
        };

        const ld = document.getElementById('mapJsonLd');
        if(ld){
          ld.textContent = JSON.stringify(mapSchema);
        }
      }

      async function renderPeakMap(peak, name, canonicalUrl){
        const { panel, map, title, subtitle, cta } = getPeakMapElements();
        if(!panel || !map) return;

        const coords = parseCoordinates(peak['Coordinates']);
        if(!coords){
          panel.hidden = true;
          return;
        }

        panel.hidden = false;
        map.id = 'peakMap';
        map.setAttribute('aria-label', `Topographic map near ${name}`);
        if(title) title.textContent = `${name} trail map`;
        if(subtitle) subtitle.textContent = 'OpenStreetMap topo tiles with WMNF trail geometry.';

        const trailNames = peak['Trail Names'] || [];
        const trailLinkName = Array.isArray(trailNames) && trailNames.length ? trailNames[0] : null;
        if(cta){
          cta.textContent = 'White Mountain Trails →';
          cta.href = trailLinkName ? `https://nh48.info/trails?trail=${encodeURIComponent(trailLinkName)}` : 'https://nh48.info/trails';
          cta.setAttribute('aria-label', 'Explore White Mountain Trails');
        }

        updatePeakMapStatus('Loading trail map…', true);

        const leafletReady = await ensureLeafletReady();
        if(!leafletReady){
          updatePeakMapStatus('Map tiles are unavailable right now.', true);
          return;
        }

        const bounds = getPeakMapBounds(coords);
        peakMapBounds = bounds;
        const latLngBounds = L.latLngBounds([bounds.south, bounds.west], [bounds.north, bounds.east]);

        if(!peakMap){
          peakMap = L.map(map, { zoomControl: true, scrollWheelZoom: false });
          const topoLayer = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OpenStreetMap contributors &amp; OpenTopoMap (CC-BY-SA)'
          });
          const fallbackLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OpenStreetMap contributors'
          });
          topoLayer.on('tileerror', () => {
            if(!peakMap.hasLayer(fallbackLayer)){
              fallbackLayer.addTo(peakMap);
            }
          });
          topoLayer.addTo(peakMap);
          peakMapTrailsLayer = L.layerGroup().addTo(peakMap);
        }else if(peakMapTrailsLayer){
          peakMapTrailsLayer.clearLayers();
        }else{
          peakMapTrailsLayer = L.layerGroup().addTo(peakMap);
        }

        peakMap.fitBounds(latLngBounds, { padding: [12, 12] });
        peakMap.setMaxBounds(latLngBounds.pad(0.05));
        peakMap.setMinZoom(peakMap.getBoundsZoom(latLngBounds));
        requestAnimationFrame(() => peakMap.invalidateSize());

        if(peakMapMarker){
          peakMapMarker.setLatLng([coords.lat, coords.lon]);
        }else{
          peakMapMarker = L.circleMarker([coords.lat, coords.lon], {
            radius: 6,
            color: '#22c55e',
            fillColor: '#22c55e',
            fillOpacity: 0.9,
            weight: 2
          }).addTo(peakMap);
        }

        if(peakMapLabel){
          peakMapLabel.setLatLng([coords.lat, coords.lon]);
          peakMapLabel.setTooltipContent(escapeHtml(name));
        }else{
          peakMapLabel = L.marker([coords.lat, coords.lon], {
            opacity: 0,
            interactive: true
          }).addTo(peakMap);
          peakMapLabel.bindTooltip(escapeHtml(name), {
            permanent: true,
            direction: 'top',
            className: 'peak-map-tooltip',
            offset: [0, -12]
          });
        }

        const trailData = await fetchTrailData();
        const candidates = buildTrailNameCandidates(peak['Standard Routes'] || [], trailNames);
        const matched = trailData.filter(trail => {
          const normalized = normalizeTrailName(trail.name || trail.trail_name || '');
          if(!normalized) return false;
          if(candidates.has(normalized)) return true;
          for(const candidate of candidates){
            if(candidate && normalized.includes(candidate)) return true;
          }
          return false;
        });

        const trailsToRender = matched.length
          ? matched
          : trailData.filter(trail => trailWithinBounds(trail, bounds));

        trailsToRender.forEach(trail => {
          if(!Array.isArray(trail.geometry) || trail.geometry.length < 2) return;
          const latLngs = trail.geometry.map(point => [point.lat, point.lon]);
          const line = L.polyline(latLngs, {
            color: '#60a5fa',
            weight: 3,
            opacity: 0.9
          });
          line.addTo(peakMapTrailsLayer);
          if(trail.name){
            line.bindTooltip(escapeHtml(trail.name), { sticky: true, direction: 'top' });
          }
        });

        if(!trailsToRender.length){
          updatePeakMapStatus('No WMNF trail geometry found in this area yet.', true);
        }else{
          updatePeakMapStatus('', false);
        }

        setMapJsonLd(name, canonicalUrl, coords, bounds);
        trackEvent('peak_map_rendered', { slug: currentSlug, trails: trailsToRender.length });
      }

      function renderTerrain(p){
        const terrainGrid = document.getElementById('terrainGrid');
        if(!terrainGrid) return;
        terrainGrid.innerHTML = '';
        const terrainItems = [
          { label: t('peak.terrain.terrain'), value: p['Terrain Character'] },
          { label: t('peak.terrain.scramble'), value: p['Scramble Sections'] },
          { label: t('peak.terrain.view'), value: p['View Type'] }
        ].filter(x => x.value);

        if(terrainItems.length === 0){
          terrainGrid.hidden = true;
          return;
        }
        terrainItems.forEach(item => {
          const div = document.createElement('div');
          div.className = 'info-panel';
          div.innerHTML = `
            <div class="info-label">${item.label}</div>
            <div class="info-value">${item.value}</div>`;
          terrainGrid.appendChild(div);
        });
        terrainGrid.hidden = false;
        trackEvent('peak_terrain_rendered', { slug: currentSlug, count: terrainItems.length });
      }

      function renderConditions(p){
        const conditionsGrid = document.getElementById('conditionsGrid');
        if(!conditionsGrid) return;
        conditionsGrid.innerHTML = '';
        const conditionItems = [
          { label: t('peak.conditions.bestSeasons'), value: p['Best Seasons to Hike'] },
          { label: t('peak.conditions.waterAvailability'), value: p['Water Availability'] },
          { label: t('peak.conditions.cellReception'), value: p['Cell Reception Quality'] },
          { label: t('peak.conditions.weatherExposure'), value: translateExposure(p['Weather Exposure Rating']) },
          { label: t('peak.conditions.emergencyBailout'), value: p['Emergency Bailout Options'] },
          { label: t('peak.conditions.dogFriendly'), value: p['Dog Friendly'] },
          { label: t('peak.conditions.nearbyFeatures'), value: p['Nearby Notable Features'] }
        ].filter(x => x.value);

        if(conditionItems.length === 0){
          conditionsGrid.hidden = true;
          return;
        }
        conditionItems.forEach(item => {
          const div = document.createElement('div');
          div.className = 'info-panel';
          div.innerHTML = `
            <div class="info-label">${item.label}</div>
            <div class="info-value">${item.value}</div>`;
          conditionsGrid.appendChild(div);
        });
        conditionsGrid.hidden = false;
        trackEvent('peak_conditions_rendered', { slug: currentSlug, count: conditionItems.length });
      }

      function updateHeadMeta(p, slug, name, primaryMeta){
        const elevation = p['Elevation (ft)'] || t('common.unknown');
        const prominence = p['Prominence (ft)'] || t('common.unknown');
        const range = p['Range / Subrange'] || 'White Mountains';
        const peakDescription = safeText(p.description || p['Description']).trim();

        const langCode = getSeoLang();
        const canonicalUrl = buildCanonicalUrl(slug, langCode);
        const generatedDescription = t('peak.meta.descriptionTemplate', { name, elevation, prominence, range });
        const enrichedMeta = primaryMeta ? enrichMetadata(primaryMeta, primaryMeta.iptc) : null;
        const metaDescription = enrichedMeta
          ? (safeText(enrichedMeta.description)
            || safeText(enrichedMeta.extendedDescription)
            || safeText(enrichedMeta.altText)
            || safeText(enrichedMeta.alt)
            || safeText(enrichedMeta.caption)).trim()
          : '';
        const descriptionText = peakDescription || metaDescription || generatedDescription;
        const titleText = `${name} — White Mountain National Forest`;

        const titleEl = document.getElementById('dynamicTitle');
        if(titleEl){
          titleEl.textContent = titleText;
        }
        const descriptionEl = document.getElementById('dynamicDescription');
        if(descriptionEl){
          descriptionEl.setAttribute('content', descriptionText);
        }
        const canonicalEl = document.getElementById('dynamicCanonical');
        if(canonicalEl){
          canonicalEl.setAttribute('href', canonicalUrl);
        }
        const ogTitleEl = document.getElementById('dynamicOgTitle');
        if(ogTitleEl){
          ogTitleEl.setAttribute('content', titleText);
        }
        const ogDescriptionEl = document.getElementById('dynamicOgDescription');
        if(ogDescriptionEl){
          ogDescriptionEl.setAttribute('content', descriptionText);
        }
        const ogUrlEl = document.getElementById('dynamicOgUrl');
        if(ogUrlEl){
          ogUrlEl.setAttribute('content', canonicalUrl);
        }
        const twitterTitleEl = document.getElementById('dynamicTwitterTitle');
        if(twitterTitleEl){
          twitterTitleEl.setAttribute('content', titleText);
        }
        const twitterDescriptionEl = document.getElementById('dynamicTwitterDescription');
        if(twitterDescriptionEl){
          twitterDescriptionEl.setAttribute('content', descriptionText);
        }
        const twitterUrlEl = document.querySelector('meta[name=\"twitter:url\"]');
        if(twitterUrlEl){
          twitterUrlEl.setAttribute('content', canonicalUrl);
        }
        setMeta('keywords', `NH48 API, ${name} peak details, New Hampshire 4000 footers, White Mountains routes, hiking data, peak metadata, mountain photos`);
        setMeta('author', (enrichedMeta && enrichedMeta.creator) || 'Nathan Sobol');
        setMetaProperty('article:author', 'https://nh48.info');
        setMetaProperty('og:site_name', 'nh48.info');
        setMetaProperty(
          'og:copyright',
          (enrichedMeta && enrichedMeta.copyrightNotice) || '© Nathan Sobol'
        );

        updateHreflangLinks(slug);
        updateBreadcrumbNav(name, canonicalUrl);
        setBreadcrumbJsonLd(name, canonicalUrl);

        return { canonicalUrl, descriptionText };
      }

      /* CAROUSEL ------------------------------------------------------------- */
      function buildCarousel(images, meta, altBase){
        const carouselEl = document.getElementById('carousel');
        const dotsEl = document.getElementById('dots');
        carouselEl.innerHTML = '';
        dotsEl.innerHTML = '';

        carouselImgs = [];
        carouselIdx = 0;
        photoMetaData = meta || [];

        const placeholder = getPlaceholder();
        setMediaLoading(true);
        let firstImageResolved = false;
        if(!images || images.length === 0){
          images = [placeholder];
          photoMetaData = [{}];
        }

        const hasRealImages = images.some(src => src && src !== placeholder);

        images.forEach((src, i) => {
          const slide = document.createElement('div');
          slide.className = 'slide' + (i === 0 ? ' active' : '');

          const figure = document.createElement('figure');
          figure.className = 'slide-figure';

          const img = document.createElement('img');
          const altInfo = buildPhotoAltText(altBase, meta[i]);
          img.alt = altInfo ? altInfo.text : '';
          if(altInfo && altInfo.lang){
            img.setAttribute('lang', altInfo.lang);
          }

          const realSrc = src || placeholder;
          const isPlaceholder = realSrc === placeholder;
          img.loading = 'lazy';
          img.decoding = 'async';
          img.src = placeholder;
          if(!isPlaceholder){
            img.setAttribute('data-src', realSrc);
          }

          const resolveFirstImage = () => {
            if(firstImageResolved) return;
            firstImageResolved = true;
            setMediaLoading(false);
            trackEvent('peak_carousel_first_image_loaded', { index: 0 });
          };
          const handleLoad = () => {
            if(img.getAttribute('data-src')) return;
            img.removeEventListener('load', handleLoad);
            resolveFirstImage();
          };
          img.addEventListener('load', handleLoad);
          img.onerror = () => {
            img.onerror = null;
            img.src = placeholder;
            img.removeAttribute('data-src');
            resolveFirstImage();
          };

          figure.appendChild(img);

          const described = buildPhotoExtendedDescription(meta[i]);
          if(described && described.text){
            const describedId = `photo-desc-${i}`;
            img.setAttribute('aria-describedby', describedId);
            const sr = document.createElement('span');
            sr.id = describedId;
            sr.className = 'sr-only';
            sr.textContent = described.text;
            if(described.lang){
              sr.setAttribute('lang', described.lang);
            }
            figure.appendChild(sr);
          }

          slide.appendChild(figure);
          carouselEl.appendChild(slide);
          carouselImgs.push(img);

          const dot = document.createElement('button');
          dot.type = 'button';
          dot.className = 'dot' + (i === 0 ? ' active' : '');
          dot.style.backgroundImage = `url('${realSrc}')`;
          const dotLabel = altInfo && altInfo.text ? altInfo.text : `View photo ${i + 1}`;
          dot.setAttribute('aria-label', dotLabel);
          dot.title = dotLabel;
          dot.addEventListener('click', () => {
            trackEvent('peak_carousel_dot_click', { index: i });
            goTo(i, true);
          });
          dotsEl.appendChild(dot);
        });

        deferImageSrcSwap(carouselEl);
        if(!hasRealImages){
          setMediaLoading(false);
        }

        document.getElementById('media').hidden = false;
        document.getElementById('carouselTimer').hidden = false;

        // Controls
        document.getElementById('prevBtn').onclick = () => prev(true);
        document.getElementById('nextBtn').onclick = () => next(true);

        // Initialise
        updateMetadata(0);
        setupCarouselLazyLoading();
        startCarousel();
      }

      function updateSlides(){
        const slides = Array.from(document.querySelectorAll('.slide'));
        const dots = Array.from(document.querySelectorAll('.dot'));
        slides.forEach((s,i) => s.classList.toggle('active', i === carouselIdx));
        dots.forEach((d,i) => d.classList.toggle('active', i === carouselIdx));
        updateMetadata(carouselIdx);
      }

      function ensureImgLoaded(i){
        const img = carouselImgs[i];
        if(!img) return;
        const real = img.getAttribute('data-src');
        if(real){
          img.src = real;
          img.removeAttribute('data-src');
        }
      }

      function next(manual=false){
        carouselIdx = (carouselIdx + 1) % carouselImgs.length;
        ensureImgLoaded(carouselIdx);
        updateSlides();
        if(manual){
          trackEvent('peak_carousel_next', { index: carouselIdx });
          restartCarousel();
        }
      }

      function prev(manual=false){
        carouselIdx = (carouselIdx - 1 + carouselImgs.length) % carouselImgs.length;
        ensureImgLoaded(carouselIdx);
        updateSlides();
        if(manual){
          trackEvent('peak_carousel_prev', { index: carouselIdx });
          restartCarousel();
        }
      }

      function goTo(i, manual=false){
        carouselIdx = i % carouselImgs.length;
        ensureImgLoaded(carouselIdx);
        updateSlides();
        if(manual){
          trackEvent('peak_carousel_go_to', { index: carouselIdx });
          restartCarousel();
        }
      }

      function startCarousel(){
        stopCarousel();
        if(isCarouselPaused){
          updatePauseButton(true);
          return;
        }
        currentDelay = BASE_DELAY + Math.floor(Math.random()*2000);
        // start the visual timer immediately
        startTimer(currentDelay);
        // and reset both slide + timer on each automatic flip
        carouselTimer = setInterval(() => {
          next(false);
          startTimer(currentDelay);
        }, currentDelay);
        updatePauseButton(false);
      }

      function stopCarousel(){
        if(carouselTimer){
          clearInterval(carouselTimer);
          carouselTimer = null;
        }
        if(timerInterval){
          clearInterval(timerInterval);
          timerInterval = null;
        }
      }

      function updatePauseButton(paused=isCarouselPaused){
        const btn = document.getElementById('carouselPauseBtn');
        if(!btn) return;
        btn.textContent = paused ? '▶' : '❚❚';
        btn.setAttribute('aria-pressed', paused);
        btn.setAttribute('aria-label', paused ? 'Resume carousel' : 'Pause carousel');
        btn.title = paused ? 'Resume carousel' : 'Pause carousel';
      }

      function pauseCarousel(reason='manual'){
        if(isCarouselPaused) return;
        isCarouselPaused = true;
        stopCarousel();
        updatePauseButton(true);
        trackEvent('peak_carousel_paused', { reason });
      }

      function resumeCarousel(reason='manual'){
        if(!isCarouselPaused) return;
        isCarouselPaused = false;
        startCarousel();
        updatePauseButton(false);
        trackEvent('peak_carousel_resumed', { reason });
      }

      function restartCarousel(){
        if(isCarouselPaused) return;
        startCarousel();
      }

      function toggleCarouselPause(){
        if(isCarouselPaused){
          resumeCarousel('pause_button');
        }else{
          pauseCarousel('pause_button');
        }
      }

      const pauseBtn = document.getElementById('carouselPauseBtn');
      if(pauseBtn){
        pauseBtn.addEventListener('click', toggleCarouselPause);
        updatePauseButton(false);
      }

      function setupCarouselLazyLoading(){
        if (!('IntersectionObserver' in window)){
          carouselImgs.forEach(img => {
            const src = img.getAttribute('data-src');
            if(src){ img.src = src; img.removeAttribute('data-src'); }
          });
          return;
        }
        const observer = new IntersectionObserver((entries) => {
          entries.forEach(entry => {
            if(entry.isIntersecting){
              const img = entry.target;
              const src = img.getAttribute('data-src');
              if(src){ img.src = src; img.removeAttribute('data-src'); }
              observer.unobserve(img);
            }
          });
        }, { rootMargin:'100px' });
        carouselImgs.forEach(img => {
          if(img.getAttribute('data-src')) observer.observe(img);
        });
      }

      /* COUNTDOWN TIMER ------------------------------------------------------ */
      function startTimer(duration){
        const ring = document.getElementById('timerRing');
        const textEl = document.getElementById('timerText');
        if(!ring || !textEl) return;

        const radius = 18;
        const circumference = 2 * Math.PI * radius;
        ring.style.strokeDasharray = circumference;
        ring.style.strokeDashoffset = 0;

        const start = Date.now();
        const end = start + duration;

        if(timerInterval) clearInterval(timerInterval);

        timerInterval = setInterval(() => {
          const now = Date.now();
          const remaining = Math.max(end - now, 0);
          const percent = remaining / duration;
          const offset = circumference * (1 - percent);
          ring.style.strokeDashoffset = offset;
          const secs = Math.ceil(remaining / 1000);
          textEl.textContent = secs;
          if(remaining <= 0){
            clearInterval(timerInterval);
            timerInterval = null;
          }
        }, 100);

        textEl.textContent = Math.ceil(duration / 1000);
      }

      /* INIT ----------------------------------------------------------------- */
      async function init(){
        const slug = getResolvedSlug();
        if(!slug){
          trackEvent('peak_missing_slug');
          updatePeakTitle(t('peak.notFound') || 'Peak not found');
          return;
        }

        try{
          const [ , data ] = await Promise.all([
            waitForI18NReady(),
            fetchPeaks()
          ]);
          const p = data && data[slug];

          if(!p){
            trackEvent('peak_not_found', { slug });
            updatePeakTitle(t('peak.notFound') || 'Peak not found');
            return;
          }

          const name = p.peakName || p['Peak Name'] || p.name || p['Name'] || p.peak || p['Peak'] || p['PeakName'] || slug;
          updatePeakTitle(name);
          currentPeak = p;
          currentSlug = slug;

          // Photos + per-photo metadata
          let imgs = [];
          let meta = [];
          let primaryIndex = 0;
          let primaryMarked = false;
          if(Array.isArray(p.photos) && p.photos.length > 0){
            p.photos.forEach((item, idx) => {
              if(typeof item === 'string'){
                const normalizedUrl = normalizePhotoUrl(item);
                imgs.push(normalizedUrl);
                meta.push({ url: normalizedUrl, originalUrl: item });
                if(item && typeof item === 'object' && item.isPrimary && !primaryMarked){
                  primaryIndex = idx;
                  primaryMarked = true;
                }
              }else if(item && item.url){
                const normalizedUrl = normalizePhotoUrl(item.url);
                imgs.push(normalizedUrl);
                meta.push({ ...item, url: normalizedUrl, originalUrl: item.url });
                if(item.isPrimary && !primaryMarked){
                  primaryIndex = idx;
                  primaryMarked = true;
                }
              }
            });
          }
          if(imgs.length === 0){
            imgs = [getPlaceholder()];
            meta = [{}];
            primaryIndex = 0;
            primaryMarked = false;
          }
          currentImages = imgs.slice();
          currentMeta = meta.slice();

          const primaryMeta = meta[primaryIndex] || meta[0] || {};
          const primaryImageCandidate = imgs[primaryIndex] || imgs[0];
          const primaryImage =
            primaryImageCandidate && !primaryImageCandidate.startsWith('data:')
              ? primaryImageCandidate
              : DEFAULT_OG_IMAGE;
          const parsedDimensions = parseDimensions(primaryMeta.dimensions);
          currentPrimaryMeta = primaryMeta;
          currentPrimaryPhoto = {
            ...primaryMeta,
            url: primaryImage,
            width: parsedDimensions.width,
            height: parsedDimensions.height
          };

          const { canonicalUrl, descriptionText } = updateHeadMeta(p, slug, name, primaryMeta);

          const ogImageEl = document.getElementById('dynamicOgImage');
          if(ogImageEl){
            ogImageEl.setAttribute('content', primaryImage);
          }
          const twitterImageEl = document.getElementById('dynamicTwitterImage');
          if(twitterImageEl){
            twitterImageEl.setAttribute('content', primaryImage);
          }

          buildPeakDescription(p);
          // Build general info panel
          buildGeneralInfo(p);

          const routes = p['Standard Routes'] || [];
          const trailNames = p['Trail Names'] || [];
          renderRoutes(routes);
          renderRelatedTrails(routes, trailNames);
          const trailNamesGrid = document.getElementById('trailNamesGrid');
          if(trailNamesGrid){
            trailNamesGrid.hidden = true;
            trailNamesGrid.innerHTML = '';
          }
          renderTerrain(p);
          renderConditions(p);
          renderPeakMap(p, name, canonicalUrl);

          buildMountainSchema(p, name, canonicalUrl, currentPrimaryPhoto, descriptionText);
          buildCarousel(imgs, meta, name);
          trackEvent('peak_loaded', { slug, name, photoCount: imgs.length });

        }catch(err){
          console.error('Error loading peak data:', err);
          trackEvent('peak_load_failed', { slug, message: err.message });
          updatePeakTitle(t('peak.errorLoading'));
        }
      }

      if(document.readyState === 'loading'){
        document.addEventListener('DOMContentLoaded', init, { once: true });
      }else{
        init();
      }

      if (window.NH48_I18N && window.NH48_I18N.onLangChange) {
        window.NH48_I18N.onLangChange((lang) => {
          syncUnitsWithLanguage(lang);
          if (!currentPeak) return;
          const name = currentPeak.peakName || currentPeak['Peak Name'] || currentSlug;
          updatePeakTitle(name);
          const { canonicalUrl, descriptionText } = updateHeadMeta(currentPeak, currentSlug, name, currentPrimaryMeta);
          buildPeakDescription(currentPeak);
          buildGeneralInfo(currentPeak);
          const routes = currentPeak['Standard Routes'] || [];
          const trailNames = currentPeak['Trail Names'] || [];
          renderRoutes(routes);
          renderRelatedTrails(routes, trailNames);
          const trailNamesGrid = document.getElementById('trailNamesGrid');
          if(trailNamesGrid){
            trailNamesGrid.hidden = true;
            trailNamesGrid.innerHTML = '';
          }
          renderTerrain(currentPeak);
          renderConditions(currentPeak);
          renderPeakMap(currentPeak, name, canonicalUrl);
          if (currentPrimaryPhoto) {
            buildMountainSchema(currentPeak, name, canonicalUrl, currentPrimaryPhoto, descriptionText);
          }
          if (currentImages.length) {
            buildCarousel(currentImages, currentMeta, name);
          }
          trackEvent('peak_language_change', { language: lang, slug: currentSlug });
        });
      }

      const unitsSelect = document.getElementById('unitsSelect');
      if(unitsSelect){
        unitsSelect.addEventListener('change', (e) => {
          setUnits(e.target.value);
          if (!currentPeak) return;
          buildGeneralInfo(currentPeak);
          const routes = currentPeak['Standard Routes'] || [];
          renderRoutes(routes);
          trackEvent('peak_units_change', { units: e.target.value, slug: currentSlug });
        });
      }

      syncUnitsWithLanguage(window.NH48_I18N ? window.NH48_I18N.getLang() : 'en');
    </script>
    <div id="footer-placeholder"></div>
<script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-app.js";
      import { getAnalytics, logEvent } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-analytics.js";

      const firebaseConfig = {
        apiKey: "AIzaSyCUShYXwxGVEDNzMeIwSFPmDaYeXSqRK4A",
        authDomain: "nh48-info.firebaseapp.com",
        projectId: "nh48-info",
        storageBucket: "nh48-info.firebasestorage.app",
        messagingSenderId: "732743288228",
        appId: "1:732743288228:web:d82d62cae0c3999ee5ad31",
        measurementId: "G-Q9F2W8YB7D"
      };

      const app = initializeApp(firebaseConfig);
      const analytics = getAnalytics(app);

      // Expose globally for app scripts
      window.NH48_INFO_ANALYTICS = {
        analytics,
        logEvent
      };

      // Base page-load event
      logEvent(analytics, "page_loaded", {
        site: "nh48-info",
        page: location.pathname
      });
    </script>
  </body>
</html>
