<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noindex,follow">
  <title>White Mountain Trails Map &amp; Open Data – White Mountain National Forest</title>
  <meta name="description" content="Explore White Mountain National Forest trails with an interactive map and open datasets for WMNF routes and 2,000-foot peaks. Download normalized JSON for your own apps.">
  <meta name="keywords" content="WMNF trails,White Mountain National Forest,New Hampshire hiking trails,open trail data,WMNF dataset,2000 foot peaks">
  <link rel="canonical" href="https://nh48.info/trails">
  <meta property="og:type" content="website">
  <meta property="og:title" content="White Mountain Trails Map &amp; Open Data – White Mountain National Forest">
  <meta property="og:description" content="Interactive WMNF trail explorer plus downloadable JSON datasets for White Mountain routes and 2,000-foot peaks.">
  <meta property="og:url" content="https://nh48.info/trails">
  <meta property="og:image" content="https://nh48.info/WMNF_Trails_API_logo.png">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="White Mountain Trails Map &amp; Open Data – White Mountain National Forest">
  <meta name="twitter:description" content="Open WMNF trail and 2,000-foot peak datasets with an interactive planning map.">
  <meta name="twitter:image" content="https://nh48.info/WMNF_Trails_API_logo.png">
    <link rel="alternate" hreflang="en" href="https://nh48.info/">
    <link rel="alternate" hreflang="es" href="https://nh48.info/i18n/es.html">
    <link rel="alternate" hreflang="fr" href="https://nh48.info/i18n/fr.html">
    <link rel="alternate" hreflang="de" href="https://nh48.info/i18n/de.html">
    <link rel="alternate" hreflang="zh" href="https://nh48.info/i18n/zh.html">
    <link rel="alternate" hreflang="zh-Hans" href="https://nh48.info/i18n/zh-Hans.html">
    <link rel="alternate" hreflang="ja" href="https://nh48.info/i18n/ja.html">
    <link rel="alternate" hreflang="ar" href="https://nh48.info/i18n/ar.html">
    <link rel="alternate" hreflang="hi-IN" href="https://nh48.info/i18n/hi.html">
    <link rel="alternate" hreflang="pt" href="https://nh48.info/i18n/pt.html">
    <link rel="alternate" hreflang="ru" href="https://nh48.info/i18n/ru.html">
    <link rel="alternate" hreflang="id" href="https://nh48.info/i18n/id.html">
    <link rel="alternate" hreflang="it" href="https://nh48.info/i18n/it.html">
    <link rel="alternate" hreflang="ko" href="https://nh48.info/i18n/ko.html">
    <link rel="alternate" hreflang="tr" href="https://nh48.info/i18n/tr.html">
    <link rel="alternate" hreflang="vi" href="https://nh48.info/i18n/vi.html">
    <link rel="alternate" hreflang="pl" href="https://nh48.info/i18n/pl.html">
    <link rel="alternate" hreflang="x-default" href="https://nh48.info/">
  <script src="/js/unified-footer.js" defer></script>
  <script type="module" src="../js/i18n.js"></script>

  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Dataset",
      "name": "White Mountain National Forest Trails & 2,000-Foot Peaks (White Mountain Trails API)",
      "description": "Independent WMNF dataset containing normalized trail geometry and 2,000-foot peak records used by the White Mountain Trails App.",
      "identifier": "wmnf-trails",
      "url": "https://nh48.info/trails",
      "sameAs": [
        "https://github.com/natesobol/WMNF-Trails-API",
        "https://nh48.info/data/wmnf-trails/White_Mountains_Trails.txt"
      ],
      "keywords": [
        "White Mountain National Forest",
        "WMNF",
        "trails",
        "New Hampshire",
        "Maine",
        "hiking",
        "open data",
        "geojson",
        "2000 foot peaks",
        "White Mountain trails dataset"
      ],
      "isAccessibleForFree": true,
      "license": "https://creativecommons.org/licenses/by/4.0/",
      "creator": {
        "@type": "Organization",
        "name": "NH48 / White Mountain Trails",
        "url": "https://nh48.info"
      },
      "spatialCoverage": {
        "@type": "AdministrativeArea",
        "name": "White Mountain National Forest in New Hampshire and Maine"
      },
      "temporalCoverage": "2020-01-01/2025-12-31",
      "distribution": [
        {
          "@type": "DataDownload",
          "encodingFormat": "application/json",
          "name": "WMNF Trail Network (Main)",
          "contentUrl": "https://nh48.info/data/wmnf-trails/wmnf-main.json"
        },
        {
          "@type": "DataDownload",
          "encodingFormat": "application/json",
          "name": "WMNF Trail Network (Pliney)",
          "contentUrl": "https://nh48.info/data/wmnf-trails/wmnf-pliney.json"
        },
        {
          "@type": "DataDownload",
          "encodingFormat": "application/json",
          "name": "WMNF Trail Network (Maine Segment)",
          "contentUrl": "https://nh48.info/data/wmnf-trails/wmnf-maine.json"
        },
        {
          "@type": "DataDownload",
          "encodingFormat": "application/json",
          "name": "WMNF 2,000-Foot Peaks",
          "contentUrl": "https://nh48.info/data/wmnf-trails/NH2000ftpeaks.json"
        },
        {
          "@type": "DataDownload",
          "encodingFormat": "text/plain",
          "name": "White Mountain Trails (tabular export)",
          "contentUrl": "https://nh48.info/data/wmnf-trails/White_Mountains_Trails.txt"
        }
      ],
      "includedInDataCatalog": {
        "@type": "DataCatalog",
        "name": "White Mountain Trails App",
        "url": "https://nh48.info/trails",
        "description": "Trail network, peak overlays, and derived files powering the White Mountain Trails App and embeddable map widgets.",
        "license": "https://creativecommons.org/licenses/by/4.0/"
      }
    }
  </script>
  <script id="trailsJsonLd" type="application/ld+json"></script>
  <script>
    (() => {
      const TRAILS_JSONLD_SCRIPT_ID = 'trailsJsonLd';
      const TRAIL_LIST_PAGE = 'https://nh48.info/trails?trail=';
      const TRAIL_ITEMLIST_LIMIT = 300;
      const TRAIL_DATA_URLS = [
        '../data/trails_with_osm.json',
        '/data/trails_with_osm.json',
        'https://cdn.jsdelivr.net/gh/natesobol/WMNF-Trails-API@main/trails_with_osm.json',
        'https://raw.githubusercontent.com/natesobol/WMNF-Trails-API/main/trails_with_osm.json'
      ];

      function normalizeTrailNameForJsonLd(name){
        return String(name || '').trim();
      }

      function buildTrailItemList(names){
        const itemListElement = names.slice(0, TRAIL_ITEMLIST_LIMIT).map((name, index) => ({
          '@type': 'ListItem',
          position: index + 1,
          url: `${TRAIL_LIST_PAGE}${encodeURIComponent(name)}`,
          name
        }));
        return {
          '@context': 'https://schema.org',
          '@type': 'ItemList',
          name: 'White Mountain National Forest Trails',
          itemListElement
        };
      }

      async function loadTrailItemList(){
        for(const url of TRAIL_DATA_URLS){
          try{
            const response = await fetch(url);
            if(!response.ok) continue;
            const data = await response.json();
            const names = data
              .map(record => normalizeTrailNameForJsonLd(record.trail_name || record.name))
              .filter(Boolean)
              .sort((a, b) => a.localeCompare(b));
            if(names.length === 0) continue;
            const scriptEl = document.getElementById(TRAILS_JSONLD_SCRIPT_ID);
            if(scriptEl){
              scriptEl.textContent = JSON.stringify(buildTrailItemList(names));
            }
            return;
          }catch(err){
            console.warn('Unable to load trail list data for JSON-LD:', err);
          }
        }
      }

      window.addEventListener('DOMContentLoaded', loadTrailItemList);
    })();
  </script>

<!--
  WMNF Trail Explorer

  This HTML document builds a simple, responsive web application that allows users to browse
  hiking trails in New Hampshire's White Mountain National Forest (WMNF).  It displays a
  searchable, sortable list of trails alongside an interactive Leaflet map.  When a user
  selects a trail from the list, the map pans/zooms to the trail and highlights it.  The
  layout adapts gracefully between desktop and mobile screen sizes using CSS flexbox and
  media queries.

  For Wix embedding: This version uses GitHub's raw content URL to load the GeoJSON file.
  No DOCTYPE or full HTML structure is needed for Wix embeds. The Leaflet libraries are
  loaded via CDN. This works across all deployment contexts (GitHub Pages, Wix, etc).
-->
<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  crossorigin=""
/>
  <style>
    * {
      box-sizing: border-box;
    }

    /* Dark theme color palette */
    :root {
      --bg-primary: #1a1d23;
      --bg-secondary: #25282f;
      --bg-tertiary: #2d3039;
      --border-color: #3d4048;
      --text-primary: #ffffff;
      --text-secondary: #ffffff;
      --accent-blue: #4a9eff;
      --accent-blue-dark: #2d7dd8;
      --accent-red: #ff6b6b;
      --success-green: #51cf66;
      --hover-bg: #33373f;
      --page-padding: clamp(16px, 4vw, 48px);
      --content-width: 1200px;

      /* Dark green used for primary action buttons (Export/Import) */
      --button-green: #2f855a;
      --button-green-dark: #276749;
    }

    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background-color: var(--bg-primary);
      color: var(--text-primary);
    }

    .page-header {
      max-width: 1100px;
      margin: 1.25rem auto 0.35rem;
      padding: 0 var(--page-padding);
      width: 100%;
      display: flex;
      align-items: center;
      gap: 14px;
      flex-wrap: wrap;
    }

    .page-header h1 {
      margin: 0;
      font-size: clamp(1.65rem, 2vw, 2rem);
      line-height: 1.1;
    }

    .page-header p {
      margin: 0.2rem 0 0;
      color: var(--text-secondary);
      line-height: 1.4;
    }

    .header-text {
      display: flex;
      flex-direction: column;
      gap: 4px;
      min-width: 0;
    }

    .page-logo {
      display: inline-flex;
    }

    .page-breadcrumbs {
      margin: 0 auto 10px;
      color: var(--text-secondary);
      max-width: 1100px;
      padding: 0 var(--page-padding);
    }

    .page-breadcrumbs ol {
      display: flex;
      gap: 8px;
      list-style: none;
      padding: 0;
      margin: 0;
      font-size: 0.95rem;
    }

    .page-breadcrumbs li {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .page-breadcrumbs li + li::before {
      content: "/";
      color: var(--text-secondary);
      opacity: 0.7;
    }

    .page-breadcrumbs a {
      color: var(--accent-blue);
      text-decoration: none;
      font-weight: 700;
    }

    .page-breadcrumbs a:hover,
    .page-breadcrumbs a:focus-visible {
      text-decoration: underline;
    }

    .logo-wrap {
      width: 72px;
      height: 72px;
      border-radius: 14px;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: none;
      background: transparent;
      padding: 0;
    }

    .logo-wrap img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      display: block;
      margin: 0;
    }

    .page-logo {
      display: inline-flex;
      margin-bottom: 0.5rem;
    }

    .page-header .page-subtitle {
      margin: 0.35rem 0 0;
      font-weight: 600;
      font-size: 1.1rem;
      color: #d6f5df;
    }
    .nh48-lang {
      display: flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
      margin-top: 12px;
    }
    .nh48-lang-menu {
      position: relative;
    }
    .nh48-lang-toggle {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      min-height: 36px;
      padding: 4px 10px;
      border-radius: 10px;
      border: 1px solid var(--border-color);
      background: var(--bg-secondary);
      color: var(--text-primary);
      cursor: pointer;
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.6px;
    }
    .nh48-lang-toggle .flag {
      font-size: 18px;
    }
    .nh48-lang-toggle-text {
      white-space: nowrap;
    }
    .nh48-lang-caret {
      font-size: 0.65rem;
      margin-left: 2px;
      opacity: 0.8;
    }
    .nh48-lang-options {
      position: absolute;
      right: 0;
      top: calc(100% + 8px);
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      padding: 8px;
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 6px;
      min-width: 220px;
      box-shadow: 0 12px 28px rgba(15, 23, 42, 0.35);
      opacity: 0;
      pointer-events: none;
      transform: translateY(-6px);
      transition: opacity 0.15s ease, transform 0.15s ease;
      z-index: 4;
    }
    .nh48-lang-menu.open .nh48-lang-options {
      opacity: 1;
      pointer-events: auto;
      transform: translateY(0);
    }
    .nh48-lang-label {
      font-size: 0.75rem;
      color: #d6f5df;
      text-transform: uppercase;
      letter-spacing: 0.8px;
      margin-right: 4px;
    }
    .nh48-flag {
      width: 34px;
      height: 34px;
      border-radius: 8px;
      border: 1px solid var(--border-color);
      background: var(--bg-secondary);
      color: var(--text-primary);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: border-color 0.2s ease, box-shadow 0.2s ease, transform 0.2s ease;
    }
    .nh48-flag .flag {
      font-size: 18px;
      line-height: 1;
    }
    .nh48-flag.active {
      border-color: var(--success-green);
      box-shadow: 0 0 0 2px rgba(81, 207, 102, 0.25);
    }
    .nh48-flag:focus-visible {
      outline: 2px solid var(--success-green);
      outline-offset: 2px;
    }

    /* Root container for the app */
  #app {
    display: flex;
    gap: 1rem;
    width: 100%;
    max-width: none;
    margin: 0;
    padding: 1rem;
    min-height: 100vh;
    box-sizing: border-box;
  }

    /* Top section holds the sidebar and the map side by side */
    #topSection {
      display: flex;
      gap: 1rem;
      padding: 1rem;
      min-height: 320px;
      align-items: stretch;
    }

    /* Draggable divider between the map panel and the trail list */
    #panelResizer {
      height: 10px;
      background: linear-gradient(
        90deg,
        transparent 0%,
        rgba(255, 255, 255, 0.25) 25%,
        rgba(255, 255, 255, 0.35) 50%,
        rgba(255, 255, 255, 0.25) 75%,
        transparent 100%
      );
      cursor: row-resize;
      border-top: 1px solid var(--border-color);
      border-bottom: 1px solid var(--border-color);
      user-select: none;
      touch-action: none;
    }

    /* Adjust the sidebar dimensions; allow vertical scrolling for long content */
    /* Map occupies the left side of the top section */
    /* Container wrapping the map. Provides padding and its own border to avoid
       the map touching other edges. */
  #mapContainer {
    flex: 2;
    display: flex;
    flex-direction: column;
    padding: 1rem;
    background-color: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    min-height: 100vh;
  }

    /* Map itself fills its container */
  #map {
    flex: 1;
    width: 100%;
    height: 100%;
    background-color: #2d2d2d;
    border-radius: 6px;
    min-height: 100vh;
  }

    /* Bottom container holds the trail list and the info/settings panel */
    #bottomSection {
      display: flex;
      gap: 1rem;
      padding: 1rem;
      width: 100%;
      box-sizing: border-box;
      min-height: 320px;
    }

    /* List section below the map; spans most of the width */
    #listSection {
      width: 100%;
      /* Allow the list section to grow and fill the remaining height */
      flex: 2;
      height: 100%;
      min-height: 280px;
      /* Light grey panel similar to WMNF trails app */
      background-color: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.3);
      display: flex;
      flex-direction: column;
      padding: 1rem 1.5rem;
      overflow-y: auto;
    }

    .about-panel {
      flex: 1;
      min-width: 300px;
      max-width: 420px;
      margin: 0;
      overflow-y: auto;
    }

    /* Sidebar (settings) styles defined above.  Old definitions removed to avoid conflicts. */

    /* Header section with title */
    .sidebar-header {
      padding: 1.5rem;
      border-bottom: 1px solid var(--border-color);
      background-color: var(--bg-primary);
    }

    .sidebar-header h1 {
      margin: 0;
      font-size: 1.5rem;
      font-weight: 600;
      color: var(--text-primary);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .sidebar-header p {
      margin: 0.5rem 0 0 0;
      font-size: 0.85rem;
      color: var(--text-secondary);
    }

    /* Controls container */
    .controls {
      padding: 1rem 1.5rem;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      background-color: var(--bg-secondary);
    }

    .controls input[type="text"],
    .controls select {
      width: 100%;
      padding: 0.75rem;
      background-color: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      font-size: 0.95rem;
      color: var(--text-primary);
      transition: all 0.2s ease;
    }

    .controls input[type="text"]::placeholder {
      color: var(--text-secondary);
    }

    /* Wrapper for the letter navigation bar and its label */
    .letter-nav-wrapper {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      padding: 0.5rem 1.5rem 0.5rem;
      border-bottom: 1px solid var(--border-color);
    }
    .jump-label {
      font-size: 0.75rem;
      color: var(--text-primary);
      user-select: none;
    }
    .letter-nav {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 0.15rem;
    }
    .letter-nav span {
      cursor: pointer;
      color: var(--text-primary);
      font-size: 0.75rem;
      margin: 0.15rem 0.2rem;
      padding: 0.25rem 0.4rem;
      border-radius: 4px;
      flex: none;
      user-select: none;
    }
    .letter-nav span:hover {
      background-color: var(--hover-bg);
      color: var(--accent-blue);
    }

    /* List header styling */
    .list-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.6rem 1rem;
      background-color: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-top-left-radius: 8px;
      border-top-right-radius: 8px;
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--text-primary);
    }
    .header-name {
      flex: 1;
    }
    .header-completed {
      flex: 0;
      margin-left: 0.5rem;
    }

    .controls input[type="text"]:focus,
    .controls select:focus {
      outline: none;
      border-color: var(--accent-blue);
      background-color: var(--bg-tertiary);
      box-shadow: 0 0 0 3px rgba(74, 158, 255, 0.1);
    }

    .controls select {
      cursor: pointer;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='8' viewBox='0 0 12 8'%3E%3Cpath fill='%23a0a3a8' d='M1 1l5 5 5-5'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 0.75rem center;
      padding-right: 2.5rem;
    }

    /* Trail list container */
    .trail-list-container {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
    }

    .trail-info-panel {
      flex: 1;
      padding: 0.75rem 1rem;
      background-color: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.35);
      min-width: 280px;
      margin: 0;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .trail-info-panel h2 {
      margin: 0 0 0.35rem;
      font-size: 1.1rem;
      color: var(--text-primary);
      text-align: center;
    }

    .trail-info-panel p {
      margin: 0.15rem 0 0.6rem;
      color: var(--text-secondary);
      text-align: center;
      font-size: 0.9rem;
    }

    .trail-info-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 0.65rem;
    }

    @media (max-width: 720px) {
      .trail-info-grid {
        grid-template-columns: 1fr;
      }
    }

    .trail-info-item {
      padding: 0.75rem;
      background-color: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }

    .trail-info-item span {
      font-size: 0.75rem;
      color: var(--text-secondary);
      letter-spacing: 0.02em;
      text-transform: uppercase;
    }

    .trail-info-item strong {
      color: var(--text-primary);
      font-size: 0.95rem;
      word-break: break-word;
    }

    .trail-info-empty {
      text-align: center;
      color: var(--text-secondary);
      line-height: 1.5;
    }

    .trail-info-about {
      padding: 0.75rem;
      background-color: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      text-align: left;
    }

    .trail-info-about h3 {
      margin: 0 0 0.25rem;
      font-size: 0.95rem;
      color: var(--text-primary);
      text-align: left;
    }

    .trail-info-about p {
      margin: 0;
      text-align: left;
      color: var(--text-secondary);
      line-height: 1.4;
      font-size: 0.9rem;
    }

    .peakbagger-panel .cta {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      align-items: center;
    }

    .peakbagger-panel a {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      padding: 0.6rem 1rem;
      background: linear-gradient(135deg, var(--button-green) 0%, var(--button-green-dark) 100%);
      color: white;
      border-radius: 6px;
      text-decoration: none;
      font-weight: 600;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.35);
    }

    .peakbagger-panel a:hover {
      filter: brightness(1.05);
    }

    @media (max-width: 900px) {
      .info-panels {
        flex-direction: column;
      }
    }

    .trail-list-container::-webkit-scrollbar {
      width: 8px;
    }

    .trail-list-container::-webkit-scrollbar-track {
      background: transparent;
    }

    .trail-list-container::-webkit-scrollbar-thumb {
      background: var(--border-color);
      border-radius: 4px;
    }

    .trail-list-container::-webkit-scrollbar-thumb:hover {
      background: var(--text-secondary);
    }

    /* Trail list styles */
    #trailList {
      list-style: none;
      padding: 0.5rem;
      margin: 0;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    #trailList li {
      padding: 1rem;
      background-color: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 0.95rem;
      color: var(--text-primary);
      user-select: none;
    }

    #trailList li:hover {
      background-color: var(--hover-bg);
      border-color: var(--accent-blue);
      transform: translateX(4px);
    }

    #trailList li.active {
      background: linear-gradient(135deg, var(--accent-blue) 0%, var(--accent-blue-dark) 100%);
      border-color: var(--accent-blue);
      font-weight: 600;
      box-shadow: 0 4px 12px rgba(74, 158, 255, 0.25);
      color: white;
    }

    /* Empty state message */
    .empty-state {
      padding: 2rem 1.5rem;
      text-align: center;
      color: var(--text-secondary);
      font-size: 0.95rem;
    }

    /* Loading state message */
    .loading-state {
      padding: 2rem 1.5rem;
      text-align: center;
      color: var(--text-secondary);
      font-size: 0.95rem;
    }

    .loading-state p {
      margin: 0;
      animation: pulse 1.5s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 0.6; }
      50% { opacity: 1; }
    }

    /* Map container */
    #map {
      flex: 1;
      background-color: #2d2d2d;
    }

    /* Leaflet customization */
    .leaflet-control-container {
      font-family: inherit;
    }

    .leaflet-control {
      background-color: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .leaflet-control-zoom-in,
    .leaflet-control-zoom-out {
      color: var(--text-primary);
      background-color: var(--bg-tertiary);
      border-bottom: 1px solid var(--border-color);
    }

    .leaflet-control-zoom-in:hover,
    .leaflet-control-zoom-out:hover {
      background-color: var(--hover-bg);
      color: var(--accent-blue);
    }

    @media (max-width: 900px) {
      #topSection {
        flex-direction: column;
      }

      #mapContainer {
        margin: 0;
      }

      .trail-info-panel {
        margin: 0;
        width: 100%;
      }

      #bottomSection {
        flex-direction: column;
      }

      .about-panel {
        max-width: 100%;
      }
    }

    .leaflet-popup-content-wrapper {
      background-color: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      box-shadow: 0 2px 12px rgba(0, 0, 0, 0.4);
    }

    .leaflet-popup-content {
      color: var(--text-primary);
      margin: 0;
    }

    .leaflet-popup-tip {
      background-color: var(--bg-secondary);
      border-color: var(--border-color);
    }

    /* Information panel at the top of the sidebar.  This panel provides
       instructions about using the site and buttons for exporting/importing
       completion status.  It borrows styling cues from peakbagger: dark
       background, rounded borders, and subtle borders. */
    .info-panel {
      margin: 0;
      padding: 1rem;
      background-color: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      color: var(--text-secondary);
      font-size: 0.85rem;
      line-height: 1.4;
    }
    .info-panel strong {
      color: var(--accent-blue);
    }
    .export-import {
      display: flex;
      gap: 0.5rem;
      margin-top: 0.75rem;
      flex-wrap: wrap;
    }
    .export-import button,
    .export-import label {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0.4rem 0.75rem;
      background-color: var(--button-green);
      color: white;
      border: none;
      border-radius: 5px;
      font-size: 0.8rem;
      cursor: pointer;
      transition: background-color 0.2s ease;
      text-decoration: none;
    }
    .export-import button:hover,
    .export-import label:hover {
      background-color: var(--button-green-dark);
    }
    /* Hide file input element */
    .export-import input[type="file"] {
      display: none;
    }

    /* Style for the link to view the GitHub API repository */
    .api-link-container {
      margin-top: 0.75rem;
      display: flex;
      justify-content: center;
    }
    .view-api-link {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.4rem;
      padding: 0.5rem 0.9rem;
      background-color: rgba(34, 197, 94, 0.12);
      color: #eafbf1;
      border: 1px solid var(--button-green);
      border-radius: 6px;
      font-size: 0.85rem;
      cursor: pointer;
      text-decoration: none;
      transition: background-color 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
      box-shadow: 0 6px 24px rgba(34, 197, 94, 0.18);
    }
    .view-api-link:hover {
      background-color: rgba(34, 197, 94, 0.22);
      color: #ffffff;
      box-shadow: 0 8px 28px rgba(34, 197, 94, 0.28);
    }

    /* Trail list styling adjustments for completed status */
    #trailList li {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .status-circle {
      flex-shrink: 0;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      border: 2px solid var(--border-color);
      margin-left: 0.5rem;
      cursor: pointer;
      transition: background-color 0.2s ease, border-color 0.2s ease;
    }
    .status-circle.completed {
      background-color: var(--success-green);
      border-color: var(--success-green);
    }

    /* Allow the trail name span to grow, pushing controls to the right */
    .trail-name {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    /* Date display and input styling */
    .date-container {
      margin-left: 0.5rem;
      font-size: 0.85rem;
      color: var(--text-primary);
      cursor: pointer;
      display: flex;
      align-items: center;
    }
    .date-container .date-icon {
      font-size: 1rem;
      margin-left: 0.25rem;
    }
    .date-input {
      display: none;
      background-color: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      color: var(--text-primary);
      padding: 0.2rem;
      margin-left: 0.25rem;
      font-size: 0.85rem;
    }
    /* invert calendar picker icon colors in date input */
    .date-input::-webkit-calendar-picker-indicator {
      filter: invert(1);
    }

    /* Styling for collapsible instructions */
    details summary {
      color: var(--text-primary);
      cursor: pointer;
      font-weight: 600;
      margin-top: 0.5rem;
    }
    details summary::-webkit-details-marker {
      color: var(--accent-blue);
    }
    details summary::marker {
      color: var(--accent-blue);
    }
    details p {
      margin: 0.5rem 0 0;
    }

    /* Button for launching virtual hike page */
    .hike-btn {
      width: 24px;
      height: 24px;
      margin-left: 0.5rem;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: var(--button-green); /* reuse existing button color */
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 1rem;
      line-height: 1;
    }
    .hike-btn:hover {
      background-color: var(--button-green-dark);
    }

    /* Fullscreen desktop layout */
    @media (min-width: 901px) {
      body {
        overflow: auto;
        margin: 0;
        padding: 0;
      }

      .page-shell {
        display: none;
      }

      #app {
        position: relative;
        top: auto;
        left: auto;
        right: auto;
        bottom: auto;
        padding: 1rem;
        margin: 0;
        display: flex;
        height: 100vh;
        width: 100vw;
        border: none;
        box-shadow: none;
        max-width: none;
      }

      .sidebar {
        width: 20%;
        min-width: 280px;
        max-width: 400px;
        height: 100vh;
        background: var(--bg-secondary);
        border: 1px solid var(--border-color);
        border-radius: 0;
        border-left: none;
        border-top: none;
        border-bottom: none;
        padding: 20px;
        overflow-y: auto;
        overflow-x: hidden;
        min-height: 0;
        word-wrap: break-word;
        overflow-wrap: break-word;
        z-index: 1000;
        box-shadow: 2px 0 8px rgba(0, 0, 0, 0.3);
        position: relative;
        flex-shrink: 0;
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .map-panel {
        flex: 1;
        height: 100vh;
        border: none;
        border-radius: 0;
        overflow: hidden;
        background: var(--bg-secondary);
        position: relative;
      }

      #mapContainer {
        flex: 1;
        display: flex;
        flex-direction: column;
        padding: 0;
        background-color: var(--bg-secondary);
        border: none;
        border-radius: 0;
        height: 100vh;
      }

      #map {
        flex: 1;
        width: 100%;
        height: 100%;
        background-color: #2d2d2d;
        border-radius: 0;
      }

      #nav-placeholder {
        position: fixed;
        top: 0;
        left: 20%;
        right: 0;
        z-index: 1001;
        background: rgba(26, 29, 35, 0.95);
        backdrop-filter: blur(10px);
        border-bottom: 1px solid var(--border-color);
        min-width: 280px;
      }

      /* Trail info panel styling for sidebar */
      .trail-info-panel {
        background: var(--bg-tertiary);
        border: 1px solid var(--border-color);
        border-radius: 10px;
        padding: 16px;
        margin-bottom: 16px;
      }

      .trail-info-heading {
        margin: 0 0 12px;
        font-size: 1.1rem;
        font-weight: 600;
      }

      .trail-info-empty {
        margin: 0;
        color: var(--text-secondary);
        font-size: 0.9rem;
      }

      .trail-info-about {
        margin-top: 16px;
      }

      .trail-info-about h3 {
        margin: 0 0 8px;
        font-size: 0.9rem;
        font-weight: 600;
        color: var(--text-primary);
      }

      .trail-info-about p {
        margin: 0;
        font-size: 0.85rem;
        color: var(--text-secondary);
        line-height: 1.4;
      }

      .trail-directory-title {
        font-size: 0.85rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: var(--text-secondary);
        margin: 4px 2px 10px;
      }

      .controls {
        display: flex;
        gap: 8px;
        margin-bottom: 12px;
      }

      .controls input[type="text"] {
        flex: 1;
        padding: 8px 12px;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        background: var(--bg-tertiary);
        color: var(--text-primary);
        font-size: 0.9rem;
      }

      .controls select {
        padding: 8px 12px;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        background: var(--bg-tertiary);
        color: var(--text-primary);
        font-size: 0.9rem;
      }

      .letter-nav-wrapper {
        margin-bottom: 12px;
      }

      .jump-label {
        font-size: 0.8rem;
        color: var(--text-secondary);
        margin-right: 8px;
      }

      .letter-nav {
        display: flex;
        flex-wrap: wrap;
        gap: 4px;
      }

      .letter-nav span {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 24px;
        height: 24px;
        font-size: 0.75rem;
        font-weight: 600;
        color: var(--text-secondary);
        background: var(--bg-tertiary);
        border: 1px solid var(--border-color);
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .letter-nav span:hover {
        background: var(--accent-blue);
        color: var(--text-primary);
        border-color: var(--accent-blue);
      }

      .trail-list-container {
        flex: 1;
        overflow-y: auto;
        min-height: 0;
      }

      #trailList {
        list-style: none;
        padding: 0;
        margin: 0;
      }

      #trailList li {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 8px 12px;
        margin-bottom: 4px;
        background: var(--bg-tertiary);
        border: 1px solid var(--border-color);
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      #trailList li:hover {
        background: var(--hover-bg);
        border-color: var(--accent-blue);
      }

      .loading-state {
        text-align: center;
        padding: 20px;
        color: var(--text-secondary);
      }
    }

    /* Mobile layout adjustments */
    @media (max-width: 900px) {
      body {
        overflow: auto;
      }

      .page-shell {
        display: block;
      }

      #app {
        position: relative;
        display: flex;
        flex-direction: column;
        height: auto;
        border: none;
        box-shadow: none;
        max-width: none;
        top: auto;
        left: auto;
        right: auto;
        bottom: auto;
      }

      .sidebar {
        background: var(--bg-secondary);
        border: 1px solid var(--border-color);
        border-radius: 12px;
        padding: 16px;
        overflow-y: auto;
        overflow-x: hidden;
        min-height: 0;
        word-wrap: break-word;
        overflow-wrap: break-word;
        position: relative;
        width: auto;
        height: auto;
        left: auto;
        top: auto;
        box-shadow: none;
        z-index: auto;
        flex-shrink: 0;
        order: 2;
      }

      .map-panel {
        border: 1px solid var(--border-color);
        border-radius: 12px;
        overflow: hidden;
        background: var(--bg-secondary);
        position: relative;
        left: auto;
        right: auto;
        top: auto;
        width: auto;
        flex: 1;
        order: 1;
        min-height: 50vh;
      }

      #mapContainer {
        order: 1;
        padding: 0;
        border: none;
        border-radius: 0;
        box-shadow: none;
        min-height: 50vh;
      }

      #map {
        min-height: 50vh;
      }

      #nav-placeholder {
        position: static;
        background: transparent;
        backdrop-filter: none;
        border: none;
        min-width: auto;
      }

      #panelResizer {
        display: none;
      }

      #bottomSection {
        order: -1;
        flex-direction: column;
        gap: 0.75rem;
        padding: 0.75rem 0.5rem;
      }

      #listSection {
        max-height: 400px;
        overflow-y: auto;
        border: none;
        border-radius: 0;
        box-shadow: none;
        background: var(--bg-tertiary);
        padding: 0.75rem 0.75rem;
      }

      #listSection .controls {
        position: sticky;
        top: 0;
        background: var(--bg-tertiary);
        z-index: 2;
        padding-top: 0.75rem;
        margin-left: -0.25rem;
        margin-right: -0.25rem;
      }

      .trail-list-container {
        max-height: none;
      }

      .about-panel {
        margin-top: 1rem;
        order: 2;
        width: 100%;
        max-width: none;
      }

      #topSection {
        flex-direction: column;
        gap: 0.75rem;
        padding: 0.75rem 0.5rem;
      }

      #trailInfoPanel {
        order: 2;
        margin-top: 0.75rem;
        width: 100%;
        border: none;
        border-radius: 0;
        box-shadow: none;
      }
    }
</style>
</head>

<body data-route="trails" data-page="trails">
  <div id="nav-placeholder"></div>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const navPlaceholder = document.getElementById('nav-placeholder');
      const activeRoute = document.body.dataset.route || document.body.dataset.page;

      if (navPlaceholder) {
        fetch('/pages/nav.html')
          .then(response => response.text())
          .then(html => {
            navPlaceholder.innerHTML = html;
            const links = navPlaceholder.querySelectorAll('.site-nav-links a');
            links.forEach(link => {
              const routes = (link.dataset.routes || link.dataset.route || '')
                .split(',')
                .map(value => value.trim())
                .filter(Boolean);

              if (routes.includes(activeRoute)) {
                link.classList.add('active');
                link.setAttribute('aria-current', 'page');
              }
            });
          })
          .catch(err => console.error('Failed to load navigation:', err));
      }
    });
  </script>
  <main id="app">
    <aside class="sidebar" aria-live="polite">
      <div id="trailInfoPanel" class="trail-info-panel">
        <h2 class="trail-info-heading">Select a trail to view details</h2>
        <p class="trail-info-empty" data-i18n="trails.details.empty">Select a trail to view distance, elevation, and OpenStreetMap details.</p>
        <div class="trail-info-about">
          <h3 data-i18n="trails.about.title">About this list</h3>
          <p data-i18n="trails.about.body">NH Tracing, Redlining, and White Mountain Trails all refer to the same collection of trails described in the guidebook. No matter which name you use, you're working towards the same goal of experiencing these paths.</p>
        </div>
      </div>
      <div class="trail-directory-title">White Mountain Trails</div>
      <!-- Search and sort controls -->
      <div class="controls">
        <!-- Search input with autocomplete support using datalist -->
        <input type="text" id="searchInput" data-i18n="trails.search" data-i18n-attr="placeholder" placeholder="Search trails…" list="trailSuggestions" autocomplete="off" />
        <!-- Datalist providing autocomplete suggestions for trail names sans suffixes -->
      <datalist id="trailSuggestions"></datalist>
      <select id="sortSelect">
        <option value="az" data-i18n="trails.sort.az">Sort A → Z</option>
        <option value="za" data-i18n="trails.sort.za">Sort Z → A</option>
      </select>
    </div>
      <!-- A‑Z letter navigation bar with label -->
      <div class="letter-nav-wrapper">
        <span class="jump-label" data-i18n="trails.jumpTo">Jump To:</span>
        <div id="letterNav" class="letter-nav"></div>
      </div>
      <!-- Trail list container -->
      <div class="trail-list-container">
        <ul id="trailList"></ul>
        <div id="loadingState" class="loading-state" style="display: none;">
          <p data-i18n="trails.loading">Loading trails...</p>
        </div>
      </div>
    </aside>
    <section class="map-panel">
      <div id="mapContainer">
        <div id="map"></div>
      </div>
    </section>
  </main>

  <div class="page-shell">
    <header class="page-header">
      <div class="page-logo">
        <div class="logo-wrap">
          <img src="/WMNF_Trails_API_logo.png" alt="White Mountain National Forest trails map logo" title="White Mountain Trails API" loading="lazy" decoding="async">
        </div>
      </div>
      <div class="header-text">
        <h1 data-i18n="trails.title">White Mountain Trails API Map Tool</h1>
        <h2 class="page-subtitle" data-i18n="trails.subtitle">Open peak, trail, and route data structure for the White Mountains.</h2>
        <p data-i18n="trails.intro">White Mountain National Forest — compiled by Nate Sobol. Use this as a quick trail finder and completion tracker. Open API and datasets for New Hampshire's 4,000-foot mountains.</p>
      </div>
    </header>
    <div class="nh48-lang" id="langPicker" data-i18n="common.languagePicker" data-i18n-attr="aria-label" aria-label="Language picker">
      <span class="nh48-lang-label" data-i18n="common.language">LANGUAGE</span>
      <button class="nh48-flag" data-lang="en" aria-label="English" title="English">
        <span class="flag flag-en" aria-hidden="true">EN</span>
      </button>
      <button class="nh48-flag" data-lang="es" aria-label="Español" title="Español">
        <span class="flag flag-es" aria-hidden="true">ES</span>
      </button>
      <button class="nh48-flag" data-lang="fr" aria-label="Français" title="Français">
        <span class="flag flag-fr" aria-hidden="true">FR</span>
      </button>
      <button class="nh48-flag" data-lang="de" aria-label="Deutsch" title="Deutsch">
        <span class="flag flag-de" aria-hidden="true">DE</span>
      </button>
      <button class="nh48-flag" data-lang="zh" aria-label="中文" title="中文">
        <span class="flag flag-zh" aria-hidden="true">ZH</span>
      </button>
      <button class="nh48-flag" data-lang="ja" aria-label="日本語" title="日本語">
        <span class="flag flag-ja" aria-hidden="true">JA</span>
      </button>
    </div>
    <nav class="page-breadcrumbs" aria-label="Breadcrumb">
      <ol>
        <li><a href="/">Home</a></li>
        <li>White Mountain Trails</li>
      </ol>
    </nav>

    <!-- Disclaimer and How to use sections for mobile -->
    <div id="trailIntroHome">
      <div id="trailIntroPanel" class="info-panel about-panel">
      <details open>
        <summary data-i18n="trails.disclaimer.title">Disclaimer</summary>
        <p data-i18n-html="trails.disclaimer.body">This site is <strong>not intended for planning or navigation</strong>. Trail data may contain minor errors or inaccuracies, and this collection is not the official list (though it includes most of the known trails). Please refer to official sources and use good judgement in the backcountry.</p>
      </details>
      <details open>
        <summary data-i18n="trails.howto.title">How to use</summary>
        <p data-i18n="trails.howto.body">Use the green circles to mark a trail as completed. After marking a trail, tap the calendar icon to add a date of completion — the date will replace the icon once selected and can be edited by tapping again. Your progress is stored locally in your browser. You can export or import your progress using the buttons below.</p>
      </details>
      <!-- Settings collapsible section for additional options -->
      <details>
        <summary data-i18n="trails.settings.title">Settings</summary>
        <div style="margin-top: 0.5rem; display: flex; flex-direction: column; gap: 0.5rem; font-size: 0.85rem;">
          <label style="display: flex; align-items: center; gap: 0.5rem;">
            <input type="checkbox" id="hideCompleted" />
            <span data-i18n="trails.settings.showCompleted">Hide completed trails</span>
          </label>
          <div style="display: flex; gap: 0.5rem; margin-top: 0.5rem;">
            <button id="exportBtn" style="padding: 0.25rem 0.5rem; border: 1px solid var(--border-color); background: var(--bg-tertiary); color: var(--text-primary); border-radius: 4px; cursor: pointer; font-size: 0.8rem;">
              Export
            </button>
            <label style="display: flex; align-items: center; gap: 0.25rem; cursor: pointer; padding: 0.25rem 0.5rem; border: 1px solid var(--border-color); background: var(--bg-tertiary); border-radius: 4px; font-size: 0.8rem;">
              <span data-i18n="trails.import">Import</span>
              <input type="file" id="importFile" accept=".csv,.xlsx,.json" style="display: none;" />
            </label>
            <button id="clearProgress" style="padding: 0.25rem 0.5rem; border: 1px solid var(--accent-red); background: var(--bg-tertiary); color: var(--accent-red); border-radius: 4px; cursor: pointer; font-size: 0.8rem;">
              Clear Progress
            </button>
          </div>
        </div>
        <!-- Link to view the GitHub API repository -->
        <div class="api-link-container">
          <a href="https://github.com/natesobol/WMNF-Trails-API/tree/main" target="_blank" rel="noopener noreferrer" class="view-api-link">
            <!-- GitHub logo SVG -->
            <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" style="fill: currentColor; margin-right: 0.4rem;">
              <path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82a7.62 7.62 0 012-.27c.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
            </svg>
            <span data-i18n="trails.viewApi">View API</span>
          </a>
        </div>
      </div>
      </div>
    </div>
  </div>

  <!-- Include Leaflet JS library.  Leaflet provides map rendering and helper
       functions for working with GeoJSON.  The integrity hash ensures the
       downloaded script hasn't been tampered with. -->
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    crossorigin=""
  ></script>
  <!-- Include SheetJS library for XLSX import/export -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script>
    (async function() {
      const t = (key, vars) => (window.NH48_I18N && window.NH48_I18N.t ? window.NH48_I18N.t(key, vars) : key);

      const trackEvent = (name, params = {}) => {
        const analytics = window.NH48_INFO_ANALYTICS;
        if (analytics && analytics.logEvent && analytics.analytics) {
          analytics.logEvent(analytics.analytics, name, {
            page: location.pathname,
            ...params
          });
        }
      };

      // Set an improved center and zoom over the White Mountain National Forest.
      // These coordinates zoom closer to the core of the WMNF while showing most trails.
      const defaultCenter = [44.15, -71.5];
      const defaultZoom = 9;

      // Create the map.  The `L.map` function takes the id of the map container.
      const map = L.map('map').setView(defaultCenter, defaultZoom);

      // Use a detailed topographic map tile layer (OpenTopoMap) which includes contour lines
      // and hiking paths.  Attribution is required to credit data sources.
      const baseLayer = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
        attribution: t('trails.map.attribution'),
        maxZoom: 17,
        crossOrigin: true
      }).addTo(map);

      // Fallback to standard OpenStreetMap tiles if OpenTopoMap is unavailable
      const fallbackLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap contributors'
      });

      baseLayer.on('tileerror', () => {
        if (!map.hasLayer(fallbackLayer)) {
          fallbackLayer.addTo(map);
        }
      });

      // Overlay high-contrast hiking trails on top of the topo base
      const hikingOverlay = L.tileLayer('https://tile.waymarkedtrails.org/hiking/{z}/{x}/{y}.png', {
        attribution: 'Hiking overlay &copy; waymarkedtrails.org',
        opacity: 0.9
      }).addTo(map);

      map.on('zoomend', () => {
        trackEvent('trails_map_zoom', { zoom: map.getZoom() });
      });
      map.on('moveend', () => {
        const center = map.getCenter();
        trackEvent('trails_map_move', { lat: center.lat, lng: center.lng });
      });

      // Allow the user to resize the split between the map/top content and the list below.
      const appContainer = document.getElementById('app');
      const panelResizer = document.getElementById('panelResizer');
      const minimumTopHeight = 260;
      const minimumListHeight = 240;

      function setPanelHeight(clientY) {
        if (!appContainer) return;
        const rect = appContainer.getBoundingClientRect();
        const rawHeight = clientY - rect.top;
        const maxTop = rect.height - minimumListHeight;
        const clampedHeight = Math.min(Math.max(rawHeight, minimumTopHeight), maxTop);
        appContainer.style.setProperty('--top-height', `${clampedHeight}px`);
        requestAnimationFrame(() => map.invalidateSize());
      }

      // Only set up panel resizer if it exists (it won't in the new layout)
      if (panelResizer) {
        panelResizer.addEventListener('pointerdown', event => {
          event.preventDefault();
          trackEvent('trails_panel_resize_start');
          const handleMove = moveEvent => setPanelHeight(moveEvent.clientY);
          const handleUp = () => {
            window.removeEventListener('pointermove', handleMove);
            window.removeEventListener('pointerup', handleUp);
            trackEvent('trails_panel_resize_end');
          };
          window.addEventListener('pointermove', handleMove);
          window.addEventListener('pointerup', handleUp);
        });
      }

      // Containers for the trail data.  `trailLayers` maps trail names to their
      // Leaflet layer and feature information.  `trailNames` holds just the names
      // for easy sorting and filtering.  `completedTrails` tracks user‑marked
      // completion status for each trail, persisted in localStorage.
      const trailLayers = {};
      const trailNames = [];
      const completionKey = 'wmnfTrailCompletion';
      let completedTrails = {};
      // A‑Z navigation helpers
      const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
      let letterPositions = {};
      // Create the letter navigation bar elements once
      const letterNavContainer = document.getElementById('letterNav');
      letters.forEach(letter => {
        const span = document.createElement('span');
        span.textContent = letter;
        span.setAttribute('data-letter', letter);
        span.addEventListener('click', function(e) {
          const targetLetter = this.getAttribute('data-letter');
          trackEvent('trails_letter_nav_click', { letter: targetLetter });
          const idx = letterPositions[targetLetter];
          if (idx != null && idx !== undefined && idx >= 0) {
            const li = document.querySelectorAll('#trailList li')[idx];
            if (li) {
              li.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
          }
        });
        letterNavContainer.appendChild(span);
      });
      const searchInput = document.getElementById('searchInput');
      const initialTrailQuery = new URLSearchParams(window.location.search).get('trail');
      // Retrieve success (completed) color from CSS variables.  Fallback to
      // a hardcoded green if not found.
      const successColor = getComputedStyle(document.documentElement).getPropertyValue('--success-green').trim() || '#51cf66';
      const defaultTrailColor = '#e03a2d';
      const selectedTrailColor = '#b81414';

      // Track whether completed trails should be hidden in the list. This is toggled
      // via the settings panel checkbox. Defaults to false (show all).
      let hideCompleted = false;

      // Trail info lookup and UI state for the details panel beneath the map.
      const trailInfoPanel = document.getElementById('trailInfoPanel');
      let trailInfoLookup = new Map();
      let trailInfoLoaded = false;
      let currentTrailSelection = null;
      let introPanelShown = false;
      let introPanelDismissed = false;
      const introPanel = document.getElementById('trailIntroPanel');
      const introPanelHome = document.getElementById('trailIntroHome');
      let telemetryTrailCount = null;

      // Normalize trail names for matching (case-insensitive, trimmed, collapses spaces).
      function normalizeTrailName(name) {
        return (name || '')
          .toString()
          .trim()
          .replace(/\s+/g, ' ')
          .toLowerCase();
      }

      function normalizeTrailNameLoose(name) {
        return (name || '')
          .toString()
          .toLowerCase()
          .normalize('NFKD')
          .replace(/[^a-z0-9]/g, '');
      }

      function buildTrailNameVariants(name) {
        const collapsed = normalizeTrailNameLoose(name);
        const withoutTrail = collapsed.replace(/trail$/, '').replace(/trail/g, '');
        return [collapsed, withoutTrail].filter(Boolean);
      }

      function matchTrailName(query, names) {
        if (!query) return null;
        const normalizedQuery = normalizeTrailName(query);
        const strippedQuery = normalizedQuery.replace(/\btrail\b/g, '').trim();
        return names.find(name => normalizeTrailName(name) === normalizedQuery)
          || names.find(name => normalizeTrailName(name) === strippedQuery)
          || names.find(name => normalizeTrailName(name).replace(/\btrail\b/g, '').trim() === strippedQuery);
      }

      // Register a record in the lookup map using a few common name variants.
      function registerTrailRecord(record) {
        if (!record || !record.trail_name) return;
        const base = normalizeTrailName(record.trail_name);
        const variants = new Set([base]);
        const stripped = base.replace(/\btrail\b/gi, '').trim();
        if (stripped) {
          variants.add(stripped);
          variants.add(`${stripped} trail`);
        }
        variants.forEach(key => {
          if (key && !trailInfoLookup.has(key)) {
            trailInfoLookup.set(key, record);
          }
        });
      }

      function toRadians(deg) {
        return (deg * Math.PI) / 180;
      }

      function haversineMiles(a, b) {
        const R = 3958.8; // Earth radius in miles
        const dLat = toRadians(b.lat - a.lat);
        const dLon = toRadians(b.lon - a.lon);
        const lat1 = toRadians(a.lat);
        const lat2 = toRadians(b.lat);
        const sinDLat = Math.sin(dLat / 2);
        const sinDLon = Math.sin(dLon / 2);
        const aa = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon;
        const c = 2 * Math.atan2(Math.sqrt(aa), Math.sqrt(1 - aa));
        return R * c;
      }

      function computeDistanceMiles(coords) {
        if (!Array.isArray(coords) || coords.length < 2) return 0;
        let distance = 0;
        for (let i = 1; i < coords.length; i++) {
          const prev = { lat: coords[i - 1][1], lon: coords[i - 1][0] };
          const curr = { lat: coords[i][1], lon: coords[i][0] };
          distance += haversineMiles(prev, curr);
        }
        return distance;
      }

      function formatTagLabel(key) {
        if (!key) return '';
        if (key.toLowerCase() === 'sac_scale') return 'SAC scale';
        return key
          .replace(/_/g, ' ')
          .replace(/:/g, ': ')
          .replace(/\b\w/g, char => char.toUpperCase());
      }

      function escapeHtml(input) {
        return String(input)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;');
      }

      function formatTagValue(key, value) {
        if (value == null) return '—';
        if (Array.isArray(value)) return value.map(v => escapeHtml(v)).join(', ');
        if (typeof value === 'boolean') return value ? 'yes' : 'no';
        const str = escapeHtml(value);
        if (key && (key.toLowerCase().includes('website') || key.toLowerCase().includes('url'))) {
          return `<a href="${str}" target="_blank" rel="noopener noreferrer">${str}</a>`;
        }
        return str;
      }

      function firstTagValue(tags, keys) {
        for (const key of keys) {
          if (tags[key] != null) {
            return { key, value: tags[key] };
          }
        }
        return { key: null, value: null };
      }

      function parseElevationFeet(value) {
        if (value == null) return null;
        const raw = String(value).trim();
        const num = parseFloat(raw.replace(/,/g, ''));
        if (!Number.isFinite(num)) return null;
        const isMeters = /\b(m|meter|metre)\b/i.test(raw);
        const feet = isMeters ? num * 3.28084 : num;
        return Math.round(feet);
      }

      function formatElevation(value) {
        const feet = parseElevationFeet(value);
        if (feet == null) {
          return value ? escapeHtml(value) : '—';
        }
        return `${feet.toLocaleString()} ft`;
      }

      async function fetchJsonWithFallback(urls) {
        for (const url of urls) {
          try {
            const response = await fetch(url, { cache: 'no-cache' });
            if (response.ok) {
              const data = await response.json();
              trackEvent('trails_osm_fetch_success', { source: url });
              return data;
            }
          } catch (err) {
            console.warn(`Failed to fetch ${url}:`, err.message);
            trackEvent('trails_osm_fetch_error', { source: url });
          }
        }
        return null;
      }

      async function fetchTextWithFallback(urls) {
        for (const url of urls) {
          try {
            const response = await fetch(url, { cache: 'no-cache' });
            if (response.ok) {
              const text = await response.text();
              trackEvent('trails_osm_fetch_success', { source: url });
              return text;
            }
          } catch (err) {
            console.warn(`Failed to fetch ${url}:`, err.message);
            trackEvent('trails_osm_fetch_error', { source: url });
          }
        }
        return null;
      }

      async function loadOfficialTrailNames() {
        const urls = [
          '../data/wmnf-trails/White_Mountains_Trails.txt',
          '/data/wmnf-trails/White_Mountains_Trails.txt',
          'https://raw.githubusercontent.com/natesobol/nh48-api/main/data/wmnf-trails/White_Mountains_Trails.txt'
        ];
        const text = await fetchTextWithFallback(urls);
        if (!text) return null;

        const names = text
          .split(/\r?\n/)
          .map(line => line.trim())
          .filter(Boolean);

        const normalized = new Set();
        names.forEach(name => {
          buildTrailNameVariants(name).forEach(variant => normalized.add(variant));
        });

        return { names, normalized };
      }

      async function loadOsmTrailData() {
        console.log('Starting to load OSM trail data...');
        const sources = [
          [
            '../data/wmnf-trails/wmnf-main.json',
            '/data/wmnf-trails/wmnf-main.json',
            'https://raw.githubusercontent.com/natesobol/nh48-api/main/data/wmnf-trails/wmnf-main.json'
          ],
          [
            '../data/wmnf-trails/wmnf-maine.json',
            '/data/wmnf-trails/wmnf-maine.json',
            'https://raw.githubusercontent.com/natesobol/nh48-api/main/data/wmnf-trails/wmnf-maine.json'
          ],
          [
            '../data/wmnf-trails/wmnf-pliney.json',
            '/data/wmnf-trails/wmnf-pliney.json',
            'https://raw.githubusercontent.com/natesobol/nh48-api/main/data/wmnf-trails/wmnf-pliney.json'
          ]
        ];

        console.log('Loading official trail names...');
        const officialNames = await loadOfficialTrailNames();
        console.log('Official names loaded:', officialNames ? 'success' : 'failed');
        const allowedNames = officialNames?.normalized || null;
        console.log('Allowed names count:', allowedNames ? allowedNames.size : 0);

        const allElements = [];
        for (let i = 0; i < sources.length; i++) {
          const urls = sources[i];
          console.log(`Loading source ${i + 1}/${sources.length}...`);
          const data = await fetchJsonWithFallback(urls);
          if (data && Array.isArray(data.elements)) {
            console.log(`Source ${i + 1}: loaded ${data.elements.length} elements`);
            allElements.push(...data.elements);
          } else {
            console.log(`Source ${i + 1}: failed to load`);
          }
        }

        console.log(`Total elements loaded: ${allElements.length}`);

        trailInfoLookup = new Map();

        if (!allElements.length) {
          trailInfoLoaded = true;
          console.warn('No OSM trail data could be loaded.');
          trackEvent('trails_osm_load_failed');
          return null;
        }

        const grouped = new Map();

        allElements.forEach(element => {
          const tags = element.tags || {};
          const name = tags.name || tags.ref || `OSM ${element.type} ${element.id}`;
          const nameVariants = buildTrailNameVariants(name);
          if (allowedNames && !nameVariants.some(variant => allowedNames.has(variant))) {
            return;
          }
          const coords = (element.geometry || []).map(point => [point.lon, point.lat]);
          if (coords.length < 2) return;

          if (!grouped.has(name)) {
            grouped.set(name, {
              name,
              segments: [],
              tags: {},
              osm_ids: [],
              distance_miles: 0
            });
          }

          const group = grouped.get(name);
          group.segments.push(coords);
          group.osm_ids.push(element.id);
          group.tags = { ...group.tags, ...tags };
          group.distance_miles += computeDistanceMiles(coords);
        });

        console.log(`Grouped trails: ${grouped.size}`);

        if (!grouped.size) {
          telemetryTrailCount = 0;
          trailInfoLoaded = true;
          console.warn('No OSM trail data matched the official trail list.');
          trackEvent('trails_osm_load_filtered_out');
          return { type: 'FeatureCollection', features: [] };
        }

        const features = [];
        grouped.forEach(group => {
          const geometry = group.segments.length === 1
            ? { type: 'LineString', coordinates: group.segments[0] }
            : { type: 'MultiLineString', coordinates: group.segments };
          const properties = {
            name: group.name,
            osm_ids: group.osm_ids,
            tags: group.tags,
            distance_miles: group.distance_miles
          };
          features.push({ type: 'Feature', properties, geometry });
          registerTrailRecord({
            trail_name: group.name,
            osm_ids: group.osm_ids,
            tags: group.tags,
            distance_miles: group.distance_miles
          });
        });

        telemetryTrailCount = features.length;
        trailInfoLoaded = true;
        trackEvent('trails_osm_loaded', { features: features.length, elements: allElements.length });

        if (currentTrailSelection) {
          renderTrailInfo(currentTrailSelection);
        }

        return { type: 'FeatureCollection', features };
      }

      function formatFeet(value) {
        return value == null ? '—' : `${value.toLocaleString()} ft`;
      }

      function formatDistance(value) {
        if (value == null) return '—';
        const rounded = Math.round(value * 100) / 100;
        return `${rounded} miles`;
      }

      function showIntroPanel() {
        if (!trailInfoPanel || !introPanel) return;
        if (trailInfoPanel.contains(introPanel)) {
          introPanelShown = true;
          return;
        }
        trailInfoPanel.innerHTML = '';
        trailInfoPanel.appendChild(introPanel);
        introPanelShown = true;
      }

      function restoreIntroPanelHome() {
        if (!introPanel || !introPanelHome) return;
        if (!introPanelHome.contains(introPanel)) {
          introPanelHome.appendChild(introPanel);
        }
      }

      function renderTrailInfo(name) {
        if (!trailInfoPanel) return;
        currentTrailSelection = name || null;

        if (!name) {
          if (!introPanelDismissed) {
            showIntroPanel();
            return;
          }
          restoreIntroPanelHome();
          trailInfoPanel.innerHTML = `
            <h2 class="trail-info-heading">Select a trail to view details</h2>
            <p class="trail-info-empty">${t('trails.details.empty')}</p>
          `;
          return;
        }
        introPanelDismissed = true;
        restoreIntroPanelHome();

        const record = trailInfoLookup.get(normalizeTrailName(name));
        if (!record) {
          const message = trailInfoLoaded
            ? t('trails.info.noProperties')
            : t('trails.info.loadingProperties');
          trailInfoPanel.innerHTML = `
            <h2>${name}</h2>
            <p class="trail-info-empty">${message}</p>
          `;
          return;
        }

        const tags = record.tags || {};
        const displayedKeys = new Set();

        const allowedUses = ['foot', 'bicycle', 'horse', 'ski', 'snowmobile', 'atv']
          .map(key => tags[key] ? `${key}: ${tags[key]}` : null)
          .filter(Boolean);

        const elevationGain = firstTagValue(tags, ['elevation_gain', 'ascent', 'ascent:gain', 'ele:gain']);
        const elevationLoss = firstTagValue(tags, ['descent', 'descent:loss', 'ele:loss']);
        const highPoint = firstTagValue(tags, ['ele:max', 'max_ele', 'ele_highest', 'ele']);
        const lowPoint = firstTagValue(tags, ['ele:min', 'min_ele', 'ele_lowest']);
        const accessFee = [tags.access, tags.fee].filter(Boolean).join(' · ');
        const season = tags.season || tags.seasonal || tags['season:conditional'];
        const maintainer = tags.operator || tags.maintainer || tags.owner;
        const description = firstTagValue(tags, ['description', 'note', 'comment', 'history', 'historic']);
        const condition = firstTagValue(tags, ['trail_visibility', 'smoothness', 'mtb:scale:imba', 'mtb:scale', 'ski:rating']);

        const fields = [
          { label: t('trails.info.distance'), value: formatDistance(record.distance_miles) },
          { label: 'Elevation gain', value: formatElevation(elevationGain.value), key: elevationGain.key },
          { label: 'Elevation loss', value: formatElevation(elevationLoss.value), key: elevationLoss.key },
          { label: 'High point', value: formatElevation(highPoint.value), key: highPoint.key },
          { label: 'Low point', value: formatElevation(lowPoint.value), key: lowPoint.key },
          { label: t('trails.info.trailType'), value: tags.highway || tags.route || tags.trail_type || '—', key: 'highway' },
          { label: t('trails.info.surface'), value: tags.surface ?? '—', key: 'surface' },
          { label: t('trails.info.difficulty'), value: tags.sac_scale || tags.smoothness || tags.difficulty || '—', key: 'sac_scale' },
          { label: t('trails.info.visibility'), value: condition.value || tags.trail_visibility || '—', key: condition.key || 'trail_visibility' },
          { label: t('trails.info.allowedUses'), value: allowedUses.length ? allowedUses.join(', ') : (tags.access ?? '—'), key: 'access' },
          { label: t('trails.info.season'), value: season || '—', key: 'season' },
          { label: t('trails.info.maintainer'), value: maintainer || '—', key: 'operator' },
          { label: 'Access / fees', value: accessFee || tags.permit || '—', key: accessFee ? 'access' : 'permit' },
          { label: 'Network', value: tags.network || '—', key: 'network' },
          { label: 'Reference', value: tags.ref || '—', key: 'ref' },
          { label: 'Website', value: formatTagValue('website', tags.website), key: 'website' },
          { label: 'Notes & history', value: formatTagValue(description.key, description.value) },
          { label: 'Source / last update', value: [tags.source, tags['source:date']].filter(Boolean).join(' · ') || '—', key: 'source' }
        ];

        const primaryItems = fields
          .filter(field => field.value && field.value !== '—')
          .map(field => {
            if (field.key) displayedKeys.add(field.key);
            return `
              <div class="trail-info-item">
                <span>${field.label}</span>
                <strong>${field.value}</strong>
              </div>
            `;
          });

        const extraTags = Object.entries(tags)
          .filter(([key, value]) => key !== 'name' && value && !displayedKeys.has(key))
          .map(([key, value]) => `
            <div class="trail-info-item">
              <span>${formatTagLabel(key)}</span>
              <strong>${formatTagValue(key, value)}</strong>
            </div>
          `);

        trailInfoPanel.innerHTML = `
          <h2>${record.trail_name || name}</h2>
          <p>${t('trails.info.sourceNote')}</p>
          <div class="trail-info-grid">${primaryItems.concat(extraTags).join('')}</div>
        `;
      }

      /**
       * Load completion data from localStorage.  If no data exists, an empty
       * object is used.  Parsing errors are silently ignored.
       */
      function loadCompletion() {
        try {
          const stored = localStorage.getItem(completionKey);
          const parsed = stored ? JSON.parse(stored) : {};
          // If the old format used a boolean for completed trails, convert to object
          Object.keys(parsed).forEach(key => {
            const val = parsed[key];
            if (typeof val === 'boolean') {
              parsed[key] = { completed: val, date: '' };
            } else if (val && typeof val === 'object') {
              // Ensure both properties exist
              parsed[key] = {
                completed: !!val.completed,
                date: val.date || ''
              };
            } else {
              // Unknown format, treat as incomplete
              parsed[key] = { completed: false, date: '' };
            }
          });
          completedTrails = parsed;
        } catch (e) {
          completedTrails = {};
        }
      }

      /**
       * Persist completion data back to localStorage.  Always stringify the
       * object to ensure consistent storage.
       */
      function saveCompletion() {
        try {
          localStorage.setItem(completionKey, JSON.stringify(completedTrails));
        } catch (e) {
          console.warn('Failed to save completion state:', e);
        }
      }

      /**
       * Toggle completion status for a given trail.  After toggling, persist
       * the change and reapply styles to both the map and list.
       *
       * @param {string} name The trail name
       */
      function toggleCompletion(name) {
        // Ensure entry exists
        if (!completedTrails[name]) {
          completedTrails[name] = { completed: false, date: '' };
        }
        const currentStatus = completedTrails[name].completed;
        completedTrails[name].completed = !currentStatus;
        // When marking incomplete, clear the date
        if (!completedTrails[name].completed) {
          completedTrails[name].date = '';
        }
        saveCompletion();
        applyCompletionStyles();
        renderTrailList();
      }

      /**
       * Apply completion styles to all trail layers.  Completed trails are
       * colored green, while incomplete trails retain the default blue.
       */
      function applyCompletionStyles() {
        Object.entries(trailLayers).forEach(([name, info]) => {
          const status = completedTrails[name];
          const completed = status && status.completed;
          const color = defaultTrailColor;
          const weight = completed ? 5 : 3;
          info.layer.setStyle({ color: color, weight: weight });
        });
      }

      /**
       * Apply a visibility filter based on the current search results.  This
       * function hides trails not present in the filtered list by setting
       * their opacity to zero while preserving their original colors and
       * weights.  Visible trails remain at full opacity.
       *
       * @param {string[]} filteredNames The list of trail names that should be visible
       */
      function applyFilterStyles(filteredNames) {
        Object.entries(trailLayers).forEach(([name, info]) => {
          const status = completedTrails[name];
          const completed = status && status.completed;
          const isVisible = filteredNames.includes(name);
          // Determine color and weight as in applyCompletionStyles
          const color = defaultTrailColor;
          const weight = completed ? 5 : 3;
          const opacity = isVisible ? 1 : 0;
          info.layer.setStyle({ color: color, weight: weight, opacity: opacity });
        });
      }

      /**
       * Export progress as a CSV file.  Each row contains the trail name and
       * whether it is completed (true/false).
       */
      function exportCSV() {
        const headers = [
          t('trails.csv.headerTrail'),
          t('trails.csv.headerCompleted'),
          t('trails.csv.headerDate')
        ];
        let csv = `${headers.join(',')}\n`;
        trailNames.forEach(name => {
          const status = completedTrails[name] || { completed: false, date: '' };
          const completed = status.completed ? 'true' : 'false';
          const date = status.date || '';
          // Escape double quotes in names
          const safeName = name.replace(/"/g, '""');
          csv += `"${safeName}",${completed},${date}\n`;
        });
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = t('trails.csv.filename');
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      }

      /**
       * Parse CSV text and update completion data accordingly.  Assumes
       * first row contains headers and subsequent rows contain name and
       * completed flag.  Ignores unknown trails.
       *
       * @param {string} text Raw CSV content
       */
      function parseCSV(text) {
        const lines = text.split(/\r?\n/).filter(l => l.trim());
        const imported = {};
        lines.slice(1).forEach(line => {
          const parts = line.split(',');
          if (parts.length >= 2) {
            const name = parts[0].replace(/^"|"$/g, '').replace(/""/g, '"').trim();
            const val = (parts[1] || '').trim().toLowerCase();
            const date = (parts[2] || '').trim();
            imported[name] = {
              completed: val === 'true' || val === '1' || val === 'yes',
              date: date
            };
          }
        });
        completedTrails = imported;
        saveCompletion();
        applyCompletionStyles();
        renderTrailList();
        trackEvent('trails_import_complete', { count: Object.keys(imported).length, source: 'csv' });
      }

      /**
       * Parse rows from an XLSX worksheet and update completion data.
       * Accepts an array of arrays where the first row is a header.
       *
       * @param {Array<Array<any>>} rows Parsed rows from sheetjs
       */
      function parseRows(rows) {
        const imported = {};
        rows.slice(1).forEach(row => {
          const name = row[0];
          const val = String(row[1] || '').toLowerCase();
          const date = row.length >= 3 ? String(row[2] || '').trim() : '';
          imported[name] = {
            completed: val === 'true' || val === '1' || val === 'yes',
            date: date
          };
        });
        completedTrails = imported;
        saveCompletion();
        applyCompletionStyles();
        renderTrailList();
        trackEvent('trails_import_complete', { count: Object.keys(imported).length, source: 'xlsx' });
      }

      // Hook up export button click
      const exportBtn = document.getElementById('exportBtn');
      if (exportBtn) {
        exportBtn.addEventListener('click', () => {
          trackEvent('trails_export_csv');
          exportCSV();
        });
      }
      // Hook up import file change
      const importFile = document.getElementById('importFile');
      if (importFile) {
        importFile.addEventListener('change', function(e) {
          const file = e.target.files[0];
          if (!file) return;
          trackEvent('trails_import_start', { extension: file.name.split('.').pop().toLowerCase() });
          const ext = file.name.split('.').pop().toLowerCase();
          if (ext === 'csv') {
            const reader = new FileReader();
            reader.onload = function(ev) {
              parseCSV(ev.target.result);
            };
            reader.readAsText(file);
          } else if (ext === 'xlsx' || ext === 'xls') {
            const reader = new FileReader();
            reader.onload = function(ev) {
              const data = new Uint8Array(ev.target.result);
              const workbook = XLSX.read(data, { type: 'array' });
              const sheet = workbook.Sheets[workbook.SheetNames[0]];
              const rows = XLSX.utils.sheet_to_json(sheet, { header: 1 });
              parseRows(rows);
            };
            reader.readAsArrayBuffer(file);
          }
          // reset input to allow re-import of same file
          this.value = '';
        });
      }

      // Helper function to highlight a single trail layer.  Resets all others
      // back to the default style before applying a highlighted style to the
      // selected trail.
      function highlightLayer(targetLayer) {
        // Reset all trails to their completion or default color
        applyCompletionStyles();
        // Highlight the selected trail in red
        targetLayer.setStyle({ color: selectedTrailColor, weight: 6 });
      }

      function focusTrailBounds(layer) {
        if (!layer) return;
        const bounds = layer.getBounds();
        if (!bounds || !bounds.isValid()) return;
        map.fitBounds(bounds.pad(0.12), {
          maxZoom: 14,
          animate: true,
          padding: [48, 48]
        });
      }

      /**
       * Populate the datalist for autocomplete suggestions.  Creates a set of
       * simplified trail names with common suffix words removed (e.g., "Trail",
       * "Loop", "Cutoff", etc.) and inserts them as options into the datalist.
       */
      function populateSuggestions() {
        const suffixes = ['trail','loop','cutoff','road','path','connector','summit','route'];
        const suggestions = new Set();
        trailNames.forEach(name => {
          // Remove trailing suffix words
          let parts = name.split(' ');
          while (parts.length > 1 && suffixes.includes(parts[parts.length - 1].toLowerCase())) {
            parts.pop();
          }
          const suggestion = parts.join(' ');
          suggestions.add(suggestion);
        });
        const datalist = document.getElementById('trailSuggestions');
        if (!datalist) return;
        datalist.innerHTML = '';
        suggestions.forEach(s => {
          const option = document.createElement('option');
          option.value = s;
          datalist.appendChild(option);
        });
      }

      /**
       * Populate the map with GeoJSON features.  Each feature becomes a
       * clickable polyline on the map.  When clicked, the trail is highlighted
       * and the map view zooms to its bounds.  The trail name is used
       * as a key in the `trailLayers` object for quick lookup later.
       *
       * @param {Object} geoData The GeoJSON FeatureCollection to display
       */
      function addTrailsToMap(geoData) {
        const geoLayer = L.geoJSON(geoData, {
          style: function(feature) {
            // Default line styling.  You can change the color or weight here.
            return { color: defaultTrailColor, weight: 3 };
          },
          onEachFeature: function(feature, layer) {
            const name = feature.properties && feature.properties.name
              ? feature.properties.name
              : t('trails.unnamedTrail');
            // Store reference to this layer and its original feature
            trailLayers[name] = { layer: layer, feature: feature };
            trailNames.push(name);
            // Bind a popup showing the trail name.  When the line is clicked
            // the popup appears.  You can add more content here (length, notes, etc.).
            layer.bindPopup(`<strong>${name}</strong>`);
            // Handle click on the map line.  Highlight and zoom.
            layer.on('click', function() {
              highlightLayer(layer);
              focusTrailBounds(layer);
              layer.openPopup();
              renderTrailInfo(name);
              trackEvent('trails_map_trail_click', { trail: name });
            });
          }
        }).addTo(map);
        // After adding all features, apply completion styles to set initial colors
        applyCompletionStyles();
      }

      /**
       * Render the list of trails in the sidebar.  The list is filtered by
       * the search input and sorted according to the dropdown.  Each item
       * becomes clickable; clicking will highlight and pan to the trail.
       */
      function renderTrailList() {
        const listElement  = document.getElementById('trailList');
        const container    = listElement.parentElement;
        const searchQuery  = document.getElementById('searchInput').value.trim().toLowerCase();
        const sortOrder    = document.getElementById('sortSelect').value;

        // 1. Filter names by search query and hide‑completed flag.
        let names = trailNames.filter(name => filterBySearch(name, searchQuery));
        if (hideCompleted) {
          names = names.filter(name => !isTrailCompleted(name));
        }

        // 2. Sort names alphabetically (ascending by default, descending if 'za').
        names.sort((a, b) => (sortOrder === 'za' ? b.localeCompare(a) : a.localeCompare(b)));

        // 3. Clear any previous empty‑state messages and existing list items.
        container.querySelectorAll('.empty-state').forEach(el => el.remove());
        listElement.innerHTML = '';

        // 4. If no names match, show an appropriate empty message and return early.
        if (names.length === 0) {
          showEmptyState(container, searchQuery);
          return;
        }

        // 5. Populate list items for each trail.
        names.forEach(name => {
          const li = createTrailListItem(name);
          listElement.appendChild(li);
        });

        // 6. Update A‑Z navigation positions and apply map filter styles.
        updateLetterPositions(names);
        applyFilterStyles(names);
      }

      /**
       * Return true if a trail name matches the search query.  It checks both the
       * full name and a simplified version with common suffixes removed.
       */
      function filterBySearch(name, query) {
        if (!query) return true;
        const nameLower = name.toLowerCase();
        const simple    = nameLower
          .replace(/\b(trail|loop|cutoff|road|path|connector|summit|route)\b/g, '')
          .replace(/\s+/g, ' ')
          .trim();
        return nameLower.includes(query) || simple.includes(query);
      }

      /** Returns true if a trail is marked as completed in the global state. */
      function isTrailCompleted(name) {
        const status = completedTrails[name];
        return status && status.completed;
      }

      /** Show a message when the filtered list is empty. */
      function showEmptyState(container, query) {
        const emptyMsg    = document.createElement('div');
        emptyMsg.className = 'empty-state';
        emptyMsg.textContent = query
          ? t('trails.list.noMatches')
          : t('trails.list.noTrails');
        container.appendChild(emptyMsg);
      }

      /**
       * Create a fully wired list item for a given trail.  It includes the name,
       * date display/input, status indicator, and optional virtual hike button.
       */
      function createTrailListItem(name) {
        const li       = document.createElement('li');
        const nameSpan = document.createElement('span');
        nameSpan.className  = 'trail-name';
        nameSpan.textContent = name;

        // Build status circle and date controls.
        const { statusSpan, dateContainer, dateInput } = createStatusAndDateControls(name);

        // When clicking the list item, highlight the trail on the map.
        li.addEventListener('click', () => {
          const info = trailLayers[name];
          if (info) {
            highlightLayer(info.layer);
            focusTrailBounds(info.layer);
            info.layer.openPopup();
            document.querySelectorAll('#trailList li').forEach(el => el.classList.remove('active'));
            li.classList.add('active');
            renderTrailInfo(name);
            trackEvent('trails_list_trail_click', { trail: name });
          }
        });

        // Assemble the list item.
        li.appendChild(nameSpan);
        li.appendChild(dateContainer);
        li.appendChild(dateInput);
        li.appendChild(statusSpan);
        return li;
      }

      /**
       * Create and wire up the status circle and date picker/input for a trail.
       * Returns the status span, date container span, and date input element.
       */
      function createStatusAndDateControls(name) {
        // Status circle for toggling completion.
        const statusSpan = document.createElement('span');
        statusSpan.className = 'status-circle';
        const statusData = completedTrails[name];
        if (statusData && statusData.completed) {
          statusSpan.classList.add('completed');
        }
        statusSpan.addEventListener('click', e => {
          e.stopPropagation();
          toggleCompletion(name);
          trackEvent('trails_completion_toggle', {
            trail: name,
            completed: !(completedTrails[name] && completedTrails[name].completed)
          });
        });

        // Date display.
        const dateContainer = document.createElement('span');
        dateContainer.className = 'date-container';
        if (statusData && statusData.completed) {
          if (statusData.date) {
            dateContainer.textContent = statusData.date;
          } else {
            dateContainer.innerHTML   = '<span class="date-icon">Date</span>';
          }
        } else {
          dateContainer.style.display = 'none';
        }

        // Date input for editing.
        const dateInput  = document.createElement('input');
        dateInput.type   = 'date';
        dateInput.className = 'date-input';
        dateInput.value  = (statusData && statusData.date) ? statusData.date : '';

        // Show the date picker when clicking the display.
        dateContainer.addEventListener('click', e => {
          e.stopPropagation();
          dateContainer.style.display = 'none';
          dateInput.style.display     = 'inline-flex';
          dateInput.focus();
          trackEvent('trails_date_edit_open', { trail: name });
        });

        // Prevent date input click from selecting the trail.
        dateInput.addEventListener('click', e => e.stopPropagation());

        // Update the stored date when it changes.
        dateInput.addEventListener('change', () => {
          const newDate = dateInput.value;
          if (!completedTrails[name]) {
            completedTrails[name] = { completed: true, date: newDate };
          } else {
            completedTrails[name].completed = true;
            completedTrails[name].date      = newDate;
          }
          saveCompletion();
          if (newDate) {
            dateContainer.textContent = newDate;
          } else {
            dateContainer.innerHTML   = '<span class="date-icon">Date</span>';
          }
          trackEvent('trails_date_updated', { trail: name, date: newDate });
        });

        // Hide the picker and restore the display on blur.
        dateInput.addEventListener('blur', () => {
          dateInput.style.display = 'none';
          const data = completedTrails[name];
          if (data && data.completed) {
            if (data.date) {
              dateContainer.textContent = data.date;
            } else {
              dateContainer.innerHTML   = '<span class="date-icon">Date</span>';
            }
            dateContainer.style.display = 'flex';
          } else {
            dateContainer.style.display = 'none';
          }
        });

        return { statusSpan, dateContainer, dateInput };
      }

      /**
       * Update `letterPositions` for A‑Z navigation.  For each letter, record
       * the index of the first trail starting with that letter in the current list.
       */
      function updateLetterPositions(names) {
        letterPositions = {};
        letters.forEach(l => { letterPositions[l] = null; });
        names.forEach((name, idx) => {
          const initial = name.charAt(0).toUpperCase();
          if (letterPositions[initial] === null) {
            letterPositions[initial] = idx;
          }
        });
      }

      // ------------------------
      // Initialization logic
      // ------------------------
      // Load completion state, fetch GeoJSON, then populate map and list.
      console.log('Initializing White Mountain Trails app...');
      loadCompletion();
      renderTrailInfo(null);
      console.log('Loading OSM trail data...');
      const geoData = await loadOsmTrailData();
      console.log('GeoData loaded:', geoData ? 'success' : 'failed');
      if (geoData) {
        console.log('Adding trails to map...');
        addTrailsToMap(geoData);
        console.log('Populating suggestions...');
        populateSuggestions();
        console.log('Rendering trail list...');
        renderTrailList();
        console.log('Trail names loaded:', trailNames.length);
        trackEvent('trails_app_ready', { trailCount: trailNames.length });
        const trailQuery = initialTrailQuery;
        if (trailQuery) {
          const matched = matchTrailName(trailQuery, trailNames);
          if (!matched) {
            window.location.replace('/not-found.html');
            return;
          }
          if (searchInput) {
            searchInput.value = matched;
            renderTrailList();
          }
          renderTrailInfo(matched);
          trackEvent('trails_query_select', { trail: matched });
        }
      } else {
        console.error('Failed to load trail data');
      }
      // Attach event listeners for search, sort, hide completed, and clear progress.
      let searchDebounce;
      searchInput.addEventListener('input', () => {
        renderTrailList();
        clearTimeout(searchDebounce);
        searchDebounce = setTimeout(() => {
          trackEvent('trails_search', { query: searchInput.value.trim().toLowerCase() });
        }, 400);
      });
      document.getElementById('sortSelect').addEventListener('change', (event) => {
        renderTrailList();
        trackEvent('trails_sort_change', { sort: event.target.value });
      });
      const hideCompletedCheckbox = document.getElementById('hideCompleted');
      if (hideCompletedCheckbox) {
        hideCompletedCheckbox.addEventListener('change', function() {
          hideCompleted = this.checked;
          renderTrailList();
          trackEvent('trails_hide_completed_toggle', { enabled: hideCompleted });
        });
      }
      const clearProgressBtn = document.getElementById('clearProgress');
      if (clearProgressBtn) {
        clearProgressBtn.addEventListener('click', function() {
          if (confirm(t('trails.confirmClear'))) {
            completedTrails = {};
            saveCompletion();
            applyCompletionStyles();
            renderTrailList();
            trackEvent('trails_clear_progress');
          }
        });
      }

      if (window.NH48_I18N && window.NH48_I18N.onLangChange) {
        window.NH48_I18N.onLangChange(() => {
          baseLayer.setAttribution(t('trails.map.attribution'));
          renderTrailInfo(currentTrailSelection);
          renderTrailList();
          trackEvent('trails_language_change', { language: window.NH48_I18N.getLang() });
        });
      }

      // ------------------------
      // Mobile scroll optimization
      // ------------------------
      // Prevent competing scroll wheels on mobile by managing touch events
      // This ensures smooth scrolling within Wix embeds and prevents body scroll conflicts
      function setupMobileScroll() {
        const isMobile = window.innerWidth <= 768;
        if (!isMobile) return;
        
        const scrollableContainers = [
          document.getElementById('sidebar'),
          document.getElementById('listSection'),
          document.querySelector('.trail-list-container')
        ];
        
        // Remove all touch event listeners that might interfere
        scrollableContainers.forEach(container => {
          if (!container) return;
          
          // Simple approach: just prevent scroll propagation at boundaries
          container.addEventListener('touchstart', function(e) {
            const scrollTop = this.scrollTop;
            const scrollHeight = this.scrollHeight;
            const height = this.clientHeight;
            const clientY = e.touches[0].clientY;
            
            // Store the initial touch position on the container
            this.setAttribute('data-start-y', clientY);
            this.setAttribute('data-start-scroll', scrollTop);
          }, { passive: true });
          
          container.addEventListener('touchmove', function(e) {
            const startY = parseFloat(this.getAttribute('data-start-y') || 0);
            const startScroll = parseFloat(this.getAttribute('data-start-scroll') || 0);
            const currentY = e.touches[0].clientY;
            const deltaY = currentY - startY;
            
            const scrollTop = this.scrollTop;
            const scrollHeight = this.scrollHeight;
            const height = this.clientHeight;
            const isAtTop = scrollTop === 0;
            const isAtBottom = scrollTop + height >= scrollHeight - 1;
            
            // Prevent overscroll: if at boundary and trying to scroll further, stop it
            if ((isAtTop && deltaY > 0) || (isAtBottom && deltaY < 0)) {
              e.preventDefault();
              return false;
            }
          }, { passive: false });
        });
        
        // For the map, allow all touch events without interference
        const mapElement = document.getElementById('map');
        if (mapElement) {
          map.touchZoom.enable();
          map.dragging.enable();
          map.tap && map.tap.enable();
          map.doubleClickZoom.disable();
        }
      }
      
      // Initialize mobile scroll handling
      setupMobileScroll();
      
      // Re-initialize on window resize
      let resizeTimer;
      window.addEventListener('resize', function() {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(setupMobileScroll, 250);
  });

})();
</script>
<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-app.js";
    import { getAnalytics, logEvent } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-analytics.js";

    const firebaseConfig = {
      apiKey: "AIzaSyCUShYXwxGVEDNzMeIwSFPmDaYeXSqRK4A",
      authDomain: "nh48-info.firebaseapp.com",
      projectId: "nh48-info",
      storageBucket: "nh48-info.firebasestorage.app",
      messagingSenderId: "732743288228",
      appId: "1:732743288228:web:d82d62cae0c3999ee5ad31",
      measurementId: "G-Q9F2W8YB7D"
    };

    const app = initializeApp(firebaseConfig);
    const analytics = getAnalytics(app);

    window.NH48_INFO_ANALYTICS = {
      analytics,
      logEvent
    };

    logEvent(analytics, "page_loaded", {
      site: "nh48-info",
      page: location.pathname
    });
  </script>
</body>
</html>
