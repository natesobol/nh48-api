<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WMNF Trails API Map Tool â€“ Redlining tracker for White Mountain trails</title>
  <meta name="description" content="Interactive map for the White Mountain National Forest redlining project. Mark trails as completed, add dates and export your progress. Not for navigation; data may contain inaccuracies.">
  <meta name="keywords" content="WMNF trails, redlining map, White Mountain trail GPX, trail completion tracker, hiking progress app, New Hampshire trails, GPX map, trail data">
  <meta name="robots" content="index,follow">
  <link rel="canonical" href="https://nh48.info/trails">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://nh48.info/trails">
  <meta property="og:title" content="WMNF Trails API Map Tool â€“ Redlining tracker for White Mountain trails">
  <meta property="og:description" content="Interactive map for the White Mountain National Forest redlining project. Mark trails as completed, add dates and export your progress. Not for navigation; data may contain inaccuracies.">
  <meta property="og:image" content="https://cdn.jsdelivr.net/gh/natesobol/nh48-api@main/nh48-preview.png">
  
  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:url" content="https://nh48.info/trails">
  <meta name="twitter:title" content="WMNF Trails API Map Tool â€“ Redlining tracker for White Mountain trails">
  <meta name="twitter:description" content="Interactive map for the White Mountain National Forest redlining project. Mark trails as completed, add dates and export your progress. Not for navigation; data may contain inaccuracies.">
  <meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/natesobol/nh48-api@main/nh48-preview.png">
  
  <link rel="icon" type="image/png" href="../WMNF_Trails_API_logo.png">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="">
  <link rel="stylesheet" href="../css/trails_app.css">
  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "SoftwareApplication",
      "name": "WMNF Trails API Map Tool",
      "applicationCategory": "SportsApplication",
      "operatingSystem": "Web",
      "description": "Interactive map for the White Mountain National Forest redlining project. Mark trails as completed, add dates and export your progress. Not for navigation; data may contain inaccuracies.",
      "url": "https://nh48.info/pages/trails_app.html",
      "creator": {
        "@type": "Person",
        "name": "Nathan Sobol",
        "url": "https://www.nh48pics.com/"
      },
      "keywords": ["WMNF trails", "redlining map", "White Mountain trail GPX", "trail completion tracker", "hiking progress app", "New Hampshire trails", "GPX map", "trail data"],
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      }
    }
  </script>
</head>

<body>
  <div id="nav-placeholder"></div>
  <script>
    // Load shared navigation
    fetch('nav.html')
      .then(response => response.text())
      .then(html => {
        document.getElementById('nav-placeholder').innerHTML = html;
      })
      .catch(err => console.error('Failed to load navigation:', err));
  </script>
  <div id="app">
    <!-- Top section containing the sidebar and the map -->
    <div id="topSection">
      <aside id="sidebar">
        <!-- Sidebar Header -->
        <div class="sidebar-header">
        <h1><img src="../WMNF_Trails_API_logo.png" alt="WMNF" style="height: 32px; vertical-align: middle; margin-right: 0.5rem;"> WMNF Trails API Map Tool</h1>
          <p>White Mountain National Forest â€” compiled by Nate Sobol. Use this as a quick trail finder and completion tracker.</p>
        </div>
        <!-- Information panel with collapsible instructions and import/export controls -->
        <div class="info-panel">
          <details open>
            <summary>About this list</summary>
            <p>NH Tracing, Redlining, and White Mountain Trails all refer to the same collection of trails described in the guidebook. No matter which name you use, youâ€™re working towards the same goal of experiencing these paths.</p>
          </details>
          <details open>
            <summary>Disclaimer</summary>
            <p>This site is <strong>not intended for planning or navigation</strong>. Trail data may contain minor errors or inaccuracies, and this collection is not the official list (though it includes most of the known trails). Please refer to official sources and use good judgement in the backcountry.</p>
          </details>
          <details open>
            <summary>How to use</summary>
            <p>Use the green circles to mark a trail as completed. After marking a trail, tap the calendar icon to add a date of completion â€” the date will replace the icon once selected and can be edited by tapping again. Your progress is stored locally in your browser. You can export or import your progress using the buttons below.</p>
          </details>
          <!-- Settings collapsible section for additional options -->
          <details>
            <summary>Settings</summary>
            <div style="margin-top: 0.5rem; display: flex; flex-direction: column; gap: 0.5rem; font-size: 0.85rem;">
              <label style="display: flex; align-items: center; gap: 0.5rem;">
                <input type="checkbox" id="hideCompleted" style="accent-color: var(--button-green);"> Hide completed trails
              </label>
              <button id="clearProgress" type="button" style="padding: 0.4rem 0.75rem; background-color: var(--button-green); color: white; border: none; border-radius: 5px; font-size: 0.8rem; cursor: pointer; width: fit-content;">Clear all progress</button>
            </div>
          </details>
          <div class="export-import">
            <button id="exportBtn" type="button">Export CSV</button>
            <label for="importFile" class="import-label">Import
              <input type="file" id="importFile" accept=".csv,.xlsx,.json" />
            </label>
          </div>
      <!-- Link to view the GitHub API repository -->
      <div class="api-link-container" style="margin-top: 0.75rem;">
        <a href="https://github.com/natesobol/WMNF-Trails-API/tree/main" target="_blank" rel="noopener noreferrer" class="view-api-link">
          <!-- GitHub logo SVG -->
          <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" style="fill: currentColor; margin-right: 0.4rem;">
            <path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82a7.62 7.62 0 012-.27c.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
          </svg>
          View API
        </a>
      </div>
        </div>
      </aside>
      <!-- Map section with map and peak info panels -->
      <div id="mapSection">
        <div id="mapContainer">
          <div id="map"></div>
        </div>
        <div id="peakInfoPanel">
          <h2 id="trailInfoTitle">Trail Information</h2>
          <p id="trailInfoDescription">Click on a trail to view its details and properties from OpenStreetMap.</p>
          <div id="trailPropertiesGrid" class="trail-properties-grid" style="display: none;"></div>
          <div id="trailPromoSection">
            <h3>Track Your NH48 Progress</h3>
            <p>Log your peak completions, track your hiking stats, and join the community of White Mountain adventurers.</p>
            <a href="https://nh48.app" target="_blank" rel="noopener" class="promo-link">Visit Peak Bagger â†’</a>
            <div class="user-details">
              <strong>Main User:</strong>
              <span>Nate Sobol</span>
            </div>
          </div>
        </div>
      </div>
    </div>
    <!-- List section below the map, spanning full width -->
    <div id="listSection">
      <!-- Search and sort controls -->
      <div class="controls">
        <!-- Search input with autocomplete support using datalist -->
        <input type="text" id="searchInput" placeholder="Search trailsâ€¦" list="trailSuggestions" autocomplete="off" />
        <!-- Datalist providing autocomplete suggestions for trail names sans suffixes -->
        <datalist id="trailSuggestions"></datalist>
        <select id="sortSelect">
          <option value="az">Sort A â†’ Z</option>
          <option value="za">Sort Z â†’ A</option>
        </select>
      </div>
      <!-- Aâ€‘Z letter navigation bar with label -->
      <div class="letter-nav-wrapper">
        <span class="jump-label">Jump To:</span>
        <div id="letterNav" class="letter-nav"></div>
      </div>
      <!-- Header row for the trail list -->
      <div class="list-header">
        <span class="header-name">Trail Name</span>
        <span class="header-completed">Completed</span>
      </div>
      <!-- Trail list container -->
      <div class="trail-list-container">
        <ul id="trailList"></ul>
        <div id="loadingState" class="loading-state" style="display: none;">
          <p>Loading trails...</p>
        </div>
      </div>
    </div>
  </div>

  <!-- Include Leaflet JS library.  Leaflet provides map rendering and helper
       functions for working with GeoJSON.  The integrity hash ensures the
       downloaded script hasn't been tampered with. -->
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    crossorigin=""
  ></script>
  <!-- Include SheetJS library for XLSX import/export -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script>
    (async function() {
      // Set an improved center and zoom over the White Mountain National Forest.
      // These coordinates zoom closer to the core of the WMNF while showing most trails.
      const defaultCenter = [44.15, -71.5];
      const defaultZoom = 9;

      // Create the map.  The `L.map` function takes the id of the map container.
      const map = L.map('map').setView(defaultCenter, defaultZoom);

      // Use a detailed topographic map tile layer (OpenTopoMap) which includes contour lines
      // and hiking paths.  Attribution is required to credit data sources.
      L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
        attribution:
          'Map data: &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, SRTM | Map style: &copy; <a href="https://opentopomap.org">OpenTopoMap</a> (CC-BY-SA)',
        maxZoom: 17
      }).addTo(map);

      // Containers for the trail data.  `trailLayers` maps trail names to their
      // Leaflet layer and feature information.  `trailNames` holds just the names
      // for easy sorting and filtering.  `completedTrails` tracks userâ€‘marked
      // completion status for each trail, persisted in localStorage.
      const trailLayers = {};
      const trailNames = [];
      const completionKey = 'wmnfTrailCompletion';
      let completedTrails = {};
      let trailProperties = []; // Store trail properties from JSON
      // Aâ€‘Z navigation helpers
      const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
      let letterPositions = {};
      // Create the letter navigation bar elements once
      const letterNavContainer = document.getElementById('letterNav');
      letters.forEach(letter => {
        const span = document.createElement('span');
        span.textContent = letter;
        span.setAttribute('data-letter', letter);
        span.addEventListener('click', function(e) {
          const targetLetter = this.getAttribute('data-letter');
          const idx = letterPositions[targetLetter];
          if (idx != null && idx !== undefined && idx >= 0) {
            const li = document.querySelectorAll('#trailList li')[idx];
            if (li) {
              li.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
          }
        });
        letterNavContainer.appendChild(span);
      });
      // Retrieve success (completed) color from CSS variables.  Fallback to
      // a hardcoded green if not found.
      const successColor = getComputedStyle(document.documentElement).getPropertyValue('--success-green').trim() || '#51cf66';

      // Track whether completed trails should be hidden in the list. This is toggled
      // via the settings panel checkbox. Defaults to false (show all).
      let hideCompleted = false;

      /**
       * Load completion data from localStorage.  If no data exists, an empty
       * object is used.  Parsing errors are silently ignored.
       */
      function loadCompletion() {
        try {
          const stored = localStorage.getItem(completionKey);
          const parsed = stored ? JSON.parse(stored) : {};
          // If the old format used a boolean for completed trails, convert to object
          Object.keys(parsed).forEach(key => {
            const val = parsed[key];
            if (typeof val === 'boolean') {
              parsed[key] = { completed: val, date: '' };
            } else if (val && typeof val === 'object') {
              // Ensure both properties exist
              parsed[key] = {
                completed: !!val.completed,
                date: val.date || ''
              };
            } else {
              // Unknown format, treat as incomplete
              parsed[key] = { completed: false, date: '' };
            }
          });
          completedTrails = parsed;
        } catch (e) {
          completedTrails = {};
        }
      }

      /**
       * Persist completion data back to localStorage.  Always stringify the
       * object to ensure consistent storage.
       */
      function saveCompletion() {
        try {
          localStorage.setItem(completionKey, JSON.stringify(completedTrails));
        } catch (e) {
          console.warn('Failed to save completion state:', e);
        }
      }

      /**
       * Toggle completion status for a given trail.  After toggling, persist
       * the change and reapply styles to both the map and list.
       *
       * @param {string} name The trail name
       */
      function toggleCompletion(name) {
        // Ensure entry exists
        if (!completedTrails[name]) {
          completedTrails[name] = { completed: false, date: '' };
        }
        const currentStatus = completedTrails[name].completed;
        completedTrails[name].completed = !currentStatus;
        // When marking incomplete, clear the date
        if (!completedTrails[name].completed) {
          completedTrails[name].date = '';
        }
        saveCompletion();
        applyCompletionStyles();
        renderTrailList();
      }

      /**
       * Apply completion styles to all trail layers.  Completed trails are
       * colored green, while incomplete trails retain the default blue.
       */
      function applyCompletionStyles() {
        Object.entries(trailLayers).forEach(([name, info]) => {
          const status = completedTrails[name];
          const completed = status && status.completed;
          const color = completed ? successColor : '#3388ff';
          const weight = completed ? 5 : 3;
          info.layer.setStyle({ color: color, weight: weight });
        });
      }

      /**
       * Apply a visibility filter based on the current search results.  This
       * function hides trails not present in the filtered list by setting
       * their opacity to zero while preserving their original colors and
       * weights.  Visible trails remain at full opacity.
       *
       * @param {string[]} filteredNames The list of trail names that should be visible
       */
      function applyFilterStyles(filteredNames) {
        Object.entries(trailLayers).forEach(([name, info]) => {
          const status = completedTrails[name];
          const completed = status && status.completed;
          const isVisible = filteredNames.includes(name);
          // Determine color and weight as in applyCompletionStyles
          const color = completed ? successColor : '#3388ff';
          const weight = completed ? 5 : 3;
          const opacity = isVisible ? 1 : 0;
          info.layer.setStyle({ color: color, weight: weight, opacity: opacity });
        });
      }

      /**
       * Export progress as a CSV file.  Each row contains the trail name and
       * whether it is completed (true/false).
       */
      function exportCSV() {
        let csv = 'Trail,Completed,Date\n';
        trailNames.forEach(name => {
          const status = completedTrails[name] || { completed: false, date: '' };
          const completed = status.completed ? 'true' : 'false';
          const date = status.date || '';
          // Escape double quotes in names
          const safeName = name.replace(/"/g, '""');
          csv += `"${safeName}",${completed},${date}\n`;
        });
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'trail-progress.csv';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      }

      /**
       * Parse CSV text and update completion data accordingly.  Assumes
       * first row contains headers and subsequent rows contain name and
       * completed flag.  Ignores unknown trails.
       *
       * @param {string} text Raw CSV content
       */
      function parseCSV(text) {
        const lines = text.split(/\r?\n/).filter(l => l.trim());
        const imported = {};
        lines.slice(1).forEach(line => {
          const parts = line.split(',');
          if (parts.length >= 2) {
            const name = parts[0].replace(/^"|"$/g, '').replace(/""/g, '"').trim();
            const val = (parts[1] || '').trim().toLowerCase();
            const date = (parts[2] || '').trim();
            imported[name] = {
              completed: val === 'true' || val === '1' || val === 'yes',
              date: date
            };
          }
        });
        completedTrails = imported;
        saveCompletion();
        applyCompletionStyles();
        renderTrailList();
      }

      /**
       * Parse rows from an XLSX worksheet and update completion data.
       * Accepts an array of arrays where the first row is a header.
       *
       * @param {Array<Array<any>>} rows Parsed rows from sheetjs
       */
      function parseRows(rows) {
        const imported = {};
        rows.slice(1).forEach(row => {
          const name = row[0];
          const val = String(row[1] || '').toLowerCase();
          const date = row.length >= 3 ? String(row[2] || '').trim() : '';
          imported[name] = {
            completed: val === 'true' || val === '1' || val === 'yes',
            date: date
          };
        });
        completedTrails = imported;
        saveCompletion();
        applyCompletionStyles();
        renderTrailList();
      }

      // Hook up export button click
      const exportBtn = document.getElementById('exportBtn');
      if (exportBtn) {
        exportBtn.addEventListener('click', exportCSV);
      } else {
        console.warn('Export button not found');
      }
      
      // Hook up import file change
      const importFile = document.getElementById('importFile');
      if (importFile) {
        importFile.addEventListener('change', function(e) {
          const file = e.target.files[0];
          if (!file) return;
          const ext = file.name.split('.').pop().toLowerCase();
          if (ext === 'csv') {
            const reader = new FileReader();
            reader.onload = function(ev) {
              parseCSV(ev.target.result);
            };
            reader.readAsText(file);
          } else if (ext === 'xlsx' || ext === 'xls') {
            const reader = new FileReader();
            reader.onload = function(ev) {
              const data = new Uint8Array(ev.target.result);
              const workbook = XLSX.read(data, { type: 'array' });
              const sheet = workbook.Sheets[workbook.SheetNames[0]];
              const rows = XLSX.utils.sheet_to_json(sheet, { header: 1 });
              parseRows(rows);
            };
            reader.readAsArrayBuffer(file);
          }
          // reset input to allow re-import of same file
          this.value = '';
        });
      } else {
        console.warn('Import file input not found');
      }

      /**
       * Load trail properties from trail_properties.json file.
       * This file contains OpenStreetMap data for each trail.
       * Fails gracefully if file doesn't exist.
       */
      async function loadTrailProperties() {
        const urls = [
          '../data/trail_properties.json',
          'https://cdn.jsdelivr.net/gh/natesobol/nh48-api@main/data/trail_properties.json',
          'https://raw.githubusercontent.com/natesobol/nh48-api/main/data/trail_properties.json'
        ];

        for (const url of urls) {
          try {
            console.log(`Attempting to fetch trail properties from: ${url}`);
            const response = await fetch(url, {
              method: 'GET',
              headers: { 'Accept': 'application/json' },
              cache: 'no-cache'
            });
            
            if (response.ok) {
              const data = await response.json();
              if (Array.isArray(data)) {
                trailProperties = data;
                console.log(`Successfully loaded ${trailProperties.length} trail properties from ${url}`);
                return true;
              }
            }
          } catch (err) {
            console.warn(`Failed to load trail properties from ${url}:`, err.message);
            continue;
          }
        }
        
        console.warn('Trail properties file not available. Trail info panel will show limited data.');
        return false;
      }

      /**
       * Find trail properties by trail name.
       * Normalizes names for matching.
       */
      function findTrailProperties(trailName) {
        if (!trailName || !trailProperties.length) return null;
        const normalized = trailName.trim().replace(/\s+/g, ' ');
        return trailProperties.find(t => 
          t.name && t.name.trim().replace(/\s+/g, ' ') === normalized
        );
      }

      /**
       * Display trail properties in the peakInfoPanel.
       * Shows all available API fields with labels.
       */
      function displayTrailInfo(trailName, feature) {
        const titleEl = document.getElementById('trailInfoTitle');
        const descEl = document.getElementById('trailInfoDescription');
        const gridEl = document.getElementById('trailPropertiesGrid');
        const promoEl = document.getElementById('trailPromoSection');
        
        if (!titleEl || !descEl || !gridEl) {
          console.warn('Trail info panel elements not found');
          return;
        }
        
        titleEl.textContent = trailName || 'Trail Information';
        
        const props = findTrailProperties(trailName);
        
        if (!props || !props.properties || Object.keys(props.properties).length === 0) {
          descEl.textContent = 'No additional trail properties available yet. Properties will be populated from OpenStreetMap data.';
          gridEl.style.display = 'none';
          if (promoEl) promoEl.style.display = 'block';
          return;
        }
        
        descEl.textContent = 'Trail properties from OpenStreetMap:';
        gridEl.innerHTML = '';
        gridEl.style.display = 'grid';
        if (promoEl) promoEl.style.display = 'none';
        
        // Sort properties alphabetically and display them
        const entries = Object.entries(props.properties)
          .filter(([key, value]) => value !== null && value !== undefined && value !== '')
          .sort(([a], [b]) => a.localeCompare(b));
        
        if (entries.length === 0) {
          descEl.textContent = 'No additional trail properties available yet.';
          gridEl.style.display = 'none';
          if (promoEl) promoEl.style.display = 'block';
          return;
        }
        
        entries.forEach(([key, value]) => {
          // Create label (format key nicely)
          const label = document.createElement('div');
          label.className = 'property-label';
          label.textContent = key.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
          
          // Create value
          const valueEl = document.createElement('div');
          valueEl.className = 'property-value';
          
          // Handle array values
          if (Array.isArray(value)) {
            valueEl.textContent = value.join(', ');
          } else if (typeof value === 'object') {
            valueEl.textContent = JSON.stringify(value);
          } else {
            valueEl.textContent = String(value);
          }
          
          gridEl.appendChild(label);
          gridEl.appendChild(valueEl);
        });
      }

      /**
       * Clear trail info panel back to default state.
       */
      function clearTrailInfo() {
        const titleEl = document.getElementById('trailInfoTitle');
        const descEl = document.getElementById('trailInfoDescription');
        const gridEl = document.getElementById('trailPropertiesGrid');
        const promoEl = document.getElementById('trailPromoSection');
        
        if (titleEl) titleEl.textContent = 'Trail Information';
        if (descEl) descEl.textContent = 'Click on a trail to view its details and properties from OpenStreetMap.';
        if (gridEl) {
          gridEl.innerHTML = '';
          gridEl.style.display = 'none';
        }
        if (promoEl) promoEl.style.display = 'block';
      }

      /**
       * Fetch the GeoJSON file from the server.  For standalone hosting (no iframe),
       * try the local bundled file first, then fall back to GitHub mirrors.
       */
      async function loadGeoJSON() {
        const urls = [
          '../data/merged_trails.geojson',
          'https://cdn.jsdelivr.net/gh/natesobol/nh48-api@main/data/merged_trails.geojson',
          'https://raw.githubusercontent.com/natesobol/nh48-api/main/data/merged_trails.geojson'
        ];

        for (const url of urls) {
          try {
            console.log(`Attempting to fetch GeoJSON from: ${url}`);
            const response = await fetch(url, {
              method: 'GET',
              headers: {
                'Accept': 'application/json, application/geo+json',
              },
              cache: 'no-cache'
            });
            
            if (response.ok) {
              const data = await response.json();
              console.log(`Successfully loaded GeoJSON from ${url}`, `Features: ${data?.features?.length || 0}`);
              return data;
            } else {
              console.warn(`Failed to load from ${url}: HTTP ${response.status} ${response.statusText}`);
            }
          } catch (err) {
            console.warn(`Failed to load from ${url}:`, err.message);
            continue;
          }
        }

        // If all URLs fail, show helpful error message
        console.error('Failed to load GeoJSON from all sources');
        alert('Unable to load trail data. Please ensure you have internet connectivity and try refreshing the page.');
        return null;
      }

      // Helper function to highlight a single trail layer.  Resets all others
      // back to the default style before applying a highlighted style to the
      // selected trail.
      function highlightLayer(targetLayer) {
        // Reset all trails to their completion or default color
        applyCompletionStyles();
        // Highlight the selected trail in red
        targetLayer.setStyle({ color: '#e74c3c', weight: 5 });
      }

      /**
       * Populate the datalist for autocomplete suggestions.  Creates a set of
       * simplified trail names with common suffix words removed (e.g., "Trail",
       * "Loop", "Cutoff", etc.) and inserts them as options into the datalist.
       */
      function populateSuggestions() {
        const datalist = document.getElementById('trailSuggestions');
        if (!datalist) {
          console.warn('Trail suggestions datalist element not found');
          return;
        }
        
        const suffixes = ['trail','loop','cutoff','road','path','connector','summit','route'];
        const suggestions = new Set();
        trailNames.forEach(name => {
          // Remove trailing suffix words
          let parts = name.split(' ');
          while (parts.length > 1 && suffixes.includes(parts[parts.length - 1].toLowerCase())) {
            parts.pop();
          }
          const suggestion = parts.join(' ');
          suggestions.add(suggestion);
        });
        datalist.innerHTML = '';
        suggestions.forEach(s => {
          const option = document.createElement('option');
          option.value = s;
          datalist.appendChild(option);
        });
      }

      /**
       * Populate the map with GeoJSON features.  Each feature becomes a
       * clickable polyline on the map.  When clicked, the trail is highlighted
       * and the map view zooms to its bounds.  The trail name is used
       * as a key in the `trailLayers` object for quick lookup later.
       *
       * @param {Object} geoData The GeoJSON FeatureCollection to display
       */
      function addTrailsToMap(geoData) {
        if (!geoData || !geoData.features) {
          console.error('Invalid GeoJSON data provided to addTrailsToMap:', geoData);
          alert('Unable to display trails: Invalid data format');
          return;
        }
        
        if (!Array.isArray(geoData.features)) {
          console.error('GeoJSON features is not an array');
          alert('Unable to display trails: Malformed data');
          return;
        }
        
        console.log(`Adding ${geoData.features.length} trails to map...`);
        
        const geoLayer = L.geoJSON(geoData, {
          style: function(feature) {
            // Default line styling.  You can change the color or weight here.
            return { color: '#3388ff', weight: 3 };
          },
          onEachFeature: function(feature, layer) {
            const name = feature?.properties?.name || 'Unnamed trail';
            // Store reference to this layer and its original feature
            trailLayers[name] = { layer: layer, feature: feature };
            trailNames.push(name);
            // Bind a popup showing the trail name.  When the line is clicked
            // the popup appears.  You can add more content here (length, notes, etc.).
            layer.bindPopup(`<strong>${name}</strong>`);
            // Handle click on the map line.  Highlight and zoom.
            layer.on('click', function() {
              highlightLayer(layer);
              map.fitBounds(layer.getBounds(), { maxZoom: 14, animate: true });
              layer.openPopup();
              // Display trail properties in info panel
              displayTrailInfo(name, feature?.properties || {});
            });
          }
        }).addTo(map);
        // After adding all features, apply completion styles to set initial colors
        applyCompletionStyles();
        console.log(`Successfully added ${trailNames.length} trails to map and list`);
      }

      /**
       * Render the list of trails in the sidebar.  The list is filtered by
       * the search input and sorted according to the dropdown.  Each item
       * becomes clickable; clicking will highlight and pan to the trail.
       */
      function renderTrailList() {
        const listElement  = document.getElementById('trailList');
        if (!listElement) {
          console.error('trailList element not found');
          return;
        }
        
        const container    = listElement.parentElement;
        if (!container) {
          console.error('trailList container not found');
          return;
        }
        
        const searchInput = document.getElementById('searchInput');
        const sortSelect = document.getElementById('sortSelect');
        
        const searchQuery  = searchInput ? searchInput.value.trim().toLowerCase() : '';
        const sortOrder    = sortSelect ? sortSelect.value : 'az';

        // 1. Filter names by search query and hideâ€‘completed flag.
        let names = trailNames.filter(name => filterBySearch(name, searchQuery));
        if (hideCompleted) {
          names = names.filter(name => !isTrailCompleted(name));
        }

        // 2. Sort names alphabetically (ascending by default, descending if 'za').
        names.sort((a, b) => (sortOrder === 'za' ? b.localeCompare(a) : a.localeCompare(b)));

        // 3. Clear any previous emptyâ€‘state messages and existing list items.
        container.querySelectorAll('.empty-state').forEach(el => el.remove());
        listElement.innerHTML = '';

        // 4. If no names match, show an appropriate empty message and return early.
        if (names.length === 0) {
          showEmptyState(container, searchQuery);
          return;
        }

        // 5. Populate list items for each trail.
        names.forEach(name => {
          const li = createTrailListItem(name);
          listElement.appendChild(li);
        });

        // 6. Update Aâ€‘Z navigation positions and apply map filter styles.
        updateLetterPositions(names);
        applyFilterStyles(names);
      }

      /**
       * Return true if a trail name matches the search query.  It checks both the
       * full name and a simplified version with common suffixes removed.
       */
      function filterBySearch(name, query) {
        if (!query) return true;
        const nameLower = name.toLowerCase();
        const simple    = nameLower
          .replace(/\b(trail|loop|cutoff|road|path|connector|summit|route)\b/g, '')
          .replace(/\s+/g, ' ')
          .trim();
        return nameLower.includes(query) || simple.includes(query);
      }

      /** Returns true if a trail is marked as completed in the global state. */
      function isTrailCompleted(name) {
        const status = completedTrails[name];
        return status && status.completed;
      }

      /** Show a message when the filtered list is empty. */
      function showEmptyState(container, query) {
        const emptyMsg    = document.createElement('div');
        emptyMsg.className = 'empty-state';
        emptyMsg.textContent = query
          ? 'No trails found.\u00A0Try a different search.'
          : 'No trails available.';
        container.appendChild(emptyMsg);
      }

      /**
       * Create a fully wired list item for a given trail.  It includes the name,
       * date display/input, status indicator, and optional virtual hike button.
       */
      function createTrailListItem(name) {
        const li       = document.createElement('li');
        const nameSpan = document.createElement('span');
        nameSpan.className  = 'trail-name';
        nameSpan.textContent = name;

        // Build status circle and date controls.
        const { statusSpan, dateContainer, dateInput } = createStatusAndDateControls(name);

        // Optional: button to launch virtual hike (remove if not needed).
        const hikeBtn = document.createElement('button');
        hikeBtn.className = 'hike-btn';
        hikeBtn.title     = 'Virtual Hike';
        hikeBtn.innerHTML = 'ðŸŒ„';
        hikeBtn.addEventListener('click', e => {
          e.stopPropagation();
          const encoded = encodeURIComponent(name);
          window.open(`virtual_hike.html?trail=${encoded}`, '_blank');
        });

        // When clicking the list item, highlight the trail on the map AND show trail details.
        li.addEventListener('click', () => {
          const info = trailLayers[name];
          if (info) {
            highlightLayer(info.layer);
            map.fitBounds(info.layer.getBounds(), { maxZoom: 14, animate: true });
            info.layer.openPopup();
            document.querySelectorAll('#trailList li').forEach(el => el.classList.remove('active'));
            li.classList.add('active');
            // Display trail information in the panel
            displayTrailInfo(name, info.feature.properties || {});
          }
        });

        // Assemble the list item.
        li.appendChild(nameSpan);
        li.appendChild(dateContainer);
        li.appendChild(dateInput);
        li.appendChild(hikeBtn);   // comment out if not using virtual hike
        li.appendChild(statusSpan);
        return li;
      }

      /**
       * Create and wire up the status circle and date picker/input for a trail.
       * Returns the status span, date container span, and date input element.
       */
      function createStatusAndDateControls(name) {
        // Status circle for toggling completion.
        const statusSpan = document.createElement('span');
        statusSpan.className = 'status-circle';
        const statusData = completedTrails[name];
        if (statusData && statusData.completed) {
          statusSpan.classList.add('completed');
        }
        statusSpan.addEventListener('click', e => {
          e.stopPropagation();
          toggleCompletion(name);
        });

        // Date display.
        const dateContainer = document.createElement('span');
        dateContainer.className = 'date-container';
        if (statusData && statusData.completed) {
          if (statusData.date) {
            dateContainer.textContent = statusData.date;
          } else {
            dateContainer.innerHTML   = '<span class="date-icon">ðŸ“…</span>';
          }
        } else {
          dateContainer.style.display = 'none';
        }

        // Date input for editing.
        const dateInput  = document.createElement('input');
        dateInput.type   = 'date';
        dateInput.className = 'date-input';
        dateInput.value  = (statusData && statusData.date) ? statusData.date : '';

        // Show the date picker when clicking the display.
        dateContainer.addEventListener('click', e => {
          e.stopPropagation();
          dateContainer.style.display = 'none';
          dateInput.style.display     = 'inline-flex';
          dateInput.focus();
        });

        // Prevent date input click from selecting the trail.
        dateInput.addEventListener('click', e => e.stopPropagation());

        // Update the stored date when it changes.
        dateInput.addEventListener('change', () => {
          const newDate = dateInput.value;
          if (!completedTrails[name]) {
            completedTrails[name] = { completed: true, date: newDate };
          } else {
            completedTrails[name].completed = true;
            completedTrails[name].date      = newDate;
          }
          saveCompletion();
          if (newDate) {
            dateContainer.textContent = newDate;
          } else {
            dateContainer.innerHTML   = '<span class="date-icon">ðŸ“…</span>';
          }
        });

        // Hide the picker and restore the display on blur.
        dateInput.addEventListener('blur', () => {
          dateInput.style.display = 'none';
          const data = completedTrails[name];
          if (data && data.completed) {
            if (data.date) {
              dateContainer.textContent = data.date;
            } else {
              dateContainer.innerHTML   = '<span class="date-icon">ðŸ“…</span>';
            }
            dateContainer.style.display = 'flex';
          } else {
            dateContainer.style.display = 'none';
          }
        });

        return { statusSpan, dateContainer, dateInput };
      }

      /**
       * Update `letterPositions` for Aâ€‘Z navigation.  For each letter, record
       * the index of the first trail starting with that letter in the current list.
       */
      function updateLetterPositions(names) {
        letterPositions = {};
        letters.forEach(l => { letterPositions[l] = null; });
        names.forEach((name, idx) => {
          const initial = name.charAt(0).toUpperCase();
          if (letterPositions[initial] === null) {
            letterPositions[initial] = idx;
          }
        });
      }

      // ------------------------
      // Initialization logic
      // ------------------------
      // Load GeoJSON first to populate map and list, then optionally load trail properties
      console.log('=== Starting WMNF Trails App Initialization ===');
      loadCompletion();
      console.log('Completion data loaded from localStorage');
      
      const geoData = await loadGeoJSON();
      if (geoData) {
        console.log('GeoJSON loaded successfully, adding to map...');
        addTrailsToMap(geoData);
        console.log('Populating search suggestions...');
        populateSuggestions();
        console.log('Rendering trail list...');
        renderTrailList();
        console.log('Map and list initialization complete');
        
        // Load trail properties in background (optional enhancement)
        console.log('Loading trail properties in background...');
        loadTrailProperties().catch(err => console.log('Trail properties not available:', err));
      } else {
        console.error('Failed to load GeoJSON data - trails will not be displayed');
      }
      
      console.log('=== Initialization Complete ===');

      // Attach event listeners for search, sort, hide completed, and clear progress.
      const searchInput = document.getElementById('searchInput');
      if (searchInput) {
        searchInput.addEventListener('input', renderTrailList);
      }
      
      const sortSelect = document.getElementById('sortSelect');
      if (sortSelect) {
        sortSelect.addEventListener('change', renderTrailList);
      }
      
      const hideCompletedCheckbox = document.getElementById('hideCompleted');
      if (hideCompletedCheckbox) {
        hideCompletedCheckbox.addEventListener('change', function() {
          hideCompleted = this.checked;
          renderTrailList();
        });
      }
      
      const clearProgressBtn = document.getElementById('clearProgress');
      if (clearProgressBtn) {
        clearProgressBtn.addEventListener('click', function() {
          if (confirm('Are you sure you want to clear all progress? This cannot be undone.')) {
            completedTrails = {};
            saveCompletion();
            applyCompletionStyles();
            renderTrailList();
          }
        });
      }

      // ------------------------
      // Mobile scroll optimization
      // ------------------------
      // Prevent competing scroll wheels on mobile by managing touch events
      // This ensures smooth scrolling within Wix embeds and prevents body scroll conflicts
      function setupMobileScroll() {
        const isMobile = window.innerWidth <= 768;
        if (!isMobile) return;
        
        const scrollableContainers = [
          document.getElementById('sidebar'),
          document.getElementById('listSection'),
          document.querySelector('.trail-list-container')
        ];
        
        // Remove all touch event listeners that might interfere
        scrollableContainers.forEach(container => {
          if (!container) return;
          
          // Simple approach: just prevent scroll propagation at boundaries
          container.addEventListener('touchstart', function(e) {
            const scrollTop = this.scrollTop;
            const scrollHeight = this.scrollHeight;
            const height = this.clientHeight;
            const clientY = e.touches[0].clientY;
            
            // Store the initial touch position on the container
            this.setAttribute('data-start-y', clientY);
            this.setAttribute('data-start-scroll', scrollTop);
          }, { passive: true });
          
          container.addEventListener('touchmove', function(e) {
            const startY = parseFloat(this.getAttribute('data-start-y') || 0);
            const startScroll = parseFloat(this.getAttribute('data-start-scroll') || 0);
            const currentY = e.touches[0].clientY;
            const deltaY = currentY - startY;
            
            const scrollTop = this.scrollTop;
            const scrollHeight = this.scrollHeight;
            const height = this.clientHeight;
            const isAtTop = scrollTop === 0;
            const isAtBottom = scrollTop + height >= scrollHeight - 1;
            
            // Prevent overscroll: if at boundary and trying to scroll further, stop it
            if ((isAtTop && deltaY > 0) || (isAtBottom && deltaY < 0)) {
              e.preventDefault();
              return false;
            }
          }, { passive: false });
        });
        
        // For the map, allow all touch events without interference
        const mapElement = document.getElementById('map');
        if (mapElement) {
          map.touchZoom.enable();
          map.dragging.enable();
          map.tap && map.tap.enable();
          map.doubleClickZoom.disable();
        }
      }
      
      // Initialize mobile scroll handling
      setupMobileScroll();
      
      // Re-initialize on window resize
      let resizeTimer;
      window.addEventListener('resize', function() {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(setupMobileScroll, 250);
      });

    })();
  </script>
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-app.js";
    import { getAnalytics, logEvent } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-analytics.js";

    const firebaseConfig = {
      apiKey: "AIzaSyCUSHYxwXVGEDNzMeIwSFmDaYeXSqRK4A",
      authDomain: "nh48-info.firebaseapp.com",
      projectId: "nh48-info",
      storageBucket: "nh48-info.firebasestorage.app",
      messagingSenderId: "732743288228",
      appId: "1:732743288228:web:d82d62cae0c3999ee5ad31",
      measurementId: "G-Q9F2W8YB7D"
    };

    const app = initializeApp(firebaseConfig);
    const analytics = getAnalytics(app);

    // Expose globally for app scripts
    window.NH48_INFO_ANALYTICS = {
      analytics,
      logEvent
    };

    // Base page-load event
    logEvent(analytics, "page_loaded", {
      site: "nh48-info",
      page: location.pathname
    });
  </script>
</body>
</html>
