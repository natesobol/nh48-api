<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <!-- Favicons - ICO format preferred for Google compatibility -->
  <link rel="icon" href="/favicons/favicon.ico" sizes="48x48" />
  <link rel="icon" type="image/x-icon" href="/favicons/favicon.ico" />
  <link rel="shortcut icon" href="/favicons/favicon.ico" />
  <link rel="icon" type="image/x-icon" sizes="16x16" href="/favicons/favicon-16x16.ico" />
  <link rel="icon" type="image/x-icon" sizes="32x32" href="/favicons/favicon-32x32.ico" />
  <link rel="icon" type="image/x-icon" sizes="48x48" href="/favicons/favicon-48x48.ico" />
  <link rel="icon" type="image/x-icon" sizes="96x96" href="/favicons/favicon-96x96.ico" />
  <!-- PNG fallbacks for browsers that prefer PNG -->
  <link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32.png" />
  <link rel="icon" type="image/png" sizes="48x48" href="/favicons/favicon-48.png" />
  <link rel="icon" type="image/png" sizes="96x96" href="/favicons/favicon-96.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png" />
  <link rel="manifest" href="/manifest.json" />
  <title>Howker Ridge Map Editor</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
  <script type="module" src="/js/i18n.js"></script>
  <script src="/js/unified-footer.js" defer></script>
  <style>
    :root {
      --bg: #0b0b0f;
      --panel: #12121a;
      --card: #1c1f2a;
      --ink: #f9fafb;
      --muted: #94a3b8;
      --border: #263042;
      --accent: #22c55e;
      --accent-warn: #fbbf24;
      --accent-danger: #ef4444;
    }
    body.light {
      --bg: #f8fafc;
      --panel: #ffffff;
      --card: #f1f5f9;
      --ink: #0f172a;
      --muted: #64748b;
      --border: #e2e8f0;
      --accent: #16a34a;
      --accent-warn: #f59e0b;
      --accent-danger: #dc2626;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--ink);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      min-height: 100vh;
    }
    .wrap {
      max-width: 1200px;
      margin: 0 auto;
      padding: 16px;
    }
    h1 {
      margin: 0 0 8px;
      font-size: clamp(24px, 3vw, 34px);
    }
    p {
      margin: 0 0 16px;
      color: var(--muted);
      line-height: 1.6;
    }
    .toolbar.large {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      padding: 16px;
      border-radius: 12px;
      background: var(--panel);
      border: 1px solid var(--border);
      align-items: center;
      min-height: 100px;
    }
    .tool-group {
      display: flex;
      align-items: center;
      gap: 8px;
      position: relative;
    }
    .tool-btn {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 8px;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      padding: 0;
      position: relative;
    }
    .tool-btn:hover,
    .tool-btn.active {
      border-color: var(--accent);
      background: color-mix(in srgb, var(--accent) 15%, var(--card));
    }
    .tool-btn img {
      width: 24px;
      height: 24px;
    }
    .dropdown-menu {
      display: none;
      position: absolute;
      top: 100%;
      left: 0;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 4px;
      z-index: 1000;
      flex-direction: column;
      gap: 4px;
    }
    .tool.dropdown.open .dropdown-menu {
      display: flex;
    }
    .toolbar.large button {
      border: 1px solid var(--border);
      background: var(--card);
      color: var(--ink);
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.9rem;
    }
    .toolbar.large select {
      border: 1px solid var(--border);
      background: var(--card);
      color: var(--ink);
      padding: 8px 10px;
      border-radius: 8px;
      font-size: 0.9rem;
    }
    .toolbar.large select:focus {
      outline: 2px solid color-mix(in srgb, var(--accent) 60%, transparent);
      outline-offset: 2px;
    }
    .toolbar.large input[type="search"] {
      border: 1px solid var(--border);
      background: var(--card);
      color: var(--ink);
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 0.9rem;
      min-width: 220px;
    }
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }
    .toolbar.large button:hover {
      border-color: var(--accent);
    }
    .toolbar.large button[data-variant="green"] {
      border-color: color-mix(in srgb, var(--accent) 70%, transparent);
    }
    .toolbar.large button[data-variant="yellow"] {
      border-color: color-mix(in srgb, var(--accent-warn) 70%, transparent);
    }
    .toolbar.large button[data-variant="danger"] {
      border-color: color-mix(in srgb, var(--accent-danger) 70%, transparent);
    }
    .toolbar.large .status {
      margin-left: auto;
      font-size: 0.9rem;
      color: var(--muted);
    }
    #actions button {
      min-width: 72px;
      height: 40px;
      font-size: 0.9rem;
      padding: 0 12px;
    }
    .map-wrap {
      margin-top: 16px;
      border-radius: 12px;
      overflow: hidden;
      border: 1px solid var(--border);
      position: relative;
    }
    #map {
      height: 75vh;
      width: 100%;
    }
    .leaflet-control.satellite-control {
      background: rgba(15, 23, 42, 0.92);
      color: #e2e8f0;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 8px 10px;
      display: grid;
      gap: 6px;
      min-width: 180px;
      box-shadow: 0 10px 18px rgba(0, 0, 0, 0.35);
    }
    .satellite-control label {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      font-size: 0.78rem;
    }
    .satellite-control input[type="range"] {
      width: 110px;
      accent-color: var(--accent);
    }
    .satellite-control .satellite-toggle {
      justify-content: flex-start;
      gap: 6px;
    }
    .share-card-overlay {
      position: absolute;
      inset: auto 0 0 0;
      width: 100%;
      padding: 28px;
      color: #fff;
      display: flex;
      align-items: flex-end;
      pointer-events: none;
    }
    .share-card-overlay::before {
      content: '';
      position: absolute;
      inset: auto 0 0 0;
      height: 40%;
      background: linear-gradient(to top, rgba(0, 0, 0, 0.7), transparent);
    }
    .share-card-overlay.portrait::before {
      height: 50%;
    }
    .share-card-overlay .share-card-content {
      position: relative;
      z-index: 1;
      display: grid;
      gap: 8px;
    }
    .share-card-overlay .trail-title {
      font-size: 1.4rem;
      font-weight: 700;
      margin: 0;
    }
    .share-card-overlay .trail-subtitle {
      color: #d1e5ff;
      font-size: 0.9rem;
      margin: 0;
    }
    .share-card-overlay .trail-stats {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .share-card-overlay.portrait .trail-stats {
      flex-direction: column;
      align-items: flex-start;
    }
    .share-card-overlay .trail-stats span {
      display: inline-block;
      background: rgba(0, 0, 0, 0.45);
      border-radius: 999px;
      padding: 4px 12px;
      font-size: 0.8rem;
    }
    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
      z-index: 9999;
    }
    .modal-backdrop[hidden] {
      display: none;
    }
    .modal-card {
      width: min(560px, 100%);
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 14px;
      box-shadow: 0 20px 70px rgba(0, 0, 0, 0.5);
      overflow: hidden;
    }
    .modal-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 14px;
      border-bottom: 1px solid var(--border);
    }
    .modal-head h2 {
      margin: 0;
      font-size: 18px;
    }
    .xbtn {
      background: transparent;
      color: var(--ink);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 6px 10px;
      cursor: pointer;
    }
    .modal-body {
      padding: 14px;
      display: grid;
      gap: 10px;
    }
    .step {
      display: flex;
      gap: 10px;
      align-items: flex-start;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: color-mix(in srgb, var(--card) 70%, transparent);
    }
    .step .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-top: 6px;
      background: #64748b;
    }
    .step.ok .dot {
      background: var(--accent);
    }
    .step.fail .dot {
      background: var(--accent-danger);
    }
    .step .msg {
      color: var(--muted);
      font-size: 13px;
      margin-top: 3px;
      line-height: 1.35;
    }
    .result {
      margin-top: 4px;
      padding: 10px;
      border-radius: 12px;
      border: 1px dashed color-mix(in srgb, var(--accent) 55%, var(--border));
      background: color-mix(in srgb, var(--panel) 70%, transparent);
    }
    .result a {
      color: var(--ink);
      text-decoration: none;
      word-break: break-all;
    }
    .result a:hover {
      color: var(--accent);
      text-decoration: underline;
    }
    .modal-form {
      display: grid;
      gap: 16px;
    }
    .modal-form fieldset {
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 12px;
      display: grid;
      gap: 8px;
    }
    .modal-form legend {
      padding: 0 6px;
      font-weight: 600;
    }
    .modal-form label {
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--ink);
    }
    .modal-form select {
      width: 100%;
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: var(--card);
      color: var(--ink);
    }
    .modal-note {
      margin: 0;
      color: var(--muted);
      font-size: 0.85rem;
      line-height: 1.4;
    }
    .modal-actions {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }
    .modal-actions button {
      border: 1px solid var(--border);
      background: var(--card);
      color: var(--ink);
      padding: 8px 14px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.9rem;
    }
    .modal-actions button[data-variant="green"] {
      border-color: color-mix(in srgb, var(--accent) 70%, transparent);
    }
    .legend {
      display: grid;
      gap: 8px;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      margin-top: 16px;
    }
    .legend-item {
      padding: 12px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: var(--panel);
    }
    .legend-item strong {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    .legend-swatch {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      display: inline-block;
    }
    .legend-swatch.green { background: #15803d; }
    .legend-swatch.yellow { background: #b45309; }
    .finish-segment-btn {
      position: absolute;
      z-index: 1000;
      background: #fff;
      color: #333;
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 4px 8px;
      font-size: 12px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.25);
      cursor: pointer;
      display: none;
    }
    .poi-form-modal[hidden] {
      display: none;
    }
    .poi-form-modal {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }
    .poi-form-backdrop {
      position: absolute;
      inset: 0;
      background: rgba(15, 23, 42, 0.7);
    }
    .poi-form-panel {
      position: relative;
      z-index: 1;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 20px;
      width: min(520px, 92vw);
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.45);
      display: grid;
      gap: 12px;
    }
    .poi-form-panel h2 {
      margin: 0;
      font-size: 1.2rem;
    }
    .poi-form-grid {
      display: grid;
      gap: 12px;
    }
    .poi-form-grid label {
      display: grid;
      gap: 6px;
      font-size: 0.9rem;
    }
    .poi-form-grid input,
    .poi-form-grid textarea,
    .poi-form-grid select {
      border-radius: 8px;
      border: 1px solid var(--border);
      padding: 8px 10px;
      background: var(--card);
      color: var(--ink);
      font-size: 0.95rem;
    }
    .poi-form-grid textarea {
      min-height: 100px;
      resize: vertical;
    }
    .poi-form-row {
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
    }
    .poi-form-actions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
    }
    .poi-form-error {
      border-radius: 8px;
      border: 1px solid rgba(248, 113, 113, 0.6);
      background: rgba(248, 113, 113, 0.1);
      color: #fecaca;
      padding: 8px 10px;
      font-size: 0.85rem;
      display: none;
    }
    .poi-form-error.is-visible {
      display: block;
    }
    .poi-list-section {
      margin-top: 20px;
      padding: 16px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: var(--panel);
      display: grid;
      gap: 12px;
    }
    .poi-list-section h2 {
      margin: 0;
      font-size: 1.2rem;
    }
    #poi-list-container {
      display: grid;
      gap: 12px;
    }
    .poi-item {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      background: var(--card);
      display: grid;
      gap: 10px;
    }
    .poi-item-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    .poi-item-header strong {
      font-size: 1rem;
    }
    .poi-item-meta {
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--muted);
      font-size: 0.85rem;
    }
    .poi-item-icon {
      width: 20px;
      height: 20px;
    }
    .poi-item-grid {
      display: grid;
      gap: 10px;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    }
    .poi-item-grid label {
      display: grid;
      gap: 6px;
      font-size: 0.85rem;
      color: var(--muted);
    }
    .poi-item-grid input,
    .poi-item-grid textarea,
    .poi-item-grid select {
      border-radius: 8px;
      border: 1px solid var(--border);
      padding: 8px 10px;
      background: var(--panel);
      color: var(--ink);
      font-size: 0.9rem;
    }
    .poi-item-grid textarea {
      min-height: 80px;
      resize: vertical;
    }
    .poi-image-list {
      display: grid;
      gap: 6px;
    }
    .poi-image-row {
      display: flex;
      gap: 6px;
      align-items: center;
    }
    .poi-image-row input {
      flex: 1;
    }
    .poi-image-row button,
    .poi-image-add {
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--ink);
      padding: 6px 10px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.8rem;
    }
    .poi-item-actions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
    }
    .poi-item-actions button {
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--ink);
      padding: 6px 10px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.85rem;
    }
    .poi-adjust-highlight {
      filter: drop-shadow(0 0 8px rgba(56, 189, 248, 0.85));
      transform: scale(1.08);
      transition: transform 0.15s ease, filter 0.15s ease;
      cursor: grab;
    }
    .poi-adjust-highlight.poi-adjust-dragging {
      cursor: grabbing;
      filter: drop-shadow(0 0 10px rgba(14, 165, 233, 0.95));
      transform: scale(1.12);
    }
  </style>
</head>
<body data-route="howker-map-editor">
  <div id="nav-placeholder"></div>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const navPlaceholder = document.getElementById('nav-placeholder');
      const activeRoute = document.body.dataset.route || document.body.dataset.page;

      if (navPlaceholder) {
        fetch('/pages/nav.html')
          .then(response => response.text())
          .then(html => {
            navPlaceholder.innerHTML = html;
            const links = navPlaceholder.querySelectorAll('.site-nav-links a');
            links.forEach(link => {
              const routes = (link.dataset.routes || link.dataset.route || '')
                .split(',')
                .map(value => value.trim())
                .filter(Boolean);

              if (routes.includes(activeRoute)) {
                link.classList.add('active');
                link.setAttribute('aria-current', 'page');
              }
            });
            if (window.NH48_I18N && window.NH48_I18N.refreshLangPicker) {
              window.NH48_I18N.refreshLangPicker();
            }
          })
          .catch(err => console.error('Failed to load navigation:', err));
      }
    });
  </script>

  <div class="wrap">
    <header>
      <h1>Howker Ridge Map Editor</h1>
      <p>Update brushing status, mark blowdowns, and place signage notes for the Howker Ridge Trail.</p>
    </header>

    <div class="toolbar large" role="toolbar" aria-label="Map editing toolbar">
      <div class="tool-group" id="lineTools" aria-label="Line tools">
        <div class="tool dropdown" id="brushTool" aria-haspopup="true">
          <button type="button" class="tool-btn" title="Brush tools" aria-label="Brush tools">
            <img src="/assets/icons/brush.svg" alt="Brush tools">
          </button>
          <div class="dropdown-menu" role="menu" aria-label="Brush tool variants">
            <button type="button" class="tool-btn" data-line-type="brush_green" title="Brushed (Green)" aria-label="Brushed (Green)">
              <img src="/assets/icons/brush-green.svg" alt="Brushed (Green)">
            </button>
            <button type="button" class="tool-btn" data-line-type="brush_yellow" title="Needs brushing (Yellow)" aria-label="Needs brushing (Yellow)">
              <img src="/assets/icons/brush-yellow.svg" alt="Needs brushing (Yellow)">
            </button>
          </div>
        </div>
        <button type="button" class="tool-btn" data-line-type="bog_bridge" title="Bog bridge / puncheon" aria-label="Bog bridge / puncheon">
          <img src="/assets/icons/bog-bridge.svg" alt="Bog bridge">
        </button>
        <button type="button" class="tool-btn" data-line-type="stonework" title="Stonework" aria-label="Stonework">
          <img src="/assets/icons/stonework.svg" alt="Stonework">
        </button>
        <button type="button" class="tool-btn" data-line-type="tread" title="Tread condition" aria-label="Tread condition">
          <img src="/assets/icons/tread.svg" alt="Tread condition">
        </button>
        <button type="button" class="tool-btn" data-line-type="encroachment" title="Corridor encroachment" aria-label="Corridor encroachment">
          <img src="/assets/icons/encroachment.svg" alt="Encroachment">
        </button>
      </div>
      <div class="tool-group" id="markerTools" aria-label="Marker tools">
        <button type="button" class="tool-btn" data-marker-type="blowdown" title="Blowdown" aria-label="Blowdown">
          <img src="/assets/icons/blowdown.svg" alt="Blowdown">
        </button>
        <button type="button" class="tool-btn" data-marker-type="sign" title="Sign" aria-label="Sign">
          <img src="/assets/icons/sign.svg" alt="Sign">
        </button>
        <button type="button" class="tool-btn" data-marker-type="drain" title="Drainage" aria-label="Drainage">
          <img src="/assets/icons/drain.svg" alt="Drainage">
        </button>
        <button type="button" class="tool-btn" data-marker-type="hazard" title="Hazard" aria-label="Hazard">
          <img src="/assets/icons/hazard.svg" alt="Hazard">
        </button>
        <button type="button" class="tool-btn" data-marker-type="cairn" title="Cairn" aria-label="Cairn">
          <img src="/assets/icons/cairn.svg" alt="Cairn">
        </button>
        <button type="button" class="tool-btn" data-marker-type="poi" title="POI update" aria-label="Public point of interest update">
          <img src="/assets/icons/poi-update.svg" alt="POI update">
        </button>
        <button type="button" class="tool-btn" id="adjustPoiBtn" title="Adjust existing POI" aria-label="Adjust existing POI">
          <img src="/assets/icons/adjust-poi.svg" alt="Adjust POI icon">
        </button>
      </div>
      <div class="tool-group" id="actions" aria-label="Editing actions">
        <button id="undoBtn" type="button" title="Undo last edit" aria-label="Undo last edit">Undo</button>
        <button id="saveBtn" type="button" data-variant="green" title="Save to server" aria-label="Save to server">Save</button>
        <button id="downloadBtn" type="button" title="Download edits" aria-label="Download edits">Download</button>
        <button id="loadEditsBtn" type="button" title="Reload saved edits" aria-label="Reload saved edits">Reload</button>
        <select id="cardOrientation" aria-label="Share card orientation">
          <option value="landscape" selected>Share Card: Wide (16:9, north left)</option>
          <option value="portrait">Share Card: Vertical (9:16, north up)</option>
        </select>
        <select id="cardRes" aria-label="Share card resolution">
          <option value="4k" selected>Share Card: 4K (4096×2304)</option>
          <option value="8k">Share Card: 8K (7680×4320) — heavy</option>
        </select>
        <button id="shareCardBtn" type="button" data-variant="green">Generate Share Card (Save + Download)</button>
        <button id="topoArtBtn" type="button" data-variant="yellow" title="Create Topo Art" aria-label="Create Topo Art">Create Topo Art</button>
      </div>
      <div class="tool-group" id="searchTools" aria-label="Search and location">
        <button id="locateBtn" type="button" data-variant="green" title="Locate me" aria-label="Locate me">Locate me</button>
        <label>
          <span class="sr-only">Search trail features or POIs</span>
          <input id="searchInput" type="search" list="searchSuggestions" placeholder="Search trail features or POIs" aria-label="Search trail features or POIs" />
          <datalist id="searchSuggestions"></datalist>
        </label>
        <button id="searchBtn" type="button" title="Search trail features or POIs" aria-label="Search trail features or POIs">Search</button>
      </div>
      <span class="status" id="statusMsg" role="status" aria-live="polite"></span>
    </div>

    <div class="map-wrap">
      <div id="map" aria-label="Howker Ridge trail editor map"></div>
      <div id="shareCardOverlay" class="share-card-overlay" aria-hidden="true"></div>
    </div>

    <div class="poi-form-modal" id="poiFormModal" hidden>
      <div class="poi-form-backdrop" data-action="close" aria-hidden="true"></div>
      <div class="poi-form-panel" role="dialog" aria-modal="true" aria-labelledby="poiFormTitle">
        <h2 id="poiFormTitle">Add a new point of interest</h2>
        <form id="poiForm">
          <div class="poi-form-grid">
            <div class="poi-form-error" id="poiFormError" role="alert" aria-live="polite"></div>
            <label for="poiNameInput">Name (required)
              <input id="poiNameInput" name="poiName" type="text" required autocomplete="off" aria-label="POI name" />
            </label>
            <label for="poiSlugInput">Slug
              <input id="poiSlugInput" name="poiSlug" type="text" required autocomplete="off" aria-label="POI slug" />
            </label>
            <div class="poi-form-row">
              <label for="poiCategoryInput">Category
                <select id="poiCategoryInput" name="poiCategory" aria-label="POI category">
                  <option value="">Select category</option>
                  <option value="waterfall">Waterfall</option>
                  <option value="junction">Junction</option>
                  <option value="scenic">Scenic overlook</option>
                  <option value="summit">Summit</option>
                  <option value="other">Other</option>
                </select>
              </label>
              <label for="poiElevationInput">Elevation (ft)
                <input id="poiElevationInput" name="poiElevation" type="number" inputmode="numeric" min="0" step="1" aria-label="POI elevation" />
              </label>
            </div>
            <label for="poiDescriptionInput">Description
              <textarea id="poiDescriptionInput" name="poiDescription" aria-label="POI description"></textarea>
            </label>
            <label>Image URLs (optional)
              <div class="poi-image-list" id="poiImageList"></div>
              <button type="button" class="poi-image-add" id="poiAddImageBtn">Add image URL</button>
            </label>
          </div>
          <div class="poi-form-actions">
            <button type="button" id="poiCancelBtn" aria-label="Cancel add POI">Cancel</button>
            <button type="submit" id="poiSubmitBtn" data-variant="green" aria-label="Add POI">Add POI</button>
          </div>
        </form>
      </div>
    </div>

    <div class="legend" aria-label="Map editing legend">
      <div class="legend-item">
        <strong><span class="legend-swatch green"></span>Brushed segment</strong>
        <p>Draw green lines where the trail is brushed and ready.</p>
      </div>
      <div class="legend-item">
        <strong><span class="legend-swatch yellow"></span>Needs brushing</strong>
        <p>Draw yellow lines where brushing is needed.</p>
      </div>
      <div class="legend-item">
        <strong>Adopter tools</strong>
        <p>Use the toolbar tools to record drainage, bog bridges, stonework, tread issues, encroachment, hazards, signs, and cairns.</p>
      </div>
    </div>
    <section id="poi-list-section" class="poi-list-section">
      <h2>Edit Points of Interest</h2>
      <div id="poi-list-container"></div>
    </section>
  </div>

  <div id="shareCardModal" class="modal-backdrop" hidden>
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="shareCardTitle">
      <div class="modal-head">
        <h2 id="shareCardTitle">Share Card Export</h2>
        <button id="shareCardClose" type="button" class="xbtn" aria-label="Close">✕</button>
      </div>
      <div class="modal-body">
        <div class="step" data-step="render">
          <span class="dot"></span>
          <div><strong>Render</strong><div class="msg">Pending…</div></div>
        </div>
        <div class="step" data-step="download">
          <span class="dot"></span>
          <div><strong>Download</strong><div class="msg">Pending…</div></div>
        </div>
        <div class="step" data-step="upload">
          <span class="dot"></span>
          <div><strong>Upload to Cloudflare</strong><div class="msg">Pending…</div></div>
        </div>
        <div class="step" data-step="head">
          <span class="dot"></span>
          <div><strong>Verify (HEAD)</strong><div class="msg">Pending…</div></div>
        </div>
        <div class="step" data-step="get">
          <span class="dot"></span>
          <div><strong>Verify (GET)</strong><div class="msg">Pending…</div></div>
        </div>
        <div class="result">
          <div class="small">Remote URL</div>
          <a id="shareCardUrl" href="#" target="_blank" rel="noopener">—</a>
        </div>
      </div>
    </div>
  </div>

  <div id="topoArtModal" class="modal-backdrop" hidden>
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="topoArtTitle">
      <div class="modal-head">
        <h2 id="topoArtTitle">Create Topo Art</h2>
        <button id="topoArtClose" type="button" class="xbtn" aria-label="Close">✕</button>
      </div>
      <div class="modal-body">
        <form id="topoArtForm" class="modal-form">
          <fieldset>
            <legend>Theme</legend>
            <label>
              <input type="radio" name="topoTheme" value="dark" checked />
              Dark (white lines on black)
            </label>
            <label>
              <input type="radio" name="topoTheme" value="light" />
              Light (black lines on white)
            </label>
          </fieldset>
          <label for="topoResolution">Resolution</label>
          <select id="topoResolution" name="topoResolution">
            <option value="4k" selected>4K (3840px wide)</option>
            <option value="8k">8K (7680px wide) — heavy export</option>
          </select>
          <p class="modal-note">Exports may take a few seconds, especially at 8K. The map will temporarily resize during capture.</p>
          <div class="modal-actions">
            <button type="button" id="topoArtCancel">Cancel</button>
            <button type="button" id="generateTopoArt" data-variant="green">Generate</button>
          </div>
        </form>
      </div>
    </div>
  </div>

  <div id="footer-placeholder"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
  <script src="https://unpkg.com/leaflet-image/leaflet-image.js"></script>
  <script>
    window.addEventListener('error', (e) => {
      console.error('[HowkerEditor] Script error:', e.message, e.filename, e.lineno, e.colno);
    });

    const TRAIL_URL = '/data/howker-ridge.geojson';
    const STATUS_URL = '/data/howker-ridge-status.geojson';
    const POI_URL = '/data/howker-ridge-pois.geojson';
    const EDIT_URL = '/data/howker-ridge-edit.json';
    const PHOTO_CATALOG_URL = '/data/howker-photos.json';
    const SAVE_ENDPOINT = '/api/howker/map-update';
    const CARD_UPLOAD_ENDPOINT = '/api/howker/map-card-upload';

    const baseIcons = {
      waterfall: '/assets/icons/waterfall.svg',
      junction: '/assets/icons/junction.svg',
      scenic: '/assets/icons/viewpoint.svg',
      summit: '/assets/icons/summit.svg',
      fallback: '/assets/icons/marker-default.svg'
    };

    const editIcons = {
      blowdown: '/assets/icons/blowdown.svg',
      sign: '/assets/icons/sign.svg',
      drain: '/assets/icons/drain.svg',
      hazard: '/assets/icons/hazard.svg',
      cairn: '/assets/icons/cairn.svg',
      poi: '/assets/icons/poi-update.svg'
    };

    let map;
    let baseTrailLayer;
    let drawControl;
    let currentMarkerType = 'blowdown';
    let currentLineType = null;
    let currentTool = null;
    let pendingPoiData = null;
    let poiSlugTouched = false;
    let finishBtn;
    let highlightLayer;
    let trailMeta = {
      name: 'Howker Ridge Trail',
      poiCount: 0,
      bounds: null
    };
    const drawnLayers = new L.FeatureGroup();
    const statusSegments = [];
    const blowdownMarkers = [];
    const signMarkers = [];
    const drainageFeatures = [];
    const bogBridges = [];
    const stoneworkSegments = [];
    const treadConditions = [];
    const encroachments = [];
    const hazardMarkers = [];
    const cairnMarkers = [];
    const poiMarkers = [];
    const historyStack = [];
    const trailSegments = [];
    const basePoiLayers = [];
    const basePoiDataByName = new Map();
    const searchIndex = [];
    let photoCatalogBySlug = new Map();
    const COORDINATE_PRECISION = 6;

    function setStatusMessage(message, isError = false) {
      const statusEl = document.getElementById('statusMsg');
      if (!statusEl) return;
      statusEl.textContent = message;
      statusEl.style.color = isError ? '#f87171' : '';
    }

    function fetchJsonWithDefault(url, defaultValue) {
      return fetch(url)
        .then(resp => {
          if (!resp.ok) return defaultValue;
          return resp.json().catch(() => defaultValue);
        })
        .catch(() => defaultValue);
    }

    function normalizeFeatureArray(value) {
      if (!value) return [];
      if (Array.isArray(value)) return value;
      if (Array.isArray(value.features)) return value.features;
      return [];
    }

    function normalizeImageUrls(value) {
      if (!value) return [];
      if (Array.isArray(value)) {
        return value.map(item => (typeof item === 'string' ? item.trim() : '')).filter(Boolean);
      }
      if (typeof value === 'string') {
        const trimmed = value.trim();
        return trimmed ? [trimmed] : [];
      }
      return [];
    }

    function formatCoordinate(value) {
      return Number.isFinite(value) ? value.toFixed(COORDINATE_PRECISION) : '';
    }

    function parseCoordinate(value) {
      if (typeof value !== 'string') return null;
      const parsed = Number.parseFloat(value.trim());
      return Number.isFinite(parsed) ? parsed : null;
    }

    function slugFromFilename(filename) {
      if (!filename || typeof filename !== 'string') return '';
      return filename.replace(/\.[^/.]+$/, '').replace(/-\d+$/, '');
    }

    function buildPhotoCatalog(data) {
      const catalog = new Map();
      const filenames = Object.keys(data || {}).sort();
      filenames.forEach(filename => {
        const slug = slugFromFilename(filename);
        if (!slug) return;
        const url = `https://howker.nh48.info/cdn-cgi/image/format=webp,width=1400/${slug}/${filename}`;
        if (!catalog.has(slug)) catalog.set(slug, []);
        catalog.get(slug).push(url);
      });
      return catalog;
    }

    function getCatalogImageUrls(slug) {
      if (!slug || !photoCatalogBySlug) return [];
      return photoCatalogBySlug.get(slug) || [];
    }

    function getImageUrlsFromProps(props = {}) {
      return normalizeImageUrls(
        props.image_urls
        || props.imageUrls
        || props.image_url
        || props.imageUrl
      );
    }

    function mergeImageUrls(primary, fallback) {
      const combined = [];
      const seen = new Set();
      [primary, fallback].forEach(list => {
        (Array.isArray(list) ? list : []).forEach(url => {
          if (!url || seen.has(url)) return;
          seen.add(url);
          combined.push(url);
        });
      });
      return combined;
    }

    function getPoiImageUrls(props = {}, slug = '') {
      const primary = getImageUrlsFromProps(props);
      const fallback = getCatalogImageUrls(slug);
      return mergeImageUrls(primary, fallback);
    }

    function featureToPoi(feature) {
      const props = feature?.properties || {};
      const slug = props.slug || slugify(props.name || '');
      return {
        lat: feature.geometry?.coordinates?.[1],
        lon: feature.geometry?.coordinates?.[0],
        name: props.name || '',
        slug,
        category: props.category || '',
        elevation: props.elevation_ft ?? props.elevation ?? null,
        description: props.description || '',
        imageUrls: getPoiImageUrls(props, slug)
      };
    }

    function normalizePoiItems(value) {
      if (!value) return [];
      if (Array.isArray(value)) {
        if (value.length && value[0]?.geometry) {
          return value.map(featureToPoi).filter(item => Number.isFinite(item.lat) && Number.isFinite(item.lon));
        }
        return value
          .map(item => ({
            lat: item.lat ?? item.latitude,
            lon: item.lon ?? item.longitude,
            name: item.name || '',
            slug: item.slug || slugify(item.name || ''),
            category: item.category || '',
            elevation: item.elevation_ft ?? item.elevation ?? null,
            description: item.description || '',
            imageUrls: getPoiImageUrls(item, item.slug || slugify(item.name || ''))
          }))
          .filter(item => Number.isFinite(item.lat) && Number.isFinite(item.lon));
      }
      if (Array.isArray(value.features)) {
        return value.features.map(featureToPoi).filter(item => Number.isFinite(item.lat) && Number.isFinite(item.lon));
      }
      return [];
    }

    async function initMap() {
      const TILE_URL = '/api/tiles/opentopo/{z}/{x}/{y}.png';
      const MAX_ZOOM = 20;
      const SATELLITE_OPACITY_DEFAULT = 0.6;
      const standardLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: MAX_ZOOM,
        maxNativeZoom: 19,
        attribution: '&copy; OpenStreetMap contributors'
      });
      const topoLayer = L.tileLayer(TILE_URL, {
        maxZoom: MAX_ZOOM,
        maxNativeZoom: 17,
        crossOrigin: true,
        attribution: '© OpenTopoMap (CC-BY-SA) • © OpenStreetMap contributors'
      });
      const satelliteLayer = L.tileLayer(
        'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
        {
          maxZoom: MAX_ZOOM,
          maxNativeZoom: 19,
          opacity: SATELLITE_OPACITY_DEFAULT,
          attribution: 'Tiles © Esri — Source: Esri, Maxar, Earthstar Geographics, and the GIS User Community'
        }
      );

      map = L.map('map', { layers: [topoLayer], maxZoom: MAX_ZOOM }).setView([44.3, -71.3], 13);
      L.control.layers(
        { Topographic: topoLayer, Standard: standardLayer },
        { Satellite: satelliteLayer },
        { position: 'topleft' }
      ).addTo(map);
      L.control.scale({ position: 'bottomleft' }).addTo(map);
      const satelliteControl = L.control({ position: 'topleft' });
      satelliteControl.onAdd = () => {
        const container = L.DomUtil.create('div', 'leaflet-control satellite-control');
        container.innerHTML = `
          <label class="satellite-toggle">
            <input type="checkbox" id="satelliteToggle" />
            <span>Satellite overlay</span>
          </label>
          <label>
            <span>Opacity</span>
            <input type="range" id="satelliteOpacity" min="0" max="1" step="0.05" value="${SATELLITE_OPACITY_DEFAULT}" />
          </label>
        `;
        L.DomEvent.disableClickPropagation(container);
        L.DomEvent.disableScrollPropagation(container);
        return container;
      };
      satelliteControl.addTo(map);
      const satelliteToggle = document.getElementById('satelliteToggle');
      const satelliteOpacity = document.getElementById('satelliteOpacity');
      const syncSatelliteLayer = () => {
        if (satelliteToggle.checked) {
          if (!map.hasLayer(satelliteLayer)) map.addLayer(satelliteLayer);
        } else if (map.hasLayer(satelliteLayer)) {
          map.removeLayer(satelliteLayer);
        }
      };
      satelliteToggle.addEventListener('change', syncSatelliteLayer);
      satelliteOpacity.addEventListener('input', event => {
        const nextValue = Number(event.target.value);
        satelliteLayer.setOpacity(Number.isFinite(nextValue) ? nextValue : SATELLITE_OPACITY_DEFAULT);
      });
      map.on('overlayadd', event => {
        if (event.layer === satelliteLayer) {
          satelliteToggle.checked = true;
        }
      });
      map.on('overlayremove', event => {
        if (event.layer === satelliteLayer) {
          satelliteToggle.checked = false;
        }
      });
      map.addLayer(drawnLayers);

      photoCatalogBySlug = await fetchJsonWithDefault(PHOTO_CATALOG_URL, {}).then(buildPhotoCatalog);
      await loadBaseTrail();
      await loadExistingEdits();
      buildPoiList();
      setupDrawTools();
    }

    async function loadBaseTrail() {
      const res = await fetch(TRAIL_URL);
      const data = await res.json();
      const features = Array.isArray(data?.features) ? data.features : [];
      const lineFeatures = features.filter(feature => feature.geometry && feature.geometry.type === 'LineString');
      const firstLineName = lineFeatures.find(feature => feature.properties?.name)?.properties?.name;
      const poiFeatures = features.filter(feature => feature.geometry && feature.geometry.type === 'Point');

      baseTrailLayer = L.geoJSON(data, {
        filter: feature => feature.geometry && feature.geometry.type === 'LineString',
        style: { color: '#0ea5e9', weight: 3, opacity: 0.8 }
      }).addTo(map);
      cacheTrailSegments();

      const bounds = baseTrailLayer.getBounds();
      if (bounds.isValid()) map.fitBounds(bounds.pad(0.05));
      trailMeta = {
        name: firstLineName || 'Howker Ridge Trail',
        poiCount: poiFeatures.length,
        bounds
      };

      L.geoJSON(data, {
        filter: feature => feature.geometry && feature.geometry.type === 'Point',
        pointToLayer: (feature, latlng) => {
          const category = feature.properties?.category || '';
          const iconPath = baseIcons[category] || baseIcons.fallback;
          const icon = L.icon({ iconUrl: iconPath, iconSize: [22, 22], iconAnchor: [11, 22] });
          return L.marker(latlng, {
            icon,
            name: feature.properties?.name || '',
            slug: feature.properties?.slug || '',
            category: feature.properties?.category || '',
            elevation_ft: feature.properties?.elevation_ft ?? null,
            description: feature.properties?.description || '',
            image_urls: getPoiImageUrls(feature.properties, feature.properties?.slug || slugify(feature.properties?.name || '')),
            image_url: feature.properties?.image_url || ''
          });
        },
        onEachFeature: (feature, layer) => {
          const props = feature.properties || {};
          const title = props.name || '';
          const desc = props.description || '';
          const slug = props.slug || slugify(title);
          if (title) {
            basePoiDataByName.set(title, {
              name: title,
              category: props.category || '',
              description: desc,
              elevation_ft: props.elevation_ft ?? null,
              slug,
              image_urls: getPoiImageUrls(props, slug)
            });
          }
          layer.bindPopup(`<strong>${title}</strong><br/>${desc}`);
          if (title) {
            basePoiLayers.push({ name: title, layer, props: layer.options });
          }
        }
      }).addTo(map);
      syncBasePoiLayers();
      updateSearchIndex();
      updateShareCardOverlay();
    }

    async function loadExistingEdits() {
      setStatusMessage('Loading edits...');
      const resetState = () => {
        statusSegments.length = 0;
        blowdownMarkers.length = 0;
        signMarkers.length = 0;
        drainageFeatures.length = 0;
        bogBridges.length = 0;
        stoneworkSegments.length = 0;
        treadConditions.length = 0;
        encroachments.length = 0;
        hazardMarkers.length = 0;
        cairnMarkers.length = 0;
        poiMarkers.length = 0;
        historyStack.length = 0;
      };

      try {
        resetState();
        const editRes = await fetch(EDIT_URL);
        let editJson = null;
        if (editRes.ok) {
          try {
            editJson = await editRes.json();
          } catch (error) {
            editJson = null;
          }
        }

        if (!editJson) {
          redrawOverlays();
          buildPoiList();
          setStatusMessage('No saved edits yet (fresh start).');
          return;
        }

        const editStatusFeatures = normalizeFeatureArray(editJson.status || editJson.statuses);
        const editPoiItems = normalizePoiItems(editJson.pois);
        const legacyStatus = editStatusFeatures.length
          ? { features: [] }
          : await fetchJsonWithDefault(STATUS_URL, { features: [] });
        const legacyPois = editPoiItems.length
          ? { features: [] }
          : await fetchJsonWithDefault(POI_URL, { features: [] });

        const statusFeatures = editStatusFeatures.length ? editStatusFeatures : legacyStatus.features || [];
        statusFeatures.forEach(feature => {
          const coords = feature.geometry.coordinates.map(coord => [coord[1], coord[0]]);
          statusSegments.push({ coords, status: feature.properties?.status || 'green' });
        });

        normalizeFeatureArray(editJson.blowdowns).forEach(feature => {
          blowdownMarkers.push({
            lat: feature.geometry.coordinates[1],
            lon: feature.geometry.coordinates[0],
            description: feature.properties?.description || '',
            size: feature.properties?.size || '',
            passable: feature.properties?.passable ?? null,
            tool: feature.properties?.tool || ''
          });
        });
        normalizeFeatureArray(editJson.signs).forEach(feature => {
          signMarkers.push({
            lat: feature.geometry.coordinates[1],
            lon: feature.geometry.coordinates[0],
            description: feature.properties?.description || '',
            subtype: feature.properties?.subtype || '',
            junction: feature.properties?.junction || '',
            direction: feature.properties?.direction || '',
            text: feature.properties?.text || ''
          });
        });
        normalizeFeatureArray(editJson.drainage).forEach(feature => {
          drainageFeatures.push({
            lat: feature.geometry.coordinates[1],
            lon: feature.geometry.coordinates[0],
            subtype: feature.properties?.subtype || '',
            condition: feature.properties?.condition || '',
            last_worked: feature.properties?.last_worked || '',
            notes: feature.properties?.notes || ''
          });
        });
        normalizeFeatureArray(editJson.bogBridges).forEach(feature => {
          bogBridges.push({
            coords: feature.geometry.coordinates.map(coord => [coord[1], coord[0]]),
            length_ft: feature.properties?.length_ft || 0,
            condition: feature.properties?.condition || '',
            hazard: feature.properties?.hazard || false,
            subtype: feature.properties?.subtype || ''
          });
        });
        normalizeFeatureArray(editJson.stonework).forEach(feature => {
          stoneworkSegments.push({
            coords: feature.geometry.coordinates.map(coord => [coord[1], coord[0]]),
            subtype: feature.properties?.subtype || '',
            condition: feature.properties?.condition || '',
            notes: feature.properties?.notes || ''
          });
        });
        normalizeFeatureArray(editJson.tread).forEach(feature => {
          treadConditions.push({
            coords: feature.geometry.coordinates.map(coord => [coord[1], coord[0]]),
            status: feature.properties?.status || '',
            notes: feature.properties?.notes || ''
          });
        });
        normalizeFeatureArray(editJson.encroachments).forEach(feature => {
          encroachments.push({
            coords: feature.geometry.coordinates.map(coord => [coord[1], coord[0]]),
            side: feature.properties?.side || '',
            notes: feature.properties?.notes || ''
          });
        });
        normalizeFeatureArray(editJson.hazards).forEach(feature => {
          hazardMarkers.push({
            lat: feature.geometry.coordinates[1],
            lon: feature.geometry.coordinates[0],
            subtype: feature.properties?.subtype || '',
            severity: feature.properties?.severity || '',
            seasonal: feature.properties?.seasonal || '',
            description: feature.properties?.description || ''
          });
        });
        normalizeFeatureArray(editJson.cairns).forEach(feature => {
          cairnMarkers.push({
            lat: feature.geometry.coordinates[1],
            lon: feature.geometry.coordinates[0],
            status: feature.properties?.status || '',
            notes: feature.properties?.notes || ''
          });
        });

        let poiItems = editPoiItems;
        if (!poiItems.length && legacyPois.features?.length) {
          poiItems = legacyPois.features.map(feature => ({
            name: feature.properties?.name || '',
            slug: feature.properties?.slug || slugify(feature.properties?.name || ''),
            category: feature.properties?.category || '',
            elevation: feature.properties?.elevation_ft ?? null,
            description: feature.properties?.description || '',
            imageUrls: getPoiImageUrls(feature.properties || {}, feature.properties?.slug || slugify(feature.properties?.name || '')),
            lat: feature.geometry.coordinates[1],
            lon: feature.geometry.coordinates[0]
          }));
        }
        poiItems.forEach(item => poiMarkers.push(item));

        redrawOverlays();
        buildPoiList();
        setStatusMessage('Edits loaded.');
      } catch (err) {
        setStatusMessage('Unable to load edits.', true);
      }
    }

    function promptValue(label, fallback = '') {
      const value = prompt(label, fallback);
      if (value === null) return '';
      return value.trim();
    }

    function promptYesNo(label, fallback = '') {
      const value = prompt(label, fallback);
      if (value === null) return null;
      const normalized = value.trim().toLowerCase();
      if (['yes', 'y', 'true', '1'].includes(normalized)) return true;
      if (['no', 'n', 'false', '0'].includes(normalized)) return false;
      return null;
    }

    function slugify(value) {
      return value.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
    }

    function clearPoiFormError() {
      const errorEl = document.getElementById('poiFormError');
      if (!errorEl) return;
      errorEl.textContent = '';
      errorEl.classList.remove('is-visible');
    }

    function showPoiFormError(message) {
      const errorEl = document.getElementById('poiFormError');
      if (!errorEl) return;
      errorEl.textContent = message;
      errorEl.classList.add('is-visible');
    }

    function openPoiFormModal() {
      const modal = document.getElementById('poiFormModal');
      if (!modal) return;
      clearPoiFormError();
      modal.hidden = false;
      const nameInput = document.getElementById('poiNameInput');
      if (nameInput) {
        nameInput.focus();
      }
    }

    function closePoiFormModal() {
      const modal = document.getElementById('poiFormModal');
      if (!modal) return;
      modal.hidden = true;
    }

    function resetPoiForm() {
      const form = document.getElementById('poiForm');
      if (form) form.reset();
      poiSlugTouched = false;
      clearPoiFormError();
      const imageList = document.getElementById('poiImageList');
      if (imageList) {
        imageList.innerHTML = '';
        buildPoiImageRow(imageList, '');
      }
    }

    function buildPoiImageRow(container, value = '') {
      if (!container) return;
      const row = document.createElement('div');
      row.className = 'poi-image-row';
      const input = document.createElement('input');
      input.type = 'url';
      input.placeholder = 'https://photos.nh48.info/...';
      input.value = value;
      const removeBtn = document.createElement('button');
      removeBtn.type = 'button';
      removeBtn.textContent = 'Remove';
      removeBtn.addEventListener('click', () => {
        row.remove();
        if (!container.querySelector('.poi-image-row')) {
          buildPoiImageRow(container, '');
        }
      });
      row.append(input, removeBtn);
      container.appendChild(row);
    }

    function getPoiNames() {
      const names = new Set();
      basePoiDataByName.forEach((value, key) => names.add(key.toLowerCase()));
      poiMarkers.forEach(item => {
        if (item.name) names.add(item.name.toLowerCase());
      });
      return names;
    }

    function getPoiSlugs() {
      const slugs = new Set();
      basePoiDataByName.forEach(value => {
        if (value.slug) slugs.add(value.slug.toLowerCase());
        if (value.name) slugs.add(slugify(value.name));
      });
      poiMarkers.forEach(item => {
        if (item.slug) slugs.add(item.slug.toLowerCase());
        if (item.name) slugs.add(slugify(item.name));
      });
      return slugs;
    }

    function disableDrawHandlers() {
      const toolbar = drawControl?._toolbars?.draw;
      toolbar?._modes?.polyline?.handler?.disable();
      toolbar?._modes?.marker?.handler?.disable();
    }

    function hasMapControl(mapInstance, control) {
      if (!mapInstance || !control) return false;
      if (typeof mapInstance.hasControl === 'function') return mapInstance.hasControl(control);
      const container = control._container;
      if (!container) return false;
      return Boolean(mapInstance._controlContainer?.contains(container));
    }

    function setActiveTool(tool) {
      currentTool = tool;
      if (tool === 'adjust-poi' || tool === 'poi-add') {
        if (hasMapControl(map, drawControl)) map.removeControl(drawControl);
        disableDrawHandlers();
      } else if (drawControl && map && !hasMapControl(map, drawControl)) {
        map.addControl(drawControl);
      }

      if (tool !== 'poi-add') {
        pendingPoiData = null;
        closePoiFormModal();
      }
      if (tool !== 'adjust-poi') {
        disableAdjustPoiMode();
      } else {
        enableAdjustPoiMode();
      }
      updateBrushEditing();
    }

    function toggleMarkerHighlight(marker, enabled) {
      const el = marker?.getElement?.();
      if (!el) return;
      el.classList.toggle('poi-adjust-highlight', enabled);
      if (!enabled) {
        el.classList.remove('poi-adjust-dragging');
      }
    }

    function toggleMarkerDraggingState(marker, enabled) {
      const el = marker?.getElement?.();
      if (!el) return;
      el.classList.toggle('poi-adjust-dragging', enabled);
    }

    function findPoiRowBySlug(slug) {
      if (!slug) return null;
      return document.querySelector(`.poi-item[data-base-slug="${slug}"], .poi-item[data-slug="${slug}"]`);
    }

    function updatePoiListCoordinates(slug, lat, lon) {
      const row = findPoiRowBySlug(slug);
      if (!row) return;
      const latInput = row.querySelector('input[data-coord="lat"]');
      const lonInput = row.querySelector('input[data-coord="lon"]');
      if (latInput) latInput.value = formatCoordinate(lat);
      if (lonInput) lonInput.value = formatCoordinate(lon);
    }

    function upsertPoiCoordinates({ name, slug, lat, lon, baseSlug }) {
      const key = baseSlug || slug || slugify(name || '');
      if (!key) return;
      const existing = poiMarkers.find(poi => (poi.slug || slugify(poi.name || '')) === key);
      if (existing) {
        existing.lat = lat;
        existing.lon = lon;
      } else {
        poiMarkers.push({ name, slug: slug || key, lat, lon });
      }
      updatePoiListCoordinates(key, lat, lon);
    }

    function registerPoiDragHandlers(marker, meta) {
      if (!marker || marker._poiAdjustHandlersAdded) return;
      marker._poiAdjustHandlersAdded = true;
      marker.on('dragstart', () => toggleMarkerDraggingState(marker, true));
      marker.on('dragend', () => {
        toggleMarkerDraggingState(marker, false);
        const ll = marker.getLatLng();
        upsertPoiCoordinates({
          name: meta.name,
          slug: meta.slug,
          baseSlug: meta.baseSlug,
          lat: ll.lat,
          lon: ll.lng
        });
        setStatusMessage(`Updated ${meta.name || 'POI'} coordinates.`);
      });
    }

    function enableAdjustPoiMode() {
      basePoiLayers.forEach(item => {
        const layer = item.layer;
        if (!layer) return;
        const slug = layer?.options?.slug || slugify(item.name || '');
        registerPoiDragHandlers(layer, {
          name: item.name,
          slug,
          baseSlug: slug
        });
      });
      basePoiLayers.forEach(item => {
        const layer = item.layer;
        if (!layer) return;
        layer.dragging?.enable();
        toggleMarkerHighlight(layer, true);
      });
      poiMarkers.forEach(item => {
        if (!item._marker) return;
        registerPoiDragHandlers(item._marker, {
          name: item.name,
          slug: item.slug || slugify(item.name || '')
        });
        item._marker.dragging?.enable();
        toggleMarkerHighlight(item._marker, true);
      });
    }

    function disableAdjustPoiMode() {
      basePoiLayers.forEach(item => {
        const layer = item.layer;
        if (!layer) return;
        if (layer.dragging?.enabled?.()) {
          layer.dragging.disable();
        }
        toggleMarkerHighlight(layer, false);
      });
      poiMarkers.forEach(item => {
        if (!item._marker) return;
        if (item._marker.dragging?.enabled?.()) {
          item._marker.dragging.disable();
        }
        toggleMarkerHighlight(item._marker, false);
      });
    }

    function calculateLengthFt(latlngs) {
      let meters = 0;
      for (let i = 1; i < latlngs.length; i += 1) {
        meters += map.distance(latlngs[i - 1], latlngs[i]);
      }
      return meters * 3.28084;
    }

    function collectLineLatLngs(latlngs, target) {
      if (!Array.isArray(latlngs)) {
        target.push(latlngs);
        return;
      }
      if (latlngs.length && latlngs[0] instanceof L.LatLng) {
        target.push(...latlngs);
        return;
      }
      latlngs.forEach(item => collectLineLatLngs(item, target));
    }

    function cacheTrailSegments() {
      trailSegments.length = 0;
      if (!baseTrailLayer) return;
      baseTrailLayer.eachLayer(layer => {
        if (!layer.getLatLngs) return;
        const flattened = [];
        collectLineLatLngs(layer.getLatLngs(), flattened);
        for (let i = 1; i < flattened.length; i += 1) {
          trailSegments.push([flattened[i - 1], flattened[i]]);
        }
      });
    }

    function closestPointOnSegment(point, segStart, segEnd) {
      const dx = segEnd.x - segStart.x;
      const dy = segEnd.y - segStart.y;
      const lengthSquared = dx * dx + dy * dy;
      if (!lengthSquared) return segStart;
      const t = Math.max(0, Math.min(1, ((point.x - segStart.x) * dx + (point.y - segStart.y) * dy) / lengthSquared));
      return L.point(segStart.x + dx * t, segStart.y + dy * t);
    }

    function snapLatLng(latlng, options = {}) {
      if (!trailSegments.length) return latlng;
      const zoom = map.getZoom();
      const maxDistancePx = Number.isFinite(options.maxDistancePx) ? options.maxDistancePx : 28;
      const target = map.project(latlng, zoom);
      let closest = null;
      let closestDistance = Infinity;
      trailSegments.forEach(([start, end]) => {
        const segStart = map.project(start, zoom);
        const segEnd = map.project(end, zoom);
        const candidate = closestPointOnSegment(target, segStart, segEnd);
        const dist = candidate.distanceTo(target);
        if (dist < closestDistance) {
          closestDistance = dist;
          closest = candidate;
        }
      });
      if (!closest || closestDistance > maxDistancePx) return latlng;
      return map.unproject(closest, zoom);
    }

    function snapLatLngs(latlngs, options = {}) {
      if (Array.isArray(latlngs)) {
        return latlngs.map(item => snapLatLngs(item, options));
      }
      return snapLatLng(latlngs, options);
    }

    function latLngsToCoords(latlngs) {
      const flattened = [];
      collectLineLatLngs(latlngs, flattened);
      return flattened.map(latlng => [latlng.lat, latlng.lng]);
    }

    function updateStatusSegmentFromLayer(seg) {
      if (!seg?._layer) return;
      const latlngs = seg._layer.getLatLngs();
      const snapped = snapLatLngs(latlngs, { maxDistancePx: 28 });
      seg._layer.setLatLngs(snapped);
      seg.coords = latLngsToCoords(snapped);
    }

    function updateBrushEditing() {
      const brushStatus = currentLineType === 'brush_green' ? 'green' : currentLineType === 'brush_yellow' ? 'yellow' : null;
      statusSegments.forEach(seg => {
        const layer = seg._layer;
        if (!layer?.editing) return;
        if (brushStatus && seg.status === brushStatus) {
          layer.editing.enable();
        } else {
          layer.editing.disable();
        }
      });
    }

    function setupDrawTools() {
      drawControl = new L.Control.Draw({
        draw: {
          polyline: {
            shapeOptions: { weight: 5, opacity: 0.8 },
            repeatMode: true,
            metric: false
          },
          polygon: false,
          rectangle: false,
          circle: false,
          circlemarker: false,
          marker: {
            icon: L.icon({ iconUrl: editIcons.blowdown, iconSize: [26, 26], iconAnchor: [13, 26] })
          }
        },
        edit: {
          featureGroup: drawnLayers,
          edit: false,
          remove: false
        }
      });
      map.addControl(drawControl);

      map.on(L.Draw.Event.CREATED, event => {
        const layer = event.layer;
        if (event.layerType === 'polyline' && currentLineType) {
          const snapped = snapLatLngs(layer.getLatLngs(), { maxDistancePx: 32 });
          layer.setLatLngs(snapped);
          const latlngs = layer.getLatLngs();
          const coords = latLngsToCoords(latlngs);
          const flatLatLngs = [];
          collectLineLatLngs(latlngs, flatLatLngs);
          const lengthFt = calculateLengthFt(flatLatLngs);

          if (currentLineType === 'brush_green' || currentLineType === 'brush_yellow') {
            const status = currentLineType === 'brush_green' ? 'green' : 'yellow';
            statusSegments.push({ coords, status });
            historyStack.push({ type: 'status' });
          } else if (currentLineType === 'bog_bridge') {
            const subtype = promptValue('Bog bridge subtype (bog_bridge, puncheon, stepping_stones):');
            const condition = promptValue('Condition (good, fair, poor):');
            const hazard = promptYesNo('Is this section hazardous? (yes/no)');
            bogBridges.push({ coords, length_ft: lengthFt, condition, hazard, subtype });
            historyStack.push({ type: 'bog_bridge' });
          } else if (currentLineType === 'stonework') {
            const subtype = promptValue('Stonework subtype (rock_step, staircase, retaining_wall, causeway):');
            const condition = promptValue('Condition (good, fair, poor):');
            const notes = promptValue('Notes (optional):');
            stoneworkSegments.push({ coords, subtype, condition, notes });
            historyStack.push({ type: 'stonework' });
          } else if (currentLineType === 'tread') {
            const status = promptValue('Tread condition (stable, eroding, severe, braided):');
            const notes = promptValue('Notes (optional):');
            treadConditions.push({ coords, status, notes });
            historyStack.push({ type: 'tread' });
          } else if (currentLineType === 'encroachment') {
            const side = promptValue('Encroachment side (left, right, both):');
            const notes = promptValue('Notes (optional):');
            encroachments.push({ coords, side, notes });
            historyStack.push({ type: 'encroachment' });
          }
          redrawOverlays();
        } else if (event.layerType === 'marker') {
          const latlng = layer.getLatLng();
          if (currentMarkerType === 'blowdown') {
            const size = promptValue('Blowdown size (small, medium, large):');
            const passable = promptYesNo('Passable? (yes/no)');
            const tool = promptValue('Required tool (crosscut, chainsaw, hand):');
            const description = promptValue('Notes (optional):');
            blowdownMarkers.push({ lat: latlng.lat, lon: latlng.lng, size, passable, tool, description });
            historyStack.push({ type: 'blowdown' });
          } else if (currentMarkerType === 'sign') {
            const subtype = promptValue('Sign subtype (junction, blaze, info):');
            const junction = promptValue('Junction name (optional):');
            const direction = promptValue('Direction (optional):');
            const text = promptValue('Sign text (optional):');
            const description = promptValue('Notes (optional):');
            signMarkers.push({ lat: latlng.lat, lon: latlng.lng, subtype, junction, direction, text, description });
            historyStack.push({ type: 'sign' });
          } else if (currentMarkerType === 'drain') {
            const subtype = promptValue('Drainage subtype (water_bar, drain_dip, ditch, cross_drain):');
            const condition = promptValue('Condition (clear, partial, blocked):');
            const last_worked = promptValue('Last worked (YYYY-MM-DD):');
            const notes = promptValue('Notes (optional):');
            drainageFeatures.push({ lat: latlng.lat, lon: latlng.lng, subtype, condition, last_worked, notes });
            historyStack.push({ type: 'drainage' });
          } else if (currentMarkerType === 'hazard') {
            const subtype = promptValue('Hazard subtype (ice, cliff, slab, washout):');
            const severity = promptValue('Severity (low, medium, high):');
            const seasonal = promptValue('Seasonal (winter, spring, year-round):');
            const description = promptValue('Notes (optional):');
            hazardMarkers.push({ lat: latlng.lat, lon: latlng.lng, subtype, severity, seasonal, description });
            historyStack.push({ type: 'hazard' });
          } else if (currentMarkerType === 'cairn') {
            const status = promptValue('Cairn status (good, needs_reset, missing):');
            const notes = promptValue('Notes (optional):');
            cairnMarkers.push({ lat: latlng.lat, lon: latlng.lng, status, notes });
            historyStack.push({ type: 'cairn' });
          }
          redrawOverlays();
        }
        if (finishBtn) finishBtn.style.display = 'none';
      });

      map.on('draw:drawvertex', event => {
        if (!event.layers || !event.layers.getLayers().length) return;
        const markers = event.layers.getLayers();
        const last = markers[markers.length - 1];
        const snapped = snapLatLng(last.getLatLng(), { maxDistancePx: 32 });
        last.setLatLng(snapped);
        showFinishButton(last.getLatLng());
        const finishLine = () => completePolyline();
        if (last._finishHandler) {
          last.off('click', last._finishHandler);
        }
        last._finishHandler = finishLine;
        last.on('click', finishLine);
      });
    }

    function addDraggableMarker(item, iconUrl, popupHtml, options = {}) {
      const icon = L.icon({ iconUrl, iconSize: [26, 26], iconAnchor: [13, 26] });
      const marker = L.marker([item.lat, item.lon], { icon, draggable: options.draggable ?? true }).addTo(drawnLayers);
      if (popupHtml) marker.bindPopup(popupHtml);
      marker.on('dragend', () => {
        const ll = marker.getLatLng();
        item.lat = ll.lat;
        item.lon = ll.lng;
      });
      return marker;
    }

    function redrawOverlays() {
      drawnLayers.clearLayers();
      statusSegments.forEach(seg => {
        const color = seg.status === 'green' ? '#15803d' : '#b45309';
        const line = L.polyline(seg.coords, { color, weight: 5, opacity: 0.5 }).addTo(drawnLayers);
        seg._layer = line;
        line.on('edit', () => updateStatusSegmentFromLayer(seg));
      });

      bogBridges.forEach(bb => {
        const opts = { color: '#8b5cf6', weight: 6, opacity: 0.7 };
        const label = `<strong>Bog Bridge</strong><br>Length: ${bb.length_ft ? bb.length_ft.toFixed(0) : '0'} ft<br>Condition: ${bb.condition || ''}${bb.hazard ? '<br><em>Hazardous</em>' : ''}`;
        L.polyline(bb.coords, opts).addTo(drawnLayers).bindPopup(label);
      });

      stoneworkSegments.forEach(seg => {
        const opts = { color: '#94a3b8', weight: 6, opacity: 0.7 };
        const label = `<strong>Stonework</strong><br>${seg.subtype || ''}<br>Condition: ${seg.condition || ''}<br>${seg.notes || ''}`;
        L.polyline(seg.coords, opts).addTo(drawnLayers).bindPopup(label);
      });

      treadConditions.forEach(seg => {
        const opts = { color: '#f97316', weight: 6, opacity: 0.7 };
        const label = `<strong>Tread Condition</strong><br>${seg.status || ''}<br>${seg.notes || ''}`;
        L.polyline(seg.coords, opts).addTo(drawnLayers).bindPopup(label);
      });

      encroachments.forEach(seg => {
        const opts = { color: '#ef4444', weight: 6, opacity: 0.7 };
        const label = `<strong>Encroachment</strong><br>${seg.side || ''}<br>${seg.notes || ''}`;
        L.polyline(seg.coords, opts).addTo(drawnLayers).bindPopup(label);
      });

      blowdownMarkers.forEach(item => {
        const label = `<strong>Blowdown</strong><br>Size: ${item.size || ''}<br>Passable: ${item.passable === null ? '' : item.passable ? 'Yes' : 'No'}<br>Tool: ${item.tool || ''}<br>${item.description || ''}`;
        addDraggableMarker(item, editIcons.blowdown, label);
      });

      signMarkers.forEach(item => {
        const label = `<strong>Sign</strong><br>${item.subtype || ''}<br>${item.junction || ''}<br>${item.direction || ''}<br>${item.text || ''}<br>${item.description || ''}`;
        addDraggableMarker(item, editIcons.sign, label);
      });

      drainageFeatures.forEach(item => {
        const label = `<strong>Drainage</strong><br>${item.subtype || ''}<br>Condition: ${item.condition || ''}<br>Last worked: ${item.last_worked || ''}<br>${item.notes || ''}`;
        addDraggableMarker(item, editIcons.drain, label);
      });

      hazardMarkers.forEach(item => {
        const label = `<strong>Hazard</strong><br>${item.subtype || ''}<br>Severity: ${item.severity || ''}<br>Seasonal: ${item.seasonal || ''}<br>${item.description || ''}`;
        addDraggableMarker(item, editIcons.hazard, label);
      });

      cairnMarkers.forEach(item => {
        const label = `<strong>Cairn</strong><br>Status: ${item.status || ''}<br>${item.notes || ''}`;
        addDraggableMarker(item, editIcons.cairn, label);
      });

      poiMarkers.forEach(item => {
        if (basePoiDataByName.has(item.name)) {
          return;
        }
        const elevation = item.elevation ? `${item.elevation} ft` : '';
        const label = [
          `<strong>${item.name || 'POI'}</strong>`,
          item.category || '',
          elevation,
          item.description || ''
        ].filter(Boolean).join('<br>');
        const iconUrl = baseIcons[item.category] || baseIcons.fallback || editIcons.poi;
        item._marker = addDraggableMarker(item, iconUrl, label, { draggable: currentTool === 'adjust-poi' });
      });

      syncBasePoiLayers();
      updateSearchIndex();
      updateShareCardOverlay();
      updateBrushEditing();
      if (currentTool === 'adjust-poi') {
        enableAdjustPoiMode();
      }
    }

    function getBasePoiData(item) {
      const props = item?.layer?.options || item?.props || {};
      const name = props.name || item.name || '';
      const slug = props.slug || slugify(name);
      return {
        name,
        slug,
        category: props.category || '',
        elevation: props.elevation_ft ?? null,
        description: props.description || '',
        imageUrls: getPoiImageUrls(props, slug)
      };
    }

    function getPoiIconForCategory(category) {
      return baseIcons[category] || baseIcons.fallback || editIcons.poi;
    }

    function renderPoiRow(container, poi, options = {}) {
      const row = document.createElement('div');
      row.className = 'poi-item';
      const slug = poi.slug || (poi.name ? slugify(poi.name) : '');
      if (options.baseSlug) row.dataset.baseSlug = options.baseSlug;
      row.dataset.slug = slug;

      const header = document.createElement('div');
      header.className = 'poi-item-header';

      const headerLeft = document.createElement('div');
      headerLeft.className = 'poi-item-meta';
      const icon = document.createElement('img');
      icon.className = 'poi-item-icon';
      icon.alt = 'POI category icon';
      icon.src = getPoiIconForCategory(poi.category);
      const title = document.createElement('strong');
      title.textContent = poi.name || 'Untitled POI';
      headerLeft.append(icon, title);

      const actions = document.createElement('div');
      actions.className = 'poi-item-actions';
      const focusBtn = document.createElement('button');
      focusBtn.type = 'button';
      focusBtn.textContent = 'Locate';
      focusBtn.addEventListener('click', () => {
        if (Number.isFinite(poi.lat) && Number.isFinite(poi.lon)) {
          map.flyTo([poi.lat, poi.lon], 16);
        }
      });
      actions.appendChild(focusBtn);

      header.append(headerLeft, actions);

      const grid = document.createElement('div');
      grid.className = 'poi-item-grid';

      const isBase = options.isBase || false;

      const nameLabel = document.createElement('label');
      nameLabel.textContent = 'Name';
      const nameInput = document.createElement('input');
      nameInput.type = 'text';
      nameInput.value = poi.name || '';
      nameInput.disabled = isBase;
      nameLabel.appendChild(nameInput);

      const slugLabel = document.createElement('label');
      slugLabel.textContent = 'Slug';
      const slugInput = document.createElement('input');
      slugInput.type = 'text';
      slugInput.value = poi.slug || slugify(poi.name || '');
      slugInput.disabled = isBase;
      slugLabel.appendChild(slugInput);

      const categoryLabel = document.createElement('label');
      categoryLabel.textContent = 'Category';
      const categorySelect = document.createElement('select');
      ['','waterfall','junction','scenic','summit','other'].forEach(value => {
        const option = document.createElement('option');
        option.value = value;
        option.textContent = value ? value[0].toUpperCase() + value.slice(1) : 'Select category';
        if (value === poi.category) option.selected = true;
        categorySelect.appendChild(option);
      });
      categoryLabel.appendChild(categorySelect);

      const elevationLabel = document.createElement('label');
      elevationLabel.textContent = 'Elevation (ft)';
      const elevationInput = document.createElement('input');
      elevationInput.type = 'number';
      elevationInput.min = '0';
      elevationInput.step = '1';
      elevationInput.value = Number.isFinite(poi.elevation) ? String(poi.elevation) : '';
      elevationLabel.appendChild(elevationInput);

      const latLabel = document.createElement('label');
      latLabel.textContent = 'Latitude';
      const latInput = document.createElement('input');
      latInput.type = 'text';
      latInput.inputMode = 'decimal';
      latInput.dataset.coord = 'lat';
      latInput.value = formatCoordinate(poi.lat);
      latLabel.appendChild(latInput);

      const lonLabel = document.createElement('label');
      lonLabel.textContent = 'Longitude';
      const lonInput = document.createElement('input');
      lonInput.type = 'text';
      lonInput.inputMode = 'decimal';
      lonInput.dataset.coord = 'lon';
      lonInput.value = formatCoordinate(poi.lon);
      lonLabel.appendChild(lonInput);

      const descriptionLabel = document.createElement('label');
      descriptionLabel.textContent = 'Description';
      const descriptionInput = document.createElement('textarea');
      descriptionInput.value = poi.description || '';
      descriptionLabel.appendChild(descriptionInput);

      const imageLabel = document.createElement('label');
      imageLabel.textContent = 'Image URLs';
      const imageList = document.createElement('div');
      imageList.className = 'poi-image-list';

      const updatePoi = () => {
        const latValue = parseCoordinate(latInput.value);
        const lonValue = parseCoordinate(lonInput.value);
        if (Number.isFinite(latValue)) {
          latInput.value = formatCoordinate(latValue);
        }
        if (Number.isFinite(lonValue)) {
          lonInput.value = formatCoordinate(lonValue);
        }
        const imageUrls = Array.from(imageList.querySelectorAll('input'))
          .map(input => input.value.trim())
          .filter(Boolean);
        const resolvedLat = Number.isFinite(latValue) ? latValue : poi.lat;
        const resolvedLon = Number.isFinite(lonValue) ? lonValue : poi.lon;
        const updated = {
          name: nameInput.value.trim(),
          slug: slugInput.value.trim(),
          category: categorySelect.value,
          elevation: elevationInput.value ? Number(elevationInput.value) : null,
          description: descriptionInput.value.trim(),
          imageUrls,
          lat: resolvedLat,
          lon: resolvedLon
        };
        row.dataset.slug = updated.slug || slugify(updated.name || '');
        updatePoiMarker(updated, row.dataset.baseSlug);
        title.textContent = updated.name || 'Untitled POI';
        icon.src = getPoiIconForCategory(updated.category);
      };

      const addImageInput = (value = '') => {
        const row = document.createElement('div');
        row.className = 'poi-image-row';
        const input = document.createElement('input');
        input.type = 'url';
        input.placeholder = 'https://photos.nh48.info/...';
        input.value = value;
        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.textContent = 'Remove';
        removeBtn.addEventListener('click', () => {
          row.remove();
          updatePoi();
        });
        input.addEventListener('change', updatePoi);
        row.append(input, removeBtn);
        imageList.appendChild(row);
      };

      const startingImages = Array.isArray(poi.imageUrls) ? poi.imageUrls : [];
      if (startingImages.length) {
        startingImages.forEach(url => addImageInput(url));
      } else {
        addImageInput('');
      }

      const addImageBtn = document.createElement('button');
      addImageBtn.type = 'button';
      addImageBtn.className = 'poi-image-add';
      addImageBtn.textContent = 'Add image URL';
      addImageBtn.addEventListener('click', () => {
        addImageInput('');
      });

      imageLabel.append(imageList, addImageBtn);

      grid.append(
        nameLabel,
        slugLabel,
        categoryLabel,
        elevationLabel,
        latLabel,
        lonLabel,
        descriptionLabel,
        imageLabel
      );

      [nameInput, slugInput, categorySelect, elevationInput, descriptionInput, latInput, lonInput].forEach(input => {
        input.addEventListener('change', updatePoi);
      });

      row.append(header, grid);
      container.appendChild(row);
    }

    function updatePoiMarker(updated, baseSlug = '') {
      const slugKey = baseSlug || updated.slug || slugify(updated.name || '');
      const existing = poiMarkers.find(poi => (poi.slug || slugify(poi.name || '')) === slugKey);
      if (existing) {
        Object.assign(existing, updated);
      } else {
        poiMarkers.push(updated);
      }
      const baseItem = baseSlug
        ? basePoiLayers.find(item => slugify(item.layer?.options?.slug || item.name || '') === baseSlug)
        : basePoiLayers.find(item => slugify(item.layer?.options?.slug || item.name || '') === slugKey);
      if (baseItem) {
        const iconPath = getPoiIconForCategory(updated.category || baseItem.layer?.options?.category);
        baseItem.layer?.setIcon?.(L.icon({ iconUrl: iconPath, iconSize: [22, 22], iconAnchor: [11, 22] }));
        const elevationLabel = updated.elevation ? `${updated.elevation} ft` : '';
        const popupHtml = [
          `<strong>${baseItem.name}</strong>`,
          updated.category || baseItem.layer?.options?.category || '',
          elevationLabel,
          updated.description || ''
        ].filter(Boolean).join('<br>');
        baseItem.layer?.bindPopup?.(popupHtml);
      }
      redrawOverlays();
      updatePoiListCoordinates(slugKey, updated.lat, updated.lon);
    }

    function buildPoiList() {
      const container = document.getElementById('poi-list-container');
      if (!container) return;
      container.innerHTML = '';

      const editedBySlug = new Map(
        poiMarkers.map(item => [item.slug || slugify(item.name || ''), item])
      );
      const baseSlugs = new Set();

      basePoiLayers.forEach(item => {
        const base = getBasePoiData(item);
        const baseSlug = base.slug || slugify(base.name || '');
        if (!baseSlug) return;
        baseSlugs.add(baseSlug);
        const edit = editedBySlug.get(baseSlug);
        const markerLatLng = item.layer.getLatLng();
        const poi = {
          ...base,
          ...edit,
          slug: base.slug || edit?.slug || baseSlug,
          elevation: edit?.elevation ?? base.elevation ?? null,
          imageUrls: edit?.imageUrls?.length ? edit.imageUrls : base.imageUrls || [],
          lat: edit?.lat ?? markerLatLng.lat,
          lon: edit?.lon ?? markerLatLng.lng
        };
        renderPoiRow(container, poi, { isBase: true, baseSlug });
      });

      poiMarkers.forEach(item => {
        const slug = item.slug || slugify(item.name || '');
        if (baseSlugs.has(slug)) return;
        renderPoiRow(container, item);
      });
    }

    function syncBasePoiLayers() {
      if (!basePoiLayers.length) return;
      basePoiLayers.forEach(item => {
        const edit = poiMarkers.find(poi => poi.name === item.name);
        if (!edit || typeof edit.lat !== 'number' || typeof edit.lon !== 'number') return;
        item.layer.setLatLng([edit.lat, edit.lon]);
      });
    }

    function getPoiFeatureProperties(item) {
      const base = basePoiDataByName.get(item.name) || {};
      const elevation = item.elevation ?? base.elevation_ft ?? base.elevation ?? null;
      const baseSlug = base.slug || slugify(base.name || '');
      const itemSlug = item.slug || slugify(item.name || '');
      const imageUrls = mergeImageUrls(
        getPoiImageUrls(base, baseSlug),
        Array.isArray(item.imageUrls) ? item.imageUrls : getPoiImageUrls(item, itemSlug)
      ).map(url => url.trim()).filter(Boolean);
      const props = {
        name: item.name || base.name || '',
        category: item.category || base.category || '',
        description: item.description || base.description || ''
      };
      const slug = item.slug || base.slug || (props.name ? slugify(props.name) : '');
      if (slug) props.slug = slug;
      if (typeof elevation === 'number' && !Number.isNaN(elevation)) {
        props.elevation_ft = elevation;
      }
      if (imageUrls.length) {
        props.image_urls = imageUrls;
      }
      return props;
    }

    function buildGeoJson() {
      const statusFeatures = statusSegments.map(seg => ({
        type: 'Feature',
        properties: { status: seg.status },
        geometry: { type: 'LineString', coordinates: seg.coords.map(coord => [coord[1], coord[0]]) }
      }));
      const blowdownFeatures = blowdownMarkers.map(item => ({
        type: 'Feature',
        properties: {
          type: 'blowdown',
          size: item.size,
          passable: item.passable,
          tool: item.tool,
          description: item.description
        },
        geometry: { type: 'Point', coordinates: [item.lon, item.lat] }
      }));
      const signFeatures = signMarkers.map(item => ({
        type: 'Feature',
        properties: {
          type: 'sign',
          subtype: item.subtype,
          junction: item.junction,
          direction: item.direction,
          text: item.text,
          description: item.description
        },
        geometry: { type: 'Point', coordinates: [item.lon, item.lat] }
      }));
      const drainageFeaturesFC = drainageFeatures.map(item => ({
        type: 'Feature',
        properties: {
          type: 'drain',
          subtype: item.subtype,
          condition: item.condition,
          last_worked: item.last_worked,
          notes: item.notes
        },
        geometry: { type: 'Point', coordinates: [item.lon, item.lat] }
      }));
      const bogBridgeFeatures = bogBridges.map(item => ({
        type: 'Feature',
        properties: {
          type: 'bog_bridge',
          subtype: item.subtype,
          length_ft: item.length_ft,
          condition: item.condition,
          hazard: item.hazard
        },
        geometry: { type: 'LineString', coordinates: item.coords.map(coord => [coord[1], coord[0]]) }
      }));
      const stoneworkFeatures = stoneworkSegments.map(item => ({
        type: 'Feature',
        properties: {
          type: 'stonework',
          subtype: item.subtype,
          condition: item.condition,
          notes: item.notes
        },
        geometry: { type: 'LineString', coordinates: item.coords.map(coord => [coord[1], coord[0]]) }
      }));
      const treadFeatures = treadConditions.map(item => ({
        type: 'Feature',
        properties: { type: 'tread', status: item.status, notes: item.notes },
        geometry: { type: 'LineString', coordinates: item.coords.map(coord => [coord[1], coord[0]]) }
      }));
      const encroachmentFeatures = encroachments.map(item => ({
        type: 'Feature',
        properties: { type: 'encroachment', side: item.side, notes: item.notes },
        geometry: { type: 'LineString', coordinates: item.coords.map(coord => [coord[1], coord[0]]) }
      }));
      const hazardFeatures = hazardMarkers.map(item => ({
        type: 'Feature',
        properties: {
          type: 'hazard',
          subtype: item.subtype,
          severity: item.severity,
          seasonal: item.seasonal,
          description: item.description
        },
        geometry: { type: 'Point', coordinates: [item.lon, item.lat] }
      }));
      const cairnFeatures = cairnMarkers.map(item => ({
        type: 'Feature',
        properties: { type: 'cairn', status: item.status, notes: item.notes },
        geometry: { type: 'Point', coordinates: [item.lon, item.lat] }
      }));
      const poiFeatures = poiMarkers.map(item => ({
        type: 'Feature',
        properties: getPoiFeatureProperties(item),
        geometry: { type: 'Point', coordinates: [item.lon, item.lat] }
      }));
      return {
        status: { type: 'FeatureCollection', features: statusFeatures },
        blowdowns: { type: 'FeatureCollection', features: blowdownFeatures },
        signs: { type: 'FeatureCollection', features: signFeatures },
        drainage: { type: 'FeatureCollection', features: drainageFeaturesFC },
        bogBridges: { type: 'FeatureCollection', features: bogBridgeFeatures },
        stonework: { type: 'FeatureCollection', features: stoneworkFeatures },
        tread: { type: 'FeatureCollection', features: treadFeatures },
        encroachments: { type: 'FeatureCollection', features: encroachmentFeatures },
        hazards: { type: 'FeatureCollection', features: hazardFeatures },
        cairns: { type: 'FeatureCollection', features: cairnFeatures },
        pois: { type: 'FeatureCollection', features: poiFeatures }
      };
    }

    async function saveToServer() {
      const password = prompt('Enter editing password:');
      if (!password) return;
      const geo = buildGeoJson();
      const payload = { password, ...geo };

      setStatusMessage('Saving edits...');
      try {
        const res = await fetch(SAVE_ENDPOINT, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        const out = await res.json();
        if (res.ok && out.ok) {
          setStatusMessage('Saved successfully.');
        } else {
          setStatusMessage(out.error || 'Error saving edits.', true);
        }
      } catch (err) {
        setStatusMessage('Save failed.', true);
      }
    }

    function downloadJson() {
      const geo = buildGeoJson();
      const blob = new Blob([JSON.stringify(geo, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = 'howker-ridge-edits.json';
      document.body.appendChild(link);
      link.click();
      link.remove();
      URL.revokeObjectURL(url);
    }

    function buildCardMeta() {
      const brushed = statusSegments.filter(s => s.status === 'green').length;
      const needs = statusSegments.filter(s => s.status !== 'green').length;
      const blowdowns = poiMarkers.filter(p => p.type === 'blowdown').length || blowdownMarkers.length;
      const signs = poiMarkers.filter(p => p.type === 'sign').length || signMarkers.length;
      const bounds = trailMeta?.bounds;
      const bbox = bounds
        ? [bounds.getSouthWest().lng, bounds.getSouthWest().lat, bounds.getNorthEast().lng, bounds.getNorthEast().lat]
        : null;

      return {
        title: trailMeta?.name || 'Howker Ridge Trail',
        subtitle: 'Mount Madison • White Mountain National Forest',
        stats: [
          '~4.5 mi one-way',
          '~4,750 ft gain',
          'Strenuous'
        ],
        edits: { brushed, needs, blowdowns, signs },
        createdAt: new Date().toISOString(),
        page: 'https://nh48.info/projects/howker-map-editor',
        poiCount: trailMeta?.poiCount || 0,
        bbox
      };
    }

    function updateShareCardOverlay() {
      const overlay = document.getElementById('shareCardOverlay');
      if (!overlay) return;
      const meta = buildCardMeta();
      const orientation = document.getElementById('cardOrientation')?.value || 'landscape';
      overlay.classList.toggle('portrait', orientation === 'portrait');
      overlay.innerHTML = `
        <div class="share-card-content">
          <div class="trail-title">${meta.title}</div>
          <div class="trail-subtitle">${meta.subtitle}</div>
          <div class="trail-stats">
            ${meta.stats.map(stat => `<span>${stat}</span>`).join('')}
          </div>
        </div>
      `;
    }

    function openShareCardModal() {
      const modal = document.getElementById('shareCardModal');
      const urlEl = document.getElementById('shareCardUrl');
      if (!modal || !urlEl) return;
      urlEl.textContent = '—';
      urlEl.href = '#';
      modal.hidden = false;
      modal.addEventListener('click', event => {
        if (event.target === modal) {
          modal.hidden = true;
        }
      }, { once: true });
      const closeBtn = document.getElementById('shareCardClose');
      if (closeBtn) closeBtn.onclick = () => (modal.hidden = true);
      modal.querySelectorAll('.step').forEach(step => {
        step.classList.remove('ok', 'fail');
        const msg = step.querySelector('.msg');
        if (msg) msg.textContent = 'Pending…';
      });
    }

    function setStep(step, ok, msg) {
      const modal = document.getElementById('shareCardModal');
      if (!modal) return;
      const row = modal.querySelector(`.step[data-step="${step}"]`);
      if (!row) return;
      row.classList.remove('ok', 'fail');
      row.classList.add(ok ? 'ok' : 'fail');
      const msgEl = row.querySelector('.msg');
      if (msgEl) msgEl.textContent = msg || (ok ? 'OK' : 'Failed');
    }

    function waitForMapIdle(timeoutMs = 12000) {
      return new Promise(resolve => {
        let done = false;
        const finish = () => {
          if (done) return;
          done = true;
          cleanup();
          resolve(true);
        };
        const cleanup = () => {
          map.off('load', bump);
          map.off('tileload', bump);
          map.off('tileerror', bump);
        };
        let t;
        const bump = () => {
          clearTimeout(t);
          t = setTimeout(finish, 400);
        };
        map.on('load', bump);
        map.on('tileload', bump);
        map.on('tileerror', bump);
        bump();
        setTimeout(finish, timeoutMs);
      });
    }

    function roundRect(ctx, x, y, w, h, r) {
      const radius = Math.min(r, w / 2, h / 2);
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.arcTo(x + w, y, x + w, y + h, radius);
      ctx.arcTo(x + w, y + h, x, y + h, radius);
      ctx.arcTo(x, y + h, x, y, radius);
      ctx.arcTo(x, y, x + w, y, radius);
      ctx.closePath();
    }

    function drawWrappedText(ctx, text, x, y, maxW, lineH) {
      const words = String(text || '').split(/\s+/).filter(Boolean);
      let line = '';
      for (let i = 0; i < words.length; i += 1) {
        const test = line ? `${line} ${words[i]}` : words[i];
        const w = ctx.measureText(test).width;
        if (w > maxW && line) {
          ctx.fillText(line, x, y);
          y += lineH;
          line = words[i];
        } else {
          line = test;
        }
      }
      if (line) {
        ctx.fillText(line, x, y);
        y += lineH;
      }
      return y;
    }

    function drawLegendOnCanvas(canvas, meta, exportW, exportH, orientation) {
      const ctx = canvas.getContext('2d');
      const pad = Math.round(exportW * 0.04);
      const gradientRatio = orientation === 'portrait' ? 0.5 : 0.4;
      const gradientHeight = Math.round(exportH * gradientRatio);
      const gradientStart = exportH - gradientHeight;

      ctx.save();
      const gradient = ctx.createLinearGradient(0, gradientStart, 0, exportH);
      gradient.addColorStop(0, 'rgba(0,0,0,0)');
      gradient.addColorStop(1, 'rgba(0,0,0,0.65)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, gradientStart, exportW, gradientHeight);

      const titleSize = Math.max(44, Math.round(exportW * 0.03));
      const subSize = Math.max(22, Math.round(exportW * 0.015));
      const statSize = Math.max(20, Math.round(exportW * 0.013));

      const statLineHeight = Math.round(statSize * 1.4);
      const statsHeight = orientation === 'portrait'
        ? meta.stats.length * statLineHeight
        : Math.round(statSize * 2);
      const totalHeight = titleSize + subSize + statsHeight + Math.round(pad * 0.6);
      let y = exportH - pad - totalHeight;

      ctx.fillStyle = '#ffffff';
      ctx.font = `700 ${titleSize}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
      y = drawWrappedText(ctx, meta.title, pad, y, exportW - pad * 2, titleSize + 6);

      ctx.fillStyle = '#d1e5ff';
      ctx.font = `600 ${subSize}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
      y += Math.round(subSize * 0.4);
      y = drawWrappedText(ctx, meta.subtitle, pad, y, exportW - pad * 2, subSize + 4);

      y += Math.round(subSize * 0.6);
      ctx.font = `600 ${statSize}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
      if (orientation === 'portrait') {
        ctx.fillStyle = '#ffffff';
        meta.stats.forEach(stat => {
          ctx.fillText(stat, pad, y + statSize);
          y += statLineHeight;
        });
      } else {
        const badgeHeight = Math.round(statSize * 1.8);
        const badgePadX = Math.round(statSize * 1.2);
        const badgeGap = Math.round(statSize * 0.6);
        let bx = pad;
        meta.stats.forEach(stat => {
          const badgeW = ctx.measureText(stat).width + badgePadX * 2;
          ctx.fillStyle = 'rgba(0,0,0,0.45)';
          roundRect(ctx, bx, y, badgeW, badgeHeight, 999);
          ctx.fill();
          ctx.fillStyle = '#ffffff';
          ctx.fillText(stat, bx + badgePadX, y + Math.round(badgeHeight * 0.68));
          bx += badgeW + badgeGap;
        });
      }

      ctx.restore();
    }

    async function generateShareCard() {
      openShareCardModal();
      const pw = prompt('Enter HOWKER_MAP_PW to upload the share card:');
      if (!pw) {
        setStep('render', false, 'Cancelled (no password).');
        return;
      }

      const resSel = document.getElementById('cardRes')?.value || '4k';
      const orientation = document.getElementById('cardOrientation')?.value || 'landscape';
      const baseW = resSel === '8k' ? 7680 : 4096;
      const baseH = resSel === '8k' ? 4320 : 2304;
      const exportW = orientation === 'portrait' ? baseH : baseW;
      const exportH = orientation === 'portrait' ? baseW : baseH;
      const mapW = orientation === 'landscape' ? exportH : exportW;
      const mapH = orientation === 'landscape' ? exportW : exportH;
      const mapEl = document.getElementById('map');
      const wrapEl = mapEl?.parentElement;

      if (!mapEl || !wrapEl) {
        setStep('render', false, 'Map container not found.');
        return;
      }

      const prev = {
        mapW: mapEl.style.width,
        mapH: mapEl.style.height,
        wrapW: wrapEl.style.width,
        wrapH: wrapEl.style.height
      };

      try {
        setStep('render', true, `Preparing ${exportW}×${exportH} export…`);
        const paddingSize = Math.round(Math.min(mapW, mapH) * 0.06);
        const boundsGroup = L.featureGroup([baseTrailLayer, drawnLayers].filter(Boolean));
        const bounds = boundsGroup.getBounds?.();
        if (bounds && bounds.isValid()) {
          map.fitBounds(bounds, {
            padding: [paddingSize, paddingSize]
          });
        }

        await waitForMapIdle(15000);

        const sourceCanvas = await new Promise((resolve, reject) => {
          window.leafletImage(map, (err, c) => {
            if (err) reject(err);
            else resolve(c);
          });
        });

        const meta = buildCardMeta();
        const scaledCanvas = document.createElement('canvas');
        scaledCanvas.width = mapW;
        scaledCanvas.height = mapH;
        const scaledCtx = scaledCanvas.getContext('2d');
        scaledCtx.imageSmoothingEnabled = true;
        scaledCtx.drawImage(
          sourceCanvas,
          0, 0, sourceCanvas.width, sourceCanvas.height,
          0, 0, mapW, mapH
        );

        let exportCanvas = scaledCanvas;
        if (orientation === 'landscape') {
          const rotated = document.createElement('canvas');
          rotated.width = exportW;
          rotated.height = exportH;
          const rctx = rotated.getContext('2d');
          rctx.imageSmoothingEnabled = true;
          rctx.save();
          rctx.translate(exportW, 0);
          rctx.rotate(Math.PI / 2);
          rctx.drawImage(scaledCanvas, 0, 0, mapW, mapH);
          rctx.restore();
          exportCanvas = rotated;
        }
        drawLegendOnCanvas(exportCanvas, meta, exportW, exportH, orientation);

        const blob = await new Promise(resolve => {
          exportCanvas.toBlob(b => resolve(b), 'image/jpeg', 0.92);
        });

        if (!blob) {
          throw new Error('Unable to encode JPG.');
        }

        const stamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
        const filename = `howker-ridge-map-card-${orientation}-${resSel}-${stamp}.jpg`;
        const dlUrl = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = dlUrl;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        link.remove();
        URL.revokeObjectURL(dlUrl);
        setStep('download', true, `Downloaded: ${filename}`);

        const fd = new FormData();
        fd.append('password', pw);
        fd.append('meta', JSON.stringify(meta));
        fd.append('file', blob, filename);

        const upRes = await fetch(CARD_UPLOAD_ENDPOINT, { method: 'POST', body: fd });
        const upJson = await upRes.json().catch(() => ({}));

        if (!upRes.ok || !upJson.ok) {
          throw new Error(upJson?.error || `Upload failed (${upRes.status}).`);
        }

        setStep('upload', true, `Stored key: ${upJson.key}`);
        const remoteUrl = upJson.url;
        const urlEl = document.getElementById('shareCardUrl');
        if (urlEl) {
          urlEl.textContent = remoteUrl;
          urlEl.href = remoteUrl;
        }

        const headRes = await fetch(remoteUrl, { method: 'HEAD' });
        setStep('head', headRes.ok, headRes.ok ? 'HEAD 200 OK' : `HEAD failed (${headRes.status})`);

        const getRes = await fetch(remoteUrl, { method: 'GET' });
        setStep('get', getRes.ok, getRes.ok ? 'GET 200 OK (image retrievable)' : `GET failed (${getRes.status})`);
      } catch (err) {
        setStep('render', false, err?.message || 'Export failed.');
        console.error(err);
      } finally {
        mapEl.style.width = prev.mapW;
        mapEl.style.height = prev.mapH;
        wrapEl.style.width = prev.wrapW;
        wrapEl.style.height = prev.wrapH;
        map.invalidateSize(true);
      }
    }

    function openTopoArtModal() {
      const modal = document.getElementById('topoArtModal');
      if (!modal) return;
      modal.hidden = false;
      modal.addEventListener('click', event => {
        if (event.target === modal) {
          modal.hidden = true;
        }
      }, { once: true });
    }

    function closeTopoArtModal() {
      const modal = document.getElementById('topoArtModal');
      if (modal) modal.hidden = true;
    }

    async function generateTopoArt(theme, resolution) {
      const mapEl = document.getElementById('map');
      const wrapEl = mapEl?.parentElement;
      if (!mapEl || !wrapEl) {
        setStatusMessage('Map container not found for Topo Art export.', true);
        return;
      }

      const originalSize = map.getSize();
      const targetWidth = resolution === '8k' ? 7680 : 3840;
      const targetHeight = Math.round(targetWidth * originalSize.y / originalSize.x);

      try {
        setStatusMessage(`Rendering Topo Art (${targetWidth}×${targetHeight})...`);
        await waitForMapIdle(15000);

        const sourceCanvas = await new Promise((resolve, reject) => {
          window.leafletImage(map, (err, c) => {
            if (err) reject(err);
            else resolve(c);
          });
        });

        const exportCanvas = document.createElement('canvas');
        exportCanvas.width = targetWidth;
        exportCanvas.height = targetHeight;
        const exportCtx = exportCanvas.getContext('2d');
        exportCtx.imageSmoothingEnabled = true;
        exportCtx.drawImage(
          sourceCanvas,
          0, 0, sourceCanvas.width, sourceCanvas.height,
          0, 0, targetWidth, targetHeight
        );

        processTopoArtImage(exportCanvas, theme);

        const stamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
        const filename = `topo-art-${theme}-${resolution}-${stamp}.png`;
        const blob = await new Promise(resolve => exportCanvas.toBlob(resolve, 'image/png'));
        if (!blob) {
          throw new Error('Unable to encode PNG.');
        }
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        link.remove();
        URL.revokeObjectURL(url);
        setStatusMessage(`Topo Art downloaded: ${filename}`);
      } catch (err) {
        setStatusMessage(err?.message || 'Topo Art export failed.', true);
        console.error(err);
      }
    }

    function processTopoArtImage(canvas, theme) {
      const ctx = canvas.getContext('2d');
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      for (let i = 0; i < data.length; i += 4) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        if (theme === 'dark') {
          if (r > 240 && g > 240 && b > 240) {
            data[i] = data[i + 1] = data[i + 2] = 255;
          } else {
            data[i] = data[i + 1] = data[i + 2] = 0;
          }
        } else {
          if (r < 20 && g < 20 && b < 20) {
            data[i] = data[i + 1] = data[i + 2] = 0;
          } else {
            data[i] = data[i + 1] = data[i + 2] = 255;
          }
        }
      }
      ctx.putImageData(imageData, 0, 0);
    }

    function undoLast() {
      const last = historyStack.pop();
      if (!last) {
        setStatusMessage('Nothing to undo.');
        return;
      }
      if (last.type === 'status') {
        statusSegments.pop();
      } else if (last.type === 'bog_bridge') {
        bogBridges.pop();
      } else if (last.type === 'stonework') {
        stoneworkSegments.pop();
      } else if (last.type === 'tread') {
        treadConditions.pop();
      } else if (last.type === 'encroachment') {
        encroachments.pop();
      } else if (last.type === 'blowdown') {
        blowdownMarkers.pop();
      } else if (last.type === 'sign') {
        signMarkers.pop();
      } else if (last.type === 'drainage') {
        drainageFeatures.pop();
      } else if (last.type === 'hazard') {
        hazardMarkers.pop();
      } else if (last.type === 'cairn') {
        cairnMarkers.pop();
      } else if (last.type === 'poi') {
        poiMarkers.pop();
      }
      redrawOverlays();
      setStatusMessage('Undid last edit.');
    }

    function enablePolylineDrawing(lineType) {
      currentLineType = lineType;
      setActiveTool('line');
      let color = '#4ade80';
      if (lineType === 'brush_yellow') {
        color = '#fbbf24';
      } else if (lineType === 'bog_bridge') {
        color = '#8b5cf6';
      } else if (lineType === 'stonework') {
        color = '#94a3b8';
      } else if (lineType === 'tread') {
        color = '#f97316';
      } else if (lineType === 'encroachment') {
        color = '#ef4444';
      }
      drawControl.setDrawingOptions({
        polyline: { shapeOptions: { color, weight: 6, opacity: 0.85 }, repeatMode: true }
      });
      drawControl._toolbars.draw._modes.polyline.handler.enable();
      updateBrushEditing();
    }

    function completePolyline() {
      const polyHandler = drawControl?._toolbars?.draw?._modes?.polyline?.handler;
      if (!polyHandler) return;
      if (typeof polyHandler.completeShape === 'function') {
        polyHandler.completeShape();
      } else if (typeof polyHandler._finishShape === 'function') {
        polyHandler._finishShape();
      }
    }

    function showFinishButton(latlng) {
      if (!finishBtn) {
        finishBtn = L.DomUtil.create('button', 'finish-segment-btn', map.getContainer());
        finishBtn.innerText = 'End segment';
        finishBtn.type = 'button';
        finishBtn.addEventListener('click', () => {
          completePolyline();
          finishBtn.style.display = 'none';
        });
      }
      const point = map.latLngToContainerPoint(latlng);
      finishBtn.style.left = `${point.x + 8}px`;
      finishBtn.style.top = `${point.y + 8}px`;
      finishBtn.style.display = 'block';
    }

    function enableMarkerDrawing(type) {
      currentMarkerType = type;
      currentLineType = null;
      setActiveTool('marker');
      updateBrushEditing();
      const iconUrl = editIcons[type] || editIcons.sign;
      drawControl._toolbars.draw._modes.marker.handler.setOptions({
        icon: L.icon({ iconUrl, iconSize: [26, 26], iconAnchor: [13, 26] })
      });
      drawControl._toolbars.draw._modes.marker.handler.enable();
      if (finishBtn) finishBtn.style.display = 'none';
    }

    function updateSearchIndex() {
      searchIndex.length = 0;
      basePoiLayers.forEach(item => searchIndex.push(item));
      poiMarkers.forEach(item => {
        if (item.name && item._marker) {
          searchIndex.push({ name: item.name, layer: item._marker });
        }
      });
      updateSearchSuggestions();
    }

    function updateSearchSuggestions() {
      const datalist = document.getElementById('searchSuggestions');
      if (!datalist) return;
      datalist.innerHTML = '';
      searchIndex
        .slice()
        .sort((a, b) => a.name.localeCompare(b.name))
        .forEach(item => {
          const option = document.createElement('option');
          option.value = item.name;
          datalist.appendChild(option);
        });
    }

    function highlightSearchResult(latlng) {
      if (highlightLayer) {
        map.removeLayer(highlightLayer);
      }
      highlightLayer = L.circleMarker(latlng, {
        radius: 10,
        color: '#22c55e',
        weight: 3,
        fillColor: '#86efac',
        fillOpacity: 0.4
      }).addTo(map);
    }

    function getLayerLatLng(layer) {
      if (!layer) return null;
      if (layer.getLatLng) return layer.getLatLng();
      if (layer.getBounds) return layer.getBounds().getCenter();
      return null;
    }

    function performSearch(query) {
      const trimmed = query.trim();
      if (!trimmed) {
        setStatusMessage('Enter a feature name to search.', true);
        return;
      }
      const lower = trimmed.toLowerCase();
      const match = searchIndex.find(item => item.name.toLowerCase() === lower)
        || searchIndex.find(item => item.name.toLowerCase().includes(lower));
      if (!match) {
        setStatusMessage('No matching trail feature or POI found.', true);
        return;
      }
      const targetLatLng = getLayerLatLng(match.layer);
      if (!targetLatLng) {
        setStatusMessage('Unable to locate that feature on the map.', true);
        return;
      }
      map.flyTo([targetLatLng.lat, targetLatLng.lng], 15);
      if (match.layer.openPopup) {
        match.layer.openPopup();
      }
      highlightSearchResult(targetLatLng);
      setStatusMessage(`Found: ${match.name}`);
    }

    function locateUser() {
      if (!navigator.geolocation) {
        setStatusMessage('Geolocation is not supported in this browser.', true);
        return;
      }
      setStatusMessage('Locating you...');
      navigator.geolocation.getCurrentPosition(
        position => {
          const { latitude, longitude } = position.coords;
          map.flyTo([latitude, longitude], 15);
          setStatusMessage('Location found.');
        },
        error => {
          setStatusMessage(error.message || 'Unable to retrieve location.', true);
        },
        { enableHighAccuracy: true, timeout: 10000 }
      );
    }

    document.addEventListener('DOMContentLoaded', () => {
      initMap();
      const adjustPoiBtn = document.getElementById('adjustPoiBtn');
      const poiFormModal = document.getElementById('poiFormModal');
      const poiForm = document.getElementById('poiForm');
      const poiAddBtn = document.querySelector('.tool-btn[data-marker-type="poi"]');
      const poiNameInput = document.getElementById('poiNameInput');
      const poiSlugInput = document.getElementById('poiSlugInput');
      const poiCategoryInput = document.getElementById('poiCategoryInput');
      const poiElevationInput = document.getElementById('poiElevationInput');
      const poiDescriptionInput = document.getElementById('poiDescriptionInput');
      const poiImageList = document.getElementById('poiImageList');
      const poiAddImageBtn = document.getElementById('poiAddImageBtn');
      const poiCancelBtn = document.getElementById('poiCancelBtn');
      const topoArtBtn = document.getElementById('topoArtBtn');
      const topoArtClose = document.getElementById('topoArtClose');
      const topoArtCancel = document.getElementById('topoArtCancel');
      const generateTopoArtBtn = document.getElementById('generateTopoArt');

      if (poiImageList && !poiImageList.querySelector('.poi-image-row')) {
        buildPoiImageRow(poiImageList, '');
      }
      if (poiAddImageBtn && poiImageList) {
        poiAddImageBtn.addEventListener('click', () => buildPoiImageRow(poiImageList, ''));
      }

      document.querySelectorAll('.tool.dropdown > .tool-btn').forEach(button => {
        button.addEventListener('click', event => {
          event.stopPropagation();
          const parent = button.parentElement;
          parent.classList.toggle('open');
          document.querySelectorAll('.tool.dropdown').forEach(other => {
            if (other !== parent) other.classList.remove('open');
          });
        });
      });
      document.addEventListener('click', event => {
        if (!event.target.closest('.tool.dropdown')) {
          document.querySelectorAll('.tool.dropdown').forEach(drop => drop.classList.remove('open'));
        }
      });
      document.querySelectorAll('.tool-btn[data-line-type]').forEach(button => {
        button.addEventListener('click', () => {
          const type = button.getAttribute('data-line-type');
          enablePolylineDrawing(type);
          document.querySelectorAll('.tool-btn[data-line-type]').forEach(item => item.classList.remove('active'));
          document.querySelectorAll('.tool-btn[data-marker-type]').forEach(item => item.classList.remove('active'));
          if (adjustPoiBtn) adjustPoiBtn.classList.remove('active');
          button.classList.add('active');
          const dropdown = button.closest('.tool.dropdown');
          if (dropdown) dropdown.classList.remove('open');
        });
      });
      document.querySelectorAll('.tool-btn[data-marker-type]').forEach(button => {
        button.addEventListener('click', () => {
          const type = button.getAttribute('data-marker-type');
          document.querySelectorAll('.tool-btn[data-marker-type]').forEach(item => item.classList.remove('active'));
          document.querySelectorAll('.tool-btn[data-line-type]').forEach(item => item.classList.remove('active'));
          if (adjustPoiBtn) adjustPoiBtn.classList.remove('active');
          button.classList.add('active');
          if (type === 'poi') {
            setActiveTool('poi-add');
            openPoiFormModal();
          } else {
            enableMarkerDrawing(type);
          }
        });
      });
      if (adjustPoiBtn) {
        adjustPoiBtn.addEventListener('click', () => {
          if (currentTool === 'adjust-poi') {
            adjustPoiBtn.classList.remove('active');
            setActiveTool(null);
            setStatusMessage('Adjust mode off.');
            return;
          }
          document.querySelectorAll('.tool-btn[data-marker-type]').forEach(item => item.classList.remove('active'));
          document.querySelectorAll('.tool-btn[data-line-type]').forEach(item => item.classList.remove('active'));
          adjustPoiBtn.classList.add('active');
          setActiveTool('adjust-poi');
          setStatusMessage('Adjust mode: drag any glowing POI marker or edit coordinates below.');
        });
      }
      if (poiFormModal) {
        poiFormModal.addEventListener('click', event => {
          if (event.target?.dataset?.action === 'close') {
            closePoiFormModal();
            resetPoiForm();
            if (poiAddBtn) poiAddBtn.classList.remove('active');
            setActiveTool(null);
          }
        });
      }
      if (poiCancelBtn) {
        poiCancelBtn.addEventListener('click', () => {
          closePoiFormModal();
          resetPoiForm();
          if (poiAddBtn) poiAddBtn.classList.remove('active');
          setActiveTool(null);
          setStatusMessage('POI creation canceled.');
        });
      }
      if (poiNameInput && poiSlugInput) {
        poiNameInput.addEventListener('input', () => {
          if (poiSlugTouched) return;
          poiSlugInput.value = slugify(poiNameInput.value.trim());
        });
        poiSlugInput.addEventListener('input', () => {
          poiSlugTouched = true;
        });
      }
      if (poiForm) {
        poiForm.addEventListener('submit', event => {
          event.preventDefault();
          clearPoiFormError();
          const name = poiNameInput?.value.trim() || '';
          const slug = poiSlugInput?.value.trim() || '';
          const elevationValue = poiElevationInput?.value ? Number(poiElevationInput.value) : null;
          const imageUrls = Array.from(poiImageList?.querySelectorAll('input') || [])
            .map(input => input.value.trim())
            .filter(Boolean);

          if (!name) {
            showPoiFormError('Name is required to add a POI.');
            return;
          }
          if (!slug) {
            showPoiFormError('Slug is required to add a POI.');
            return;
          }
          if (Number.isNaN(elevationValue)) {
            showPoiFormError('Elevation must be a valid number.');
            return;
          }

          const nameSet = getPoiNames();
          const slugSet = getPoiSlugs();
          if (nameSet.has(name.toLowerCase())) {
            showPoiFormError('That name is already in use. Choose a unique name.');
            return;
          }
          if (slugSet.has(slug.toLowerCase())) {
            showPoiFormError('That slug is already in use. Choose a unique slug.');
            return;
          }

          pendingPoiData = {
            name,
            slug,
            category: poiCategoryInput?.value || '',
            elevation: elevationValue,
            description: poiDescriptionInput?.value.trim() || '',
            imageUrls
          };
          closePoiFormModal();
          setStatusMessage('Click the map to place the new POI.');
        });
      }

      map.on('click', event => {
        if (currentTool !== 'poi-add' || !pendingPoiData) return;
        const latlng = event.latlng;
        const newPoi = {
          ...pendingPoiData,
          lat: latlng.lat,
          lon: latlng.lng
        };
        poiMarkers.push(newPoi);
        historyStack.push({ type: 'poi' });
        pendingPoiData = null;
        resetPoiForm();
        redrawOverlays();
        buildPoiList();
        setStatusMessage(`Added POI: ${newPoi.name}`);
      });
      document.getElementById('saveBtn').addEventListener('click', saveToServer);
      document.getElementById('downloadBtn').addEventListener('click', downloadJson);
      document.getElementById('loadEditsBtn').addEventListener('click', loadExistingEdits);
      document.getElementById('undoBtn').addEventListener('click', undoLast);
      document.getElementById('locateBtn').addEventListener('click', locateUser);
      document.getElementById('shareCardBtn').addEventListener('click', generateShareCard);
      if (topoArtBtn) {
        topoArtBtn.addEventListener('click', openTopoArtModal);
      }
      if (topoArtClose) {
        topoArtClose.addEventListener('click', closeTopoArtModal);
      }
      if (topoArtCancel) {
        topoArtCancel.addEventListener('click', closeTopoArtModal);
      }
      if (generateTopoArtBtn) {
        generateTopoArtBtn.addEventListener('click', async () => {
          const theme = document.querySelector('input[name="topoTheme"]:checked')?.value || 'dark';
          const resolution = document.getElementById('topoResolution')?.value || '4k';
          closeTopoArtModal();
          await generateTopoArt(theme, resolution);
        });
      }
      const cardOrientation = document.getElementById('cardOrientation');
      if (cardOrientation) {
        cardOrientation.addEventListener('change', updateShareCardOverlay);
      }
      const searchInput = document.getElementById('searchInput');
      document.getElementById('searchBtn').addEventListener('click', () => performSearch(searchInput.value));
      searchInput.addEventListener('keydown', event => {
        if (event.key === 'Enter') {
          event.preventDefault();
          performSearch(searchInput.value);
        }
      });
    });
  </script>
</body>
</html>
