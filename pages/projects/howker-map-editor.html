<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <!-- Favicons - ICO format preferred for Google compatibility -->
  <link rel="icon" href="/favicons/favicon.ico" sizes="48x48" />
  <link rel="icon" type="image/x-icon" href="/favicons/favicon.ico" />
  <link rel="shortcut icon" href="/favicons/favicon.ico" />
  <link rel="icon" type="image/x-icon" sizes="16x16" href="/favicons/favicon-16x16.ico" />
  <link rel="icon" type="image/x-icon" sizes="32x32" href="/favicons/favicon-32x32.ico" />
  <link rel="icon" type="image/x-icon" sizes="48x48" href="/favicons/favicon-48x48.ico" />
  <link rel="icon" type="image/x-icon" sizes="96x96" href="/favicons/favicon-96x96.ico" />
  <!-- PNG fallbacks for browsers that prefer PNG -->
  <link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32.png" />
  <link rel="icon" type="image/png" sizes="48x48" href="/favicons/favicon-48.png" />
  <link rel="icon" type="image/png" sizes="96x96" href="/favicons/favicon-96.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png" />
  <link rel="manifest" href="/manifest.json" />
  <title>Howker Ridge Map Editor</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
  <script src="/js/unified-footer.js" defer></script>
  <style>
    :root {
      --bg: #0b0b0f;
      --panel: #12121a;
      --card: #1c1f2a;
      --ink: #f9fafb;
      --muted: #94a3b8;
      --border: #263042;
      --accent: #22c55e;
      --accent-warn: #fbbf24;
      --accent-danger: #ef4444;
    }
    body.light {
      --bg: #f8fafc;
      --panel: #ffffff;
      --card: #f1f5f9;
      --ink: #0f172a;
      --muted: #64748b;
      --border: #e2e8f0;
      --accent: #16a34a;
      --accent-warn: #f59e0b;
      --accent-danger: #dc2626;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--ink);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      min-height: 100vh;
    }
    .wrap {
      max-width: 1200px;
      margin: 0 auto;
      padding: 16px;
    }
    h1 {
      margin: 0 0 8px;
      font-size: clamp(24px, 3vw, 34px);
    }
    p {
      margin: 0 0 16px;
      color: var(--muted);
      line-height: 1.6;
    }
    .toolbar.large {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      padding: 16px;
      border-radius: 12px;
      background: var(--panel);
      border: 1px solid var(--border);
      align-items: center;
      min-height: 100px;
    }
    .tool-group {
      display: flex;
      align-items: center;
      gap: 8px;
      position: relative;
    }
    .tool-btn {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 8px;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      padding: 0;
      position: relative;
    }
    .tool-btn:hover,
    .tool-btn.active {
      border-color: var(--accent);
      background: color-mix(in srgb, var(--accent) 15%, var(--card));
    }
    .tool-btn img {
      width: 24px;
      height: 24px;
    }
    .dropdown-menu {
      display: none;
      position: absolute;
      top: 100%;
      left: 0;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 4px;
      z-index: 1000;
      flex-direction: column;
      gap: 4px;
    }
    .tool.dropdown.open .dropdown-menu {
      display: flex;
    }
    .toolbar.large button {
      border: 1px solid var(--border);
      background: var(--card);
      color: var(--ink);
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.9rem;
    }
    .toolbar.large input[type="search"] {
      border: 1px solid var(--border);
      background: var(--card);
      color: var(--ink);
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 0.9rem;
      min-width: 220px;
    }
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }
    .toolbar.large button:hover {
      border-color: var(--accent);
    }
    .toolbar.large button[data-variant="green"] {
      border-color: color-mix(in srgb, var(--accent) 70%, transparent);
    }
    .toolbar.large button[data-variant="yellow"] {
      border-color: color-mix(in srgb, var(--accent-warn) 70%, transparent);
    }
    .toolbar.large button[data-variant="danger"] {
      border-color: color-mix(in srgb, var(--accent-danger) 70%, transparent);
    }
    .toolbar.large .status {
      margin-left: auto;
      font-size: 0.9rem;
      color: var(--muted);
    }
    #actions button {
      min-width: 72px;
      height: 40px;
      font-size: 0.9rem;
      padding: 0 12px;
    }
    .map-wrap {
      margin-top: 16px;
      border-radius: 12px;
      overflow: hidden;
      border: 1px solid var(--border);
    }
    #map {
      height: 75vh;
      width: 100%;
    }
    .legend {
      display: grid;
      gap: 8px;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      margin-top: 16px;
    }
    .legend-item {
      padding: 12px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: var(--panel);
    }
    .legend-item strong {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    .legend-swatch {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      display: inline-block;
    }
    .legend-swatch.green { background: #4ade80; }
    .legend-swatch.yellow { background: #fbbf24; }
    .finish-segment-btn {
      position: absolute;
      z-index: 1000;
      background: #fff;
      color: #333;
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 4px 8px;
      font-size: 12px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.25);
      cursor: pointer;
      display: none;
    }
  </style>
</head>
<body data-route="howker-map-editor">
  <div id="nav-placeholder"></div>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const navPlaceholder = document.getElementById('nav-placeholder');
      const activeRoute = document.body.dataset.route || document.body.dataset.page;

      if (navPlaceholder) {
        fetch('/pages/nav.html')
          .then(response => response.text())
          .then(html => {
            navPlaceholder.innerHTML = html;
            const links = navPlaceholder.querySelectorAll('.site-nav-links a');
            links.forEach(link => {
              const routes = (link.dataset.routes || link.dataset.route || '')
                .split(',')
                .map(value => value.trim())
                .filter(Boolean);

              if (routes.includes(activeRoute)) {
                link.classList.add('active');
                link.setAttribute('aria-current', 'page');
              }
            });
            if (window.NH48_I18N && window.NH48_I18N.refreshLangPicker) {
              window.NH48_I18N.refreshLangPicker();
            }
          })
          .catch(err => console.error('Failed to load navigation:', err));
      }
    });
  </script>

  <div class="wrap">
    <header>
      <h1>Howker Ridge Map Editor</h1>
      <p>Update brushing status, mark blowdowns, and place signage notes for the Howker Ridge Trail.</p>
    </header>

    <div class="toolbar large" role="toolbar" aria-label="Map editing toolbar">
      <div class="tool-group" id="lineTools" aria-label="Line tools">
        <div class="tool dropdown" id="brushTool" aria-haspopup="true">
          <button type="button" class="tool-btn" title="Brush tools" aria-label="Brush tools">
            <img src="/assets/icons/brush.svg" alt="Brush tools">
          </button>
          <div class="dropdown-menu" role="menu" aria-label="Brush tool variants">
            <button type="button" class="tool-btn" data-line-type="brush_green" title="Brushed (Green)" aria-label="Brushed (Green)">
              <img src="/assets/icons/brush-green.svg" alt="Brushed (Green)">
            </button>
            <button type="button" class="tool-btn" data-line-type="brush_yellow" title="Needs brushing (Yellow)" aria-label="Needs brushing (Yellow)">
              <img src="/assets/icons/brush-yellow.svg" alt="Needs brushing (Yellow)">
            </button>
          </div>
        </div>
        <button type="button" class="tool-btn" data-line-type="bog_bridge" title="Bog bridge / puncheon" aria-label="Bog bridge / puncheon">
          <img src="/assets/icons/bog-bridge.svg" alt="Bog bridge">
        </button>
        <button type="button" class="tool-btn" data-line-type="stonework" title="Stonework" aria-label="Stonework">
          <img src="/assets/icons/stonework.svg" alt="Stonework">
        </button>
        <button type="button" class="tool-btn" data-line-type="tread" title="Tread condition" aria-label="Tread condition">
          <img src="/assets/icons/tread.svg" alt="Tread condition">
        </button>
        <button type="button" class="tool-btn" data-line-type="encroachment" title="Corridor encroachment" aria-label="Corridor encroachment">
          <img src="/assets/icons/encroachment.svg" alt="Encroachment">
        </button>
      </div>
      <div class="tool-group" id="markerTools" aria-label="Marker tools">
        <button type="button" class="tool-btn" data-marker-type="blowdown" title="Blowdown" aria-label="Blowdown">
          <img src="/assets/icons/blowdown.svg" alt="Blowdown">
        </button>
        <button type="button" class="tool-btn" data-marker-type="sign" title="Sign" aria-label="Sign">
          <img src="/assets/icons/sign.svg" alt="Sign">
        </button>
        <button type="button" class="tool-btn" data-marker-type="drain" title="Drainage" aria-label="Drainage">
          <img src="/assets/icons/drain.svg" alt="Drainage">
        </button>
        <button type="button" class="tool-btn" data-marker-type="hazard" title="Hazard" aria-label="Hazard">
          <img src="/assets/icons/hazard.svg" alt="Hazard">
        </button>
        <button type="button" class="tool-btn" data-marker-type="cairn" title="Cairn" aria-label="Cairn">
          <img src="/assets/icons/cairn.svg" alt="Cairn">
        </button>
        <button type="button" class="tool-btn" data-marker-type="poi" title="POI update" aria-label="Public point of interest update">
          <img src="/assets/icons/poi-update.svg" alt="POI update">
        </button>
      </div>
      <div class="tool-group" id="actions" aria-label="Editing actions">
        <button id="undoBtn" type="button" title="Undo last edit" aria-label="Undo last edit">Undo</button>
        <button id="saveBtn" type="button" data-variant="green" title="Save to server" aria-label="Save to server">Save</button>
        <button id="downloadBtn" type="button" title="Download edits" aria-label="Download edits">Download</button>
        <button id="loadEditsBtn" type="button" title="Reload saved edits" aria-label="Reload saved edits">Reload</button>
      </div>
      <div class="tool-group" id="searchTools" aria-label="Search and location">
        <button id="locateBtn" type="button" data-variant="green" title="Locate me" aria-label="Locate me">Locate me</button>
        <label>
          <span class="sr-only">Search trail features or POIs</span>
          <input id="searchInput" type="search" list="searchSuggestions" placeholder="Search trail features or POIs" aria-label="Search trail features or POIs" />
          <datalist id="searchSuggestions"></datalist>
        </label>
        <button id="searchBtn" type="button" title="Search trail features or POIs" aria-label="Search trail features or POIs">Search</button>
      </div>
      <span class="status" id="statusMsg" role="status" aria-live="polite"></span>
    </div>

    <div class="map-wrap">
      <div id="map" aria-label="Howker Ridge trail editor map"></div>
    </div>

    <div class="legend" aria-label="Map editing legend">
      <div class="legend-item">
        <strong><span class="legend-swatch green"></span>Brushed segment</strong>
        <p>Draw green lines where the trail is brushed and ready.</p>
      </div>
      <div class="legend-item">
        <strong><span class="legend-swatch yellow"></span>Needs brushing</strong>
        <p>Draw yellow lines where brushing is needed.</p>
      </div>
      <div class="legend-item">
        <strong>Adopter tools</strong>
        <p>Use the toolbar tools to record drainage, bog bridges, stonework, tread issues, encroachment, hazards, signs, and cairns.</p>
      </div>
    </div>
  </div>

  <div id="footer-placeholder"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
  <script>
    const TRAIL_URL = '/data/howker-ridge.geojson';
    const STATUS_URL = '/data/howker-ridge-status.geojson';
    const POI_URL = '/data/howker-ridge-pois.geojson';
    const EDIT_URL = '/data/howker-ridge-edit.json';
    const SAVE_ENDPOINT = '/api/howker/map-update';

    const baseIcons = {
      waterfall: '/assets/icons/waterfall.svg',
      junction: '/assets/icons/junction.svg',
      scenic: '/assets/icons/viewpoint.svg',
      summit: '/assets/icons/summit.svg',
      fallback: '/assets/icons/marker-default.svg'
    };

    const editIcons = {
      blowdown: '/assets/icons/blowdown.svg',
      sign: '/assets/icons/sign.svg',
      drain: '/assets/icons/drain.svg',
      hazard: '/assets/icons/hazard.svg',
      cairn: '/assets/icons/cairn.svg',
      poi: '/assets/icons/poi-update.svg'
    };

    let map;
    let baseTrailLayer;
    let drawControl;
    let currentMarkerType = 'blowdown';
    let currentLineType = null;
    let finishBtn;
    let highlightLayer;
    const drawnLayers = new L.FeatureGroup();
    const statusSegments = [];
    const blowdownMarkers = [];
    const signMarkers = [];
    const drainageFeatures = [];
    const bogBridges = [];
    const stoneworkSegments = [];
    const treadConditions = [];
    const encroachments = [];
    const hazardMarkers = [];
    const cairnMarkers = [];
    const poiMarkers = [];
    const historyStack = [];
    const trailSegments = [];
    const basePoiLayers = [];
    const searchIndex = [];

    function setStatusMessage(message, isError = false) {
      const statusEl = document.getElementById('statusMsg');
      if (!statusEl) return;
      statusEl.textContent = message;
      statusEl.style.color = isError ? '#f87171' : '';
    }

    function initMap() {
      const standardLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 18,
        attribution: '&copy; OpenStreetMap contributors'
      });
      const topoLayer = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
        maxZoom: 17,
        attribution: '&copy; OpenTopoMap contributors'
      });

      map = L.map('map', { layers: [topoLayer] }).setView([44.3, -71.3], 13);
      L.control.layers({ Topographic: topoLayer, Standard: standardLayer }, null, { position: 'topleft' }).addTo(map);
      L.control.scale({ position: 'bottomleft' }).addTo(map);
      map.addLayer(drawnLayers);

      loadBaseTrail();
      loadExistingEdits();
      setupDrawTools();
    }

    async function loadBaseTrail() {
      const res = await fetch(TRAIL_URL);
      const data = await res.json();

      baseTrailLayer = L.geoJSON(data, {
        filter: feature => feature.geometry && feature.geometry.type === 'LineString',
        style: { color: '#0ea5e9', weight: 3, opacity: 0.8 }
      }).addTo(map);
      cacheTrailSegments();

      const bounds = baseTrailLayer.getBounds();
      if (bounds.isValid()) map.fitBounds(bounds.pad(0.05));

      L.geoJSON(data, {
        filter: feature => feature.geometry && feature.geometry.type === 'Point',
        pointToLayer: (feature, latlng) => {
          const category = feature.properties?.category || '';
          const iconPath = baseIcons[category] || baseIcons.fallback;
          const icon = L.icon({ iconUrl: iconPath, iconSize: [22, 22], iconAnchor: [11, 22] });
          return L.marker(latlng, { icon });
        },
        onEachFeature: (feature, layer) => {
          const props = feature.properties || {};
          const title = props.name || '';
          const desc = props.description || '';
          layer.bindPopup(`<strong>${title}</strong><br/>${desc}`);
          if (title) {
            basePoiLayers.push({ name: title, layer });
          }
        }
      }).addTo(map);
      updateSearchIndex();
    }

    async function loadExistingEdits() {
      setStatusMessage('Loading edits...');
      const resetState = () => {
        statusSegments.length = 0;
        blowdownMarkers.length = 0;
        signMarkers.length = 0;
        drainageFeatures.length = 0;
        bogBridges.length = 0;
        stoneworkSegments.length = 0;
        treadConditions.length = 0;
        encroachments.length = 0;
        hazardMarkers.length = 0;
        cairnMarkers.length = 0;
        poiMarkers.length = 0;
        historyStack.length = 0;
      };

      const loadLegacyFiles = async () => {
        const [statusRes, poiRes] = await Promise.all([
          fetch(STATUS_URL),
          fetch(POI_URL)
        ]);

        if (statusRes.ok) {
          const statusJson = await statusRes.json();
          (statusJson.features || []).forEach(feature => {
            const coords = feature.geometry.coordinates.map(coord => [coord[1], coord[0]]);
            statusSegments.push({ coords, status: feature.properties?.status || 'green' });
          });
        }

        if (poiRes.ok) {
          const poiJson = await poiRes.json();
          (poiJson.features || []).forEach(feature => {
            const type = feature.properties?.type || 'sign';
            const base = {
              lat: feature.geometry.coordinates[1],
              lon: feature.geometry.coordinates[0],
              description: feature.properties?.description || ''
            };
            if (type === 'blowdown') {
              blowdownMarkers.push({
                ...base,
                size: feature.properties?.size || '',
                passable: feature.properties?.passable ?? null,
                tool: feature.properties?.tool || ''
              });
            } else {
              signMarkers.push({
                ...base,
                subtype: feature.properties?.subtype || type,
                junction: feature.properties?.junction || '',
                direction: feature.properties?.direction || '',
                text: feature.properties?.text || ''
              });
            }
          });
        }
      };

      try {
        resetState();
        const editRes = await fetch(EDIT_URL);
        if (editRes.ok) {
          const editJson = await editRes.json();
          (editJson.status?.features || []).forEach(feature => {
            const coords = feature.geometry.coordinates.map(coord => [coord[1], coord[0]]);
            statusSegments.push({ coords, status: feature.properties?.status || 'green' });
          });
          (editJson.blowdowns?.features || []).forEach(feature => {
            blowdownMarkers.push({
              lat: feature.geometry.coordinates[1],
              lon: feature.geometry.coordinates[0],
              description: feature.properties?.description || '',
              size: feature.properties?.size || '',
              passable: feature.properties?.passable ?? null,
              tool: feature.properties?.tool || ''
            });
          });
          (editJson.signs?.features || []).forEach(feature => {
            signMarkers.push({
              lat: feature.geometry.coordinates[1],
              lon: feature.geometry.coordinates[0],
              description: feature.properties?.description || '',
              subtype: feature.properties?.subtype || '',
              junction: feature.properties?.junction || '',
              direction: feature.properties?.direction || '',
              text: feature.properties?.text || ''
            });
          });
          (editJson.drainage?.features || []).forEach(feature => {
            drainageFeatures.push({
              lat: feature.geometry.coordinates[1],
              lon: feature.geometry.coordinates[0],
              subtype: feature.properties?.subtype || '',
              condition: feature.properties?.condition || '',
              last_worked: feature.properties?.last_worked || '',
              notes: feature.properties?.notes || ''
            });
          });
          (editJson.bogBridges?.features || []).forEach(feature => {
            bogBridges.push({
              coords: feature.geometry.coordinates.map(coord => [coord[1], coord[0]]),
              length_ft: feature.properties?.length_ft || 0,
              condition: feature.properties?.condition || '',
              hazard: feature.properties?.hazard || false,
              subtype: feature.properties?.subtype || ''
            });
          });
          (editJson.stonework?.features || []).forEach(feature => {
            stoneworkSegments.push({
              coords: feature.geometry.coordinates.map(coord => [coord[1], coord[0]]),
              subtype: feature.properties?.subtype || '',
              condition: feature.properties?.condition || '',
              notes: feature.properties?.notes || ''
            });
          });
          (editJson.tread?.features || []).forEach(feature => {
            treadConditions.push({
              coords: feature.geometry.coordinates.map(coord => [coord[1], coord[0]]),
              status: feature.properties?.status || '',
              notes: feature.properties?.notes || ''
            });
          });
          (editJson.encroachments?.features || []).forEach(feature => {
            encroachments.push({
              coords: feature.geometry.coordinates.map(coord => [coord[1], coord[0]]),
              side: feature.properties?.side || '',
              notes: feature.properties?.notes || ''
            });
          });
          (editJson.hazards?.features || []).forEach(feature => {
            hazardMarkers.push({
              lat: feature.geometry.coordinates[1],
              lon: feature.geometry.coordinates[0],
              subtype: feature.properties?.subtype || '',
              severity: feature.properties?.severity || '',
              seasonal: feature.properties?.seasonal || '',
              description: feature.properties?.description || ''
            });
          });
          (editJson.cairns?.features || []).forEach(feature => {
            cairnMarkers.push({
              lat: feature.geometry.coordinates[1],
              lon: feature.geometry.coordinates[0],
              status: feature.properties?.status || '',
              notes: feature.properties?.notes || ''
            });
          });
          (editJson.pois?.features || []).forEach(feature => {
            poiMarkers.push({
              lat: feature.geometry.coordinates[1],
              lon: feature.geometry.coordinates[0],
              name: feature.properties?.name || '',
              category: feature.properties?.category || '',
              description: feature.properties?.description || ''
            });
          });
        } else {
          await loadLegacyFiles();
        }

        redrawOverlays();
        setStatusMessage('Edits loaded.');
      } catch (err) {
        setStatusMessage('Unable to load edits.', true);
      }
    }

    function promptValue(label, fallback = '') {
      const value = prompt(label, fallback);
      if (value === null) return '';
      return value.trim();
    }

    function promptYesNo(label, fallback = '') {
      const value = prompt(label, fallback);
      if (value === null) return null;
      const normalized = value.trim().toLowerCase();
      if (['yes', 'y', 'true', '1'].includes(normalized)) return true;
      if (['no', 'n', 'false', '0'].includes(normalized)) return false;
      return null;
    }

    function calculateLengthFt(latlngs) {
      let meters = 0;
      for (let i = 1; i < latlngs.length; i += 1) {
        meters += map.distance(latlngs[i - 1], latlngs[i]);
      }
      return meters * 3.28084;
    }

    function collectLineLatLngs(latlngs, target) {
      if (!Array.isArray(latlngs)) {
        target.push(latlngs);
        return;
      }
      if (latlngs.length && latlngs[0] instanceof L.LatLng) {
        target.push(...latlngs);
        return;
      }
      latlngs.forEach(item => collectLineLatLngs(item, target));
    }

    function cacheTrailSegments() {
      trailSegments.length = 0;
      if (!baseTrailLayer) return;
      baseTrailLayer.eachLayer(layer => {
        if (!layer.getLatLngs) return;
        const flattened = [];
        collectLineLatLngs(layer.getLatLngs(), flattened);
        for (let i = 1; i < flattened.length; i += 1) {
          trailSegments.push([flattened[i - 1], flattened[i]]);
        }
      });
    }

    function closestPointOnSegment(point, segStart, segEnd) {
      const segment = segEnd.subtract(segStart);
      const lengthSquared = segment.x * segment.x + segment.y * segment.y;
      if (!lengthSquared) return segStart;
      const t = Math.max(0, Math.min(1, point.subtract(segStart).dot(segment) / lengthSquared));
      return segStart.add(segment.multiplyBy(t));
    }

    function snapLatLng(latlng) {
      if (!trailSegments.length) return latlng;
      const zoom = map.getZoom();
      const target = map.project(latlng, zoom);
      let closest = null;
      let closestDistance = Infinity;
      trailSegments.forEach(([start, end]) => {
        const segStart = map.project(start, zoom);
        const segEnd = map.project(end, zoom);
        const candidate = closestPointOnSegment(target, segStart, segEnd);
        const dist = candidate.distanceTo(target);
        if (dist < closestDistance) {
          closestDistance = dist;
          closest = candidate;
        }
      });
      if (!closest) return latlng;
      return map.unproject(closest, zoom);
    }

    function snapLatLngs(latlngs) {
      if (Array.isArray(latlngs)) {
        return latlngs.map(item => snapLatLngs(item));
      }
      return snapLatLng(latlngs);
    }

    function setupDrawTools() {
      drawControl = new L.Control.Draw({
        draw: {
          polyline: {
            shapeOptions: { weight: 6, opacity: 0.8 },
            repeatMode: true,
            metric: false
          },
          polygon: false,
          rectangle: false,
          circle: false,
          circlemarker: false,
          marker: {
            icon: L.icon({ iconUrl: editIcons.blowdown, iconSize: [26, 26], iconAnchor: [13, 26] })
          }
        },
        edit: {
          featureGroup: drawnLayers,
          edit: false,
          remove: false
        }
      });
      map.addControl(drawControl);

      map.on(L.Draw.Event.CREATED, event => {
        const layer = event.layer;
        if (event.layerType === 'polyline' && currentLineType) {
          const snapped = snapLatLngs(layer.getLatLngs());
          layer.setLatLngs(snapped);
          const latlngs = layer.getLatLngs();
          const coords = latlngs.map(latlng => [latlng.lat, latlng.lng]);
          const lengthFt = calculateLengthFt(latlngs);

          if (currentLineType === 'brush_green' || currentLineType === 'brush_yellow') {
            const status = currentLineType === 'brush_green' ? 'green' : 'yellow';
            statusSegments.push({ coords, status });
            historyStack.push({ type: 'status' });
          } else if (currentLineType === 'bog_bridge') {
            const subtype = promptValue('Bog bridge subtype (bog_bridge, puncheon, stepping_stones):');
            const condition = promptValue('Condition (good, fair, poor):');
            const hazard = promptYesNo('Is this section hazardous? (yes/no)');
            bogBridges.push({ coords, length_ft: lengthFt, condition, hazard, subtype });
            historyStack.push({ type: 'bog_bridge' });
          } else if (currentLineType === 'stonework') {
            const subtype = promptValue('Stonework subtype (rock_step, staircase, retaining_wall, causeway):');
            const condition = promptValue('Condition (good, fair, poor):');
            const notes = promptValue('Notes (optional):');
            stoneworkSegments.push({ coords, subtype, condition, notes });
            historyStack.push({ type: 'stonework' });
          } else if (currentLineType === 'tread') {
            const status = promptValue('Tread condition (stable, eroding, severe, braided):');
            const notes = promptValue('Notes (optional):');
            treadConditions.push({ coords, status, notes });
            historyStack.push({ type: 'tread' });
          } else if (currentLineType === 'encroachment') {
            const side = promptValue('Encroachment side (left, right, both):');
            const notes = promptValue('Notes (optional):');
            encroachments.push({ coords, side, notes });
            historyStack.push({ type: 'encroachment' });
          }
          redrawOverlays();
        } else if (event.layerType === 'marker') {
          const latlng = layer.getLatLng();
          if (currentMarkerType === 'blowdown') {
            const size = promptValue('Blowdown size (small, medium, large):');
            const passable = promptYesNo('Passable? (yes/no)');
            const tool = promptValue('Required tool (crosscut, chainsaw, hand):');
            const description = promptValue('Notes (optional):');
            blowdownMarkers.push({ lat: latlng.lat, lon: latlng.lng, size, passable, tool, description });
            historyStack.push({ type: 'blowdown' });
          } else if (currentMarkerType === 'sign') {
            const subtype = promptValue('Sign subtype (junction, blaze, info):');
            const junction = promptValue('Junction name (optional):');
            const direction = promptValue('Direction (optional):');
            const text = promptValue('Sign text (optional):');
            const description = promptValue('Notes (optional):');
            signMarkers.push({ lat: latlng.lat, lon: latlng.lng, subtype, junction, direction, text, description });
            historyStack.push({ type: 'sign' });
          } else if (currentMarkerType === 'drain') {
            const subtype = promptValue('Drainage subtype (water_bar, drain_dip, ditch, cross_drain):');
            const condition = promptValue('Condition (clear, partial, blocked):');
            const last_worked = promptValue('Last worked (YYYY-MM-DD):');
            const notes = promptValue('Notes (optional):');
            drainageFeatures.push({ lat: latlng.lat, lon: latlng.lng, subtype, condition, last_worked, notes });
            historyStack.push({ type: 'drainage' });
          } else if (currentMarkerType === 'hazard') {
            const subtype = promptValue('Hazard subtype (ice, cliff, slab, washout):');
            const severity = promptValue('Severity (low, medium, high):');
            const seasonal = promptValue('Seasonal (winter, spring, year-round):');
            const description = promptValue('Notes (optional):');
            hazardMarkers.push({ lat: latlng.lat, lon: latlng.lng, subtype, severity, seasonal, description });
            historyStack.push({ type: 'hazard' });
          } else if (currentMarkerType === 'cairn') {
            const status = promptValue('Cairn status (good, needs_reset, missing):');
            const notes = promptValue('Notes (optional):');
            cairnMarkers.push({ lat: latlng.lat, lon: latlng.lng, status, notes });
            historyStack.push({ type: 'cairn' });
          } else if (currentMarkerType === 'poi') {
            const name = promptValue('POI name:');
            const category = promptValue('POI category (optional):');
            const description = promptValue('POI description (optional):');
            poiMarkers.push({ lat: latlng.lat, lon: latlng.lng, name, category, description });
            historyStack.push({ type: 'poi' });
          }
          redrawOverlays();
        }
        if (finishBtn) finishBtn.style.display = 'none';
      });

      map.on('draw:drawvertex', event => {
        if (!event.layers || !event.layers.getLayers().length) return;
        const markers = event.layers.getLayers();
        const last = markers[markers.length - 1];
        const snapped = snapLatLng(last.getLatLng());
        last.setLatLng(snapped);
        showFinishButton(last.getLatLng());
      });
    }

    function addDraggableMarker(item, iconUrl, popupHtml) {
      const icon = L.icon({ iconUrl, iconSize: [26, 26], iconAnchor: [13, 26] });
      const marker = L.marker([item.lat, item.lon], { icon, draggable: true }).addTo(drawnLayers);
      if (popupHtml) marker.bindPopup(popupHtml);
      marker.on('dragend', () => {
        const ll = marker.getLatLng();
        item.lat = ll.lat;
        item.lon = ll.lng;
      });
      return marker;
    }

    function redrawOverlays() {
      drawnLayers.clearLayers();
      statusSegments.forEach(seg => {
        const color = seg.status === 'green' ? '#4ade80' : '#fbbf24';
        L.polyline(seg.coords, { color, weight: 8, opacity: 0.5 }).addTo(drawnLayers);
      });

      bogBridges.forEach(bb => {
        const opts = { color: '#8b5cf6', weight: 6, opacity: 0.7 };
        const label = `<strong>Bog Bridge</strong><br>Length: ${bb.length_ft ? bb.length_ft.toFixed(0) : '0'} ft<br>Condition: ${bb.condition || ''}${bb.hazard ? '<br><em>Hazardous</em>' : ''}`;
        L.polyline(bb.coords, opts).addTo(drawnLayers).bindPopup(label);
      });

      stoneworkSegments.forEach(seg => {
        const opts = { color: '#94a3b8', weight: 6, opacity: 0.7 };
        const label = `<strong>Stonework</strong><br>${seg.subtype || ''}<br>Condition: ${seg.condition || ''}<br>${seg.notes || ''}`;
        L.polyline(seg.coords, opts).addTo(drawnLayers).bindPopup(label);
      });

      treadConditions.forEach(seg => {
        const opts = { color: '#f97316', weight: 6, opacity: 0.7 };
        const label = `<strong>Tread Condition</strong><br>${seg.status || ''}<br>${seg.notes || ''}`;
        L.polyline(seg.coords, opts).addTo(drawnLayers).bindPopup(label);
      });

      encroachments.forEach(seg => {
        const opts = { color: '#ef4444', weight: 6, opacity: 0.7 };
        const label = `<strong>Encroachment</strong><br>${seg.side || ''}<br>${seg.notes || ''}`;
        L.polyline(seg.coords, opts).addTo(drawnLayers).bindPopup(label);
      });

      blowdownMarkers.forEach(item => {
        const label = `<strong>Blowdown</strong><br>Size: ${item.size || ''}<br>Passable: ${item.passable === null ? '' : item.passable ? 'Yes' : 'No'}<br>Tool: ${item.tool || ''}<br>${item.description || ''}`;
        addDraggableMarker(item, editIcons.blowdown, label);
      });

      signMarkers.forEach(item => {
        const label = `<strong>Sign</strong><br>${item.subtype || ''}<br>${item.junction || ''}<br>${item.direction || ''}<br>${item.text || ''}<br>${item.description || ''}`;
        addDraggableMarker(item, editIcons.sign, label);
      });

      drainageFeatures.forEach(item => {
        const label = `<strong>Drainage</strong><br>${item.subtype || ''}<br>Condition: ${item.condition || ''}<br>Last worked: ${item.last_worked || ''}<br>${item.notes || ''}`;
        addDraggableMarker(item, editIcons.drain, label);
      });

      hazardMarkers.forEach(item => {
        const label = `<strong>Hazard</strong><br>${item.subtype || ''}<br>Severity: ${item.severity || ''}<br>Seasonal: ${item.seasonal || ''}<br>${item.description || ''}`;
        addDraggableMarker(item, editIcons.hazard, label);
      });

      cairnMarkers.forEach(item => {
        const label = `<strong>Cairn</strong><br>Status: ${item.status || ''}<br>${item.notes || ''}`;
        addDraggableMarker(item, editIcons.cairn, label);
      });

      poiMarkers.forEach(item => {
        const label = `<strong>${item.name || 'POI'}</strong><br>${item.category || ''}<br>${item.description || ''}`;
        item._marker = addDraggableMarker(item, editIcons.poi, label);
      });

      updateSearchIndex();
    }

    function buildGeoJson() {
      const statusFeatures = statusSegments.map(seg => ({
        type: 'Feature',
        properties: { status: seg.status },
        geometry: { type: 'LineString', coordinates: seg.coords.map(coord => [coord[1], coord[0]]) }
      }));
      const blowdownFeatures = blowdownMarkers.map(item => ({
        type: 'Feature',
        properties: {
          type: 'blowdown',
          size: item.size,
          passable: item.passable,
          tool: item.tool,
          description: item.description
        },
        geometry: { type: 'Point', coordinates: [item.lon, item.lat] }
      }));
      const signFeatures = signMarkers.map(item => ({
        type: 'Feature',
        properties: {
          type: 'sign',
          subtype: item.subtype,
          junction: item.junction,
          direction: item.direction,
          text: item.text,
          description: item.description
        },
        geometry: { type: 'Point', coordinates: [item.lon, item.lat] }
      }));
      const drainageFeaturesFC = drainageFeatures.map(item => ({
        type: 'Feature',
        properties: {
          type: 'drain',
          subtype: item.subtype,
          condition: item.condition,
          last_worked: item.last_worked,
          notes: item.notes
        },
        geometry: { type: 'Point', coordinates: [item.lon, item.lat] }
      }));
      const bogBridgeFeatures = bogBridges.map(item => ({
        type: 'Feature',
        properties: {
          type: 'bog_bridge',
          subtype: item.subtype,
          length_ft: item.length_ft,
          condition: item.condition,
          hazard: item.hazard
        },
        geometry: { type: 'LineString', coordinates: item.coords.map(coord => [coord[1], coord[0]]) }
      }));
      const stoneworkFeatures = stoneworkSegments.map(item => ({
        type: 'Feature',
        properties: {
          type: 'stonework',
          subtype: item.subtype,
          condition: item.condition,
          notes: item.notes
        },
        geometry: { type: 'LineString', coordinates: item.coords.map(coord => [coord[1], coord[0]]) }
      }));
      const treadFeatures = treadConditions.map(item => ({
        type: 'Feature',
        properties: { type: 'tread', status: item.status, notes: item.notes },
        geometry: { type: 'LineString', coordinates: item.coords.map(coord => [coord[1], coord[0]]) }
      }));
      const encroachmentFeatures = encroachments.map(item => ({
        type: 'Feature',
        properties: { type: 'encroachment', side: item.side, notes: item.notes },
        geometry: { type: 'LineString', coordinates: item.coords.map(coord => [coord[1], coord[0]]) }
      }));
      const hazardFeatures = hazardMarkers.map(item => ({
        type: 'Feature',
        properties: {
          type: 'hazard',
          subtype: item.subtype,
          severity: item.severity,
          seasonal: item.seasonal,
          description: item.description
        },
        geometry: { type: 'Point', coordinates: [item.lon, item.lat] }
      }));
      const cairnFeatures = cairnMarkers.map(item => ({
        type: 'Feature',
        properties: { type: 'cairn', status: item.status, notes: item.notes },
        geometry: { type: 'Point', coordinates: [item.lon, item.lat] }
      }));
      const poiFeatures = poiMarkers.map(item => ({
        type: 'Feature',
        properties: {
          name: item.name,
          category: item.category,
          description: item.description
        },
        geometry: { type: 'Point', coordinates: [item.lon, item.lat] }
      }));
      return {
        status: { type: 'FeatureCollection', features: statusFeatures },
        blowdowns: { type: 'FeatureCollection', features: blowdownFeatures },
        signs: { type: 'FeatureCollection', features: signFeatures },
        drainage: { type: 'FeatureCollection', features: drainageFeaturesFC },
        bogBridges: { type: 'FeatureCollection', features: bogBridgeFeatures },
        stonework: { type: 'FeatureCollection', features: stoneworkFeatures },
        tread: { type: 'FeatureCollection', features: treadFeatures },
        encroachments: { type: 'FeatureCollection', features: encroachmentFeatures },
        hazards: { type: 'FeatureCollection', features: hazardFeatures },
        cairns: { type: 'FeatureCollection', features: cairnFeatures },
        pois: { type: 'FeatureCollection', features: poiFeatures }
      };
    }

    async function saveToServer() {
      const password = prompt('Enter editing password:');
      if (!password) return;
      const geo = buildGeoJson();
      const payload = { password, ...geo };

      setStatusMessage('Saving edits...');
      try {
        const res = await fetch(SAVE_ENDPOINT, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        const out = await res.json();
        if (res.ok && out.ok) {
          setStatusMessage('Saved successfully.');
        } else {
          setStatusMessage(out.error || 'Error saving edits.', true);
        }
      } catch (err) {
        setStatusMessage('Save failed.', true);
      }
    }

    function downloadJson() {
      const geo = buildGeoJson();
      const blob = new Blob([JSON.stringify(geo, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = 'howker-ridge-edits.json';
      document.body.appendChild(link);
      link.click();
      link.remove();
      URL.revokeObjectURL(url);
    }

    function undoLast() {
      const last = historyStack.pop();
      if (!last) {
        setStatusMessage('Nothing to undo.');
        return;
      }
      if (last.type === 'status') {
        statusSegments.pop();
      } else if (last.type === 'bog_bridge') {
        bogBridges.pop();
      } else if (last.type === 'stonework') {
        stoneworkSegments.pop();
      } else if (last.type === 'tread') {
        treadConditions.pop();
      } else if (last.type === 'encroachment') {
        encroachments.pop();
      } else if (last.type === 'blowdown') {
        blowdownMarkers.pop();
      } else if (last.type === 'sign') {
        signMarkers.pop();
      } else if (last.type === 'drainage') {
        drainageFeatures.pop();
      } else if (last.type === 'hazard') {
        hazardMarkers.pop();
      } else if (last.type === 'cairn') {
        cairnMarkers.pop();
      } else if (last.type === 'poi') {
        poiMarkers.pop();
      }
      redrawOverlays();
      setStatusMessage('Undid last edit.');
    }

    function enablePolylineDrawing(lineType) {
      currentLineType = lineType;
      let color = '#4ade80';
      if (lineType === 'brush_yellow') {
        color = '#fbbf24';
      } else if (lineType === 'bog_bridge') {
        color = '#8b5cf6';
      } else if (lineType === 'stonework') {
        color = '#94a3b8';
      } else if (lineType === 'tread') {
        color = '#f97316';
      } else if (lineType === 'encroachment') {
        color = '#ef4444';
      }
      drawControl.setDrawingOptions({
        polyline: { shapeOptions: { color, weight: 6, opacity: 0.85 }, repeatMode: true }
      });
      drawControl._toolbars.draw._modes.polyline.handler.enable();
    }

    function showFinishButton(latlng) {
      if (!finishBtn) {
        finishBtn = L.DomUtil.create('button', 'finish-segment-btn', map.getContainer());
        finishBtn.innerText = 'End segment';
        finishBtn.type = 'button';
        finishBtn.addEventListener('click', () => {
          const polyHandler = drawControl?._toolbars?.draw?._modes?.polyline?.handler;
          if (polyHandler) {
            polyHandler.completeShape();
          }
          finishBtn.style.display = 'none';
        });
      }
      const point = map.latLngToContainerPoint(latlng);
      finishBtn.style.left = `${point.x + 8}px`;
      finishBtn.style.top = `${point.y + 8}px`;
      finishBtn.style.display = 'block';
    }

    function enableMarkerDrawing(type) {
      currentMarkerType = type;
      const iconUrl = editIcons[type] || editIcons.sign;
      drawControl._toolbars.draw._modes.marker.handler.setOptions({
        icon: L.icon({ iconUrl, iconSize: [26, 26], iconAnchor: [13, 26] })
      });
      drawControl._toolbars.draw._modes.marker.handler.enable();
      if (finishBtn) finishBtn.style.display = 'none';
    }

    function updateSearchIndex() {
      searchIndex.length = 0;
      basePoiLayers.forEach(item => searchIndex.push(item));
      poiMarkers.forEach(item => {
        if (item.name && item._marker) {
          searchIndex.push({ name: item.name, layer: item._marker });
        }
      });
      updateSearchSuggestions();
    }

    function updateSearchSuggestions() {
      const datalist = document.getElementById('searchSuggestions');
      if (!datalist) return;
      datalist.innerHTML = '';
      searchIndex
        .slice()
        .sort((a, b) => a.name.localeCompare(b.name))
        .forEach(item => {
          const option = document.createElement('option');
          option.value = item.name;
          datalist.appendChild(option);
        });
    }

    function highlightSearchResult(latlng) {
      if (highlightLayer) {
        map.removeLayer(highlightLayer);
      }
      highlightLayer = L.circleMarker(latlng, {
        radius: 10,
        color: '#22c55e',
        weight: 3,
        fillColor: '#86efac',
        fillOpacity: 0.4
      }).addTo(map);
    }

    function getLayerLatLng(layer) {
      if (!layer) return null;
      if (layer.getLatLng) return layer.getLatLng();
      if (layer.getBounds) return layer.getBounds().getCenter();
      return null;
    }

    function performSearch(query) {
      const trimmed = query.trim();
      if (!trimmed) {
        setStatusMessage('Enter a feature name to search.', true);
        return;
      }
      const lower = trimmed.toLowerCase();
      const match = searchIndex.find(item => item.name.toLowerCase() === lower)
        || searchIndex.find(item => item.name.toLowerCase().includes(lower));
      if (!match) {
        setStatusMessage('No matching trail feature or POI found.', true);
        return;
      }
      const targetLatLng = getLayerLatLng(match.layer);
      if (!targetLatLng) {
        setStatusMessage('Unable to locate that feature on the map.', true);
        return;
      }
      map.flyTo([targetLatLng.lat, targetLatLng.lng], 15);
      if (match.layer.openPopup) {
        match.layer.openPopup();
      }
      highlightSearchResult(targetLatLng);
      setStatusMessage(`Found: ${match.name}`);
    }

    function locateUser() {
      if (!navigator.geolocation) {
        setStatusMessage('Geolocation is not supported in this browser.', true);
        return;
      }
      setStatusMessage('Locating you...');
      navigator.geolocation.getCurrentPosition(
        position => {
          const { latitude, longitude } = position.coords;
          map.flyTo([latitude, longitude], 15);
          setStatusMessage('Location found.');
        },
        error => {
          setStatusMessage(error.message || 'Unable to retrieve location.', true);
        },
        { enableHighAccuracy: true, timeout: 10000 }
      );
    }

    document.addEventListener('DOMContentLoaded', () => {
      initMap();
      document.querySelectorAll('.tool.dropdown > .tool-btn').forEach(button => {
        button.addEventListener('click', event => {
          event.stopPropagation();
          const parent = button.parentElement;
          parent.classList.toggle('open');
          document.querySelectorAll('.tool.dropdown').forEach(other => {
            if (other !== parent) other.classList.remove('open');
          });
        });
      });
      document.addEventListener('click', event => {
        if (!event.target.closest('.tool.dropdown')) {
          document.querySelectorAll('.tool.dropdown').forEach(drop => drop.classList.remove('open'));
        }
      });
      document.querySelectorAll('.tool-btn[data-line-type]').forEach(button => {
        button.addEventListener('click', () => {
          const type = button.getAttribute('data-line-type');
          enablePolylineDrawing(type);
          document.querySelectorAll('.tool-btn[data-line-type]').forEach(item => item.classList.remove('active'));
          button.classList.add('active');
          const dropdown = button.closest('.tool.dropdown');
          if (dropdown) dropdown.classList.remove('open');
        });
      });
      document.querySelectorAll('.tool-btn[data-marker-type]').forEach(button => {
        button.addEventListener('click', () => {
          const type = button.getAttribute('data-marker-type');
          enableMarkerDrawing(type);
          document.querySelectorAll('.tool-btn[data-marker-type]').forEach(item => item.classList.remove('active'));
          button.classList.add('active');
        });
      });
      document.getElementById('saveBtn').addEventListener('click', saveToServer);
      document.getElementById('downloadBtn').addEventListener('click', downloadJson);
      document.getElementById('loadEditsBtn').addEventListener('click', loadExistingEdits);
      document.getElementById('undoBtn').addEventListener('click', undoLast);
      document.getElementById('locateBtn').addEventListener('click', locateUser);
      const searchInput = document.getElementById('searchInput');
      document.getElementById('searchBtn').addEventListener('click', () => performSearch(searchInput.value));
      searchInput.addEventListener('keydown', event => {
        if (event.key === 'Enter') {
          event.preventDefault();
          performSearch(searchInput.value);
        }
      });
    });
  </script>
</body>
</html>
