<!doctype html>
<html lang="en" style="scroll-behavior: smooth;">
  <head>
    <meta charset="utf-8">
    <!-- Favicons - ICO format preferred for Google compatibility -->
    <link rel="icon" href="/favicons/favicon.ico" sizes="48x48">
    <link rel="icon" type="image/x-icon" href="/favicons/favicon.ico">
    <link rel="shortcut icon" href="/favicons/favicon.ico">
    <link rel="icon" type="image/x-icon" sizes="16x16" href="/favicons/favicon-16x16.ico">
    <link rel="icon" type="image/x-icon" sizes="32x32" href="/favicons/favicon-32x32.ico">
    <link rel="icon" type="image/x-icon" sizes="48x48" href="/favicons/favicon-48x48.ico">
    <link rel="icon" type="image/x-icon" sizes="96x96" href="/favicons/favicon-96x96.ico">
    <!-- PNG fallbacks for browsers that prefer PNG -->
    <link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32.png">
    <link rel="icon" type="image/png" sizes="48x48" href="/favicons/favicon-48x48.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/favicons/favicon-96x96.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
    <link rel="manifest" href="/manifest.json">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Browse the NH48 Peak Catalog with elevation, prominence, range, difficulty and photo thumbnails for all 48 four-thousand-foot peaks in New Hampshire. Search, filter and sort using this open dataset. Open API and datasets for New Hampshire’s 4,000-foot mountains.">
    <meta name="keywords" content="NH48 API, New Hampshire 4000 footers, peak catalog, White Mountains data, hiking database, open hiking API, peak metadata, mountain photos, NH 48 peaks dataset, White Mountain peak list, open source hiking API">
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow,max-image-preview:large">
    <link rel="canonical" href="https://nh48.info/catalog">
    <link rel="sitemap" type="application/xml" title="Page sitemap" href="https://nh48.info/page-sitemap.xml">
    <link rel="alternate" hreflang="en" href="https://nh48.info/">
    <link rel="alternate" hreflang="es" href="https://nh48.info/i18n/es.html">
    <link rel="alternate" hreflang="fr" href="https://nh48.info/i18n/fr.html">
    <link rel="alternate" hreflang="de" href="https://nh48.info/i18n/de.html">
    <link rel="alternate" hreflang="zh" href="https://nh48.info/i18n/zh.html">
    <link rel="alternate" hreflang="zh-Hans" href="https://nh48.info/i18n/zh-Hans.html">
    <link rel="alternate" hreflang="ja" href="https://nh48.info/i18n/ja.html">
    <link rel="alternate" hreflang="ar" href="https://nh48.info/i18n/ar.html">
    <link rel="alternate" hreflang="hi-IN" href="https://nh48.info/i18n/hi.html">
    <link rel="alternate" hreflang="pt" href="https://nh48.info/i18n/pt.html">
    <link rel="alternate" hreflang="ru" href="https://nh48.info/i18n/ru.html">
    <link rel="alternate" hreflang="id" href="https://nh48.info/i18n/id.html">
    <link rel="alternate" hreflang="it" href="https://nh48.info/i18n/it.html">
    <link rel="alternate" hreflang="ko" href="https://nh48.info/i18n/ko.html">
    <link rel="alternate" hreflang="tr" href="https://nh48.info/i18n/tr.html">
    <link rel="alternate" hreflang="vi" href="https://nh48.info/i18n/vi.html">
    <link rel="alternate" hreflang="pl" href="https://nh48.info/i18n/pl.html">
    <link rel="alternate" hreflang="x-default" href="https://nh48.info/">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://nh48.info/catalog">
    <meta property="og:title" content="NH48 Peak Catalog – Data &amp; photos for New Hampshire’s 4000-footers">
    <meta property="og:description" content="Browse the NH48 Peak Catalog with elevation, prominence, range, difficulty and photo thumbnails for all 48 four-thousand-foot peaks in New Hampshire. Search, filter and sort using this open dataset. Open API and datasets for New Hampshire’s 4,000-foot mountains.">
    <meta property="og:image" content="https://photos.nh48.info/cdn-cgi/image/format=jpg,quality=85,width=1200/zealand-mountain/zealand-mountain__001.jpg">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://nh48.info/catalog">
    <meta name="twitter:title" content="NH48 Peak Catalog – Data &amp; photos for New Hampshire's 4000-footers">
    <meta name="twitter:description" content="Browse the NH48 Peak Catalog with elevation, prominence, range, difficulty and photo thumbnails for all 48 four-thousand-foot peaks in New Hampshire. Search, filter and sort using this open dataset. Open API and datasets for New Hampshire’s 4,000-foot mountains.">
    <meta name="twitter:image" content="https://photos.nh48.info/cdn-cgi/image/format=jpg,quality=85,width=1200/zealand-mountain/zealand-mountain__001.jpg">
    
    <title>NH48 Peak Catalog – Data &amp; photos for New Hampshire’s 4000-footers</title>
    <link rel="mask-icon" href="/favicons/favicon.ico" color="#22c55e">
    <link rel="stylesheet" href="../css/nh48_catalog.css">
    <script type="module" src="../js/i18n.js"></script>
    <script src="/js/unified-footer.js" defer></script>
<noscript>
      <p>
        JavaScript is required to continue.
        <a href="https://nh48.info/catalog">Continue</a>
      </p>
    </noscript>

    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "Dataset",
        "name": "NH48 API – New Hampshire 4000-Footers Data",
        "description": "Structured data and photos for the 48 four-thousand-foot peaks of the White Mountain National Forest, including elevation, prominence, difficulty, routes and rich photo metadata.",
        "url": "https://nh48.info/",
        "license": "https://creativecommons.org/licenses/by/4.0/",
        "creator": {
          "@type": "Person",
          "name": "Nathan Sobol",
          "url": "https://www.nh48pics.com/"
        },
        "keywords": ["NH48", "White Mountains", "4000 footers", "hiking data", "peak metadata", "photo metadata", "open dataset"],
        "distribution": {
          "@type": "DataDownload",
          "contentUrl": "https://cdn.jsdelivr.net/gh/natesobol/nh48-api@main/data/nh48.json",
          "encodingFormat": "application/json"
        },
        "temporalCoverage": "2025-12-06/2025-12-06",
        "spatialCoverage": {
          "@type": "Place",
          "name": "White Mountain National Forest",
          "geo": {"@type": "GeoShape", "circle": "44.15 -71.34 50km"}
        }
      }
    </script>
    <script type="application/ld+json" id="breadcrumb-structured-data">
      {
        "@context": "https://schema.org",
        "@type": "BreadcrumbList",
        "itemListElement": [
          {
            "@type": "ListItem",
            "position": 1,
            "name": "Home",
            "item": "https://nh48.info/"
          },
          {
            "@type": "ListItem",
            "position": 2,
            "name": "NH48 Peak Catalog",
            "item": "https://nh48.info/catalog"
          }
        ]
      }
    </script>
    <script type="application/ld+json" id="catalog-image-gallery">
      {
        "@context": "https://schema.org",
        "@type": "ImageGallery",
        "name": "NH48 Peak Catalog Photo Highlights",
        "url": "https://nh48.info/catalog",
        "description": "Representative summit photography from the NH48 Peak Catalog with attribution and licensing for search engines.",
        "creator": {
          "@type": "Person",
          "name": "Nathan Sobol",
          "url": "https://www.nh48pics.com/"
        },
        "license": "https://creativecommons.org/licenses/by/4.0/",
        "about": {
          "@type": "Place",
          "name": "White Mountain National Forest"
        },
        "associatedMedia": [
          {
            "@type": "ImageObject",
            "name": "Bondcliff summit ridge",
            "caption": "Bondcliff summit ridge in New Hampshire’s White Mountains.",
            "contentUrl": "https://photos.nh48.info/cdn-cgi/image/format=webp,quality=85,width=720/bondcliff/bondcliff__001.jpg",
            "thumbnailUrl": "https://photos.nh48.info/cdn-cgi/image/format=webp,quality=85,width=720/bondcliff/bondcliff__001.jpg",
            "creditText": "Nathan Sobol"
          },
          {
            "@type": "ImageObject",
            "name": "Mount Adams alpine zone",
            "caption": "Mount Adams summit cone with alpine vegetation and views toward Mount Washington.",
            "contentUrl": "https://photos.nh48.info/cdn-cgi/image/format=webp,quality=85,width=720/mount-adams/mount-adams__001.jpg",
            "thumbnailUrl": "https://photos.nh48.info/cdn-cgi/image/format=webp,quality=85,width=720/mount-adams/mount-adams__001.jpg",
            "creditText": "Nathan Sobol"
          },
          {
            "@type": "ImageObject",
            "name": "Mount Liberty viewpoint",
            "caption": "Mount Liberty lookout over Franconia Ridge and the Pemigewasset Wilderness.",
            "contentUrl": "https://photos.nh48.info/cdn-cgi/image/format=webp,quality=85,width=720/mount-liberty/mount-liberty__001.jpg",
            "thumbnailUrl": "https://photos.nh48.info/cdn-cgi/image/format=webp,quality=85,width=720/mount-liberty/mount-liberty__001.jpg",
            "creditText": "Nathan Sobol"
          },
          {
            "@type": "ImageObject",
            "name": "Mount Washington summit",
            "caption": "Mount Washington summit buildings and observation deck above the clouds.",
            "contentUrl": "https://photos.nh48.info/cdn-cgi/image/format=webp,quality=85,width=720/mount-washington/mount-washington__001.jpg",
            "thumbnailUrl": "https://photos.nh48.info/cdn-cgi/image/format=webp,quality=85,width=720/mount-washington/mount-washington__001.jpg",
            "creditText": "Nathan Sobol"
          }
        ]
      }
    </script>
    <!--
      Enhanced catalog page for the NH48 peak list.

      This version adds:
        • Larger cards in a 2-column layout.
        • Sort-by dropdown covering all general info API fields.
        • A two-tier filter: 1) choose field, 2) choose value (Range, Difficulty, Trail Type, Exposure).
        • Cards display the same "General Peak Info" as the details page.
    -->
  </head>
  <body data-route="catalog" data-page="catalog">
    <div id="nav-placeholder"></div>
    <script>
      document.addEventListener('DOMContentLoaded', () => {
        const navPlaceholder = document.getElementById('nav-placeholder');
        const activeRoute = document.body.dataset.route || document.body.dataset.page;

        if (navPlaceholder) {
          fetch('/pages/nav.html')
            .then(response => response.text())
            .then(html => {
              navPlaceholder.innerHTML = html;
              const links = navPlaceholder.querySelectorAll('.site-nav-links a');
              links.forEach(link => {
                const routes = (link.dataset.routes || link.dataset.route || '')
                  .split(',')
                  .map(value => value.trim())
                  .filter(Boolean);

                if (routes.includes(activeRoute)) {
                  link.classList.add('active');
                  link.setAttribute('aria-current', 'page');
                }
              });
            })
            .catch(err => console.error('Failed to load navigation:', err));
        }

      });
    </script>
    <div class="wrap">
      <!-- Catalog Controls Panel -->
      <div class="catalog-controls-panel">
        <div class="catalog-hero">
          <h1 data-i18n="catalog.title">NH48 Peak Catalog</h1>
          <p data-i18n="catalog.intro">Explore all forty-eight of New Hampshire’s 4,000-footers in one interactive catalog. Click any peak to view detailed summit info, routes, difficulty, and photos w/ creator metadata.</p>
        </div>
        <!-- Search Row -->
        <div class="search-row">
          <div class="search-wrapper">
            <svg class="search-icon" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.3-4.3"/></svg>
            <input type="text" id="searchInput" list="nameSuggestions" placeholder="Search peaks by name…" aria-label="Search peaks by name" />
            <datalist id="nameSuggestions"></datalist>
          </div>
        </div>

        <!-- Filters Row -->
        <div class="filters-row">
          <div class="filter-group">
            <label for="sortSelect">Sort</label>
            <select id="sortSelect" aria-label="Sort peaks by attribute">
              <option value="range-asc" selected>By Range</option>
              <option value="name">Name (A–Z)</option>
              <option value="elev-desc">Elevation ↓</option>
              <option value="elev-asc">Elevation ↑</option>
              <option value="prom-desc">Prominence ↓</option>
              <option value="prom-asc">Prominence ↑</option>
              <option value="difficulty-asc">Difficulty</option>
              <option value="trail-asc">Trail Type</option>
              <option value="exposure-asc">Exposure</option>
            </select>
          </div>
          <div class="filter-group">
            <label for="unitsSelect">Units</label>
            <select id="unitsSelect" aria-label="Select units">
              <option value="feet">Feet</option>
              <option value="meters">Meters</option>
            </select>
          </div>
          <div class="filter-group column-selector-control">
            <label for="columnSelect">Columns</label>
            <select id="columnSelect" aria-label="Select number of columns">
              <option value="2">2</option>
              <option value="3">3</option>
              <option value="4" selected>4</option>
              <option value="5">5</option>
            </select>
          </div>
          <div class="filter-group">
            <label for="viewSelect">View</label>
            <select id="viewSelect" aria-label="Select catalog view">
              <option value="grid" selected>Grid</option>
              <option value="list">List</option>
            </select>
          </div>
          <div class="filter-group">
            <label for="groupByRangeToggle">Group by Range</label>
            <input type="checkbox" id="groupByRangeToggle" checked aria-label="Toggle grouping by mountain range">
          </div>
          <div class="filter-group api-toggle">
            <label for="apiVariablesToggle">API Labels</label>
            <input type="checkbox" id="apiVariablesToggle" aria-label="Toggle API variable labels">
          </div>
          <div class="filter-group lang-control">
            <div class="nh48-lang" id="langPicker" aria-label="Language picker"></div>
          </div>
          <a href="/submit-edit" class="submit-edit-btn">Submit Edit</a>
        </div>

        <!-- Jump to Range (visible only when grouping is enabled) -->
        <div id="rangeJumpLinks" class="range-jump-bar">
          <span class="jump-label">Jump to range:</span>
          <div class="jump-links"></div>
        </div>
      </div>

      <nav aria-label="Breadcrumb" class="breadcrumb-trail" itemscope itemtype="https://schema.org/BreadcrumbList">
        <ol>
          <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
            <a href="/" itemprop="item"><span itemprop="name">Home</span></a>
            <meta itemprop="position" content="1">
          </li>
          <li aria-current="page" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
            <span itemprop="name">Catalog</span>
            <meta itemprop="item" content="https://nh48.info/catalog">
            <meta itemprop="position" content="2">
          </li>
        </ol>
      </nav>

      <div id="catalogLoading" class="loading-indicator" aria-live="polite">
        <span class="loading-spinner" aria-hidden="true"></span>
        <span class="loading-text" data-i18n="common.loading">Loading…</span>
      </div>
      <div id="grid" class="grid"></div>
      <div id="emptyMessage" class="empty" data-i18n="catalog.empty" hidden>No peaks found.</div>
    </div>

    <script>
      // API endpoints to attempt in order.
      const API_URLS = [
        'https://cdn.jsdelivr.net/gh/natesobol/nh48-api@main/data/nh48.json',
        'https://raw.githubusercontent.com/natesobol/nh48-api/main/data/nh48.json'
      ];
      const RANGE_DATA_URLS = [
        '/data/wmnf-ranges.json',
        'https://cdn.jsdelivr.net/gh/natesobol/nh48-api@main/data/wmnf-ranges.json',
        'https://raw.githubusercontent.com/natesobol/nh48-api/main/data/wmnf-ranges.json'
      ];
      const IMAGE_TRANSFORM_OPTIONS = 'format=webp,quality=85,width=720';
      const PHOTO_BASE_URL = 'https://photos.nh48.info';
      const PHOTO_BASE = new URL(PHOTO_BASE_URL);
      const IMAGE_TRANSFORM_PREFIX = `${PHOTO_BASE.origin}/cdn-cgi/image/${IMAGE_TRANSFORM_OPTIONS}`;
      const PHOTO_PATH_PREFIX = '/nh48-photos/';

      const t = (key, vars) => (window.NH48_I18N && window.NH48_I18N.t ? window.NH48_I18N.t(key, vars) : key);

      const trackEvent = (name, params = {}) => {
        const analytics = window.NH48_INFO_ANALYTICS;
        if (analytics && analytics.logEvent && analytics.analytics) {
          analytics.logEvent(analytics.analytics, name, {
            page: location.pathname,
            ...params
          });
        }
      };

      function getPlaceholder() {
        return 'data:image/svg+xml;utf8,' + encodeURIComponent(
          `<svg xmlns="http://www.w3.org/2000/svg" width="1200" height="800"><rect width="100%" height="100%" fill="#172032"/><text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="#64748b" font-family="system-ui" font-size="22">${t('common.noImage')}</text></svg>`
        );
      }

      function applyImageTransform(url){
        if(!url) return url;
        try {
          const parsed = new URL(url, window.location.origin);
          if(parsed.pathname.startsWith('/cdn-cgi/image/')){
            return url;
          }
          if(parsed.hostname === PHOTO_BASE.hostname){
            const normalizedPath = parsed.pathname.startsWith('/') ? parsed.pathname : `/${parsed.pathname}`;
            return `${IMAGE_TRANSFORM_PREFIX}${normalizedPath}${parsed.search || ''}`;
          }
        } catch (err) {
          console.warn('Unable to normalize photo URL', url, err);
        }
        return url;
      }

      function normalizePhotoUrl(url){
        if(!url) return url;
        if(url.startsWith(PHOTO_BASE_URL)) return applyImageTransform(url);
        const isJsdelivrPhoto = url.includes('cdn.jsdelivr.net/gh/natesobol/nh48-api@main/photos/');
        const isGithubRawPhoto = url.includes('raw.githubusercontent.com/natesobol/nh48-api/main/photos/');
        const isR2PathStyle = url.includes('r2.cloudflarestorage.com/nh48-photos/');
        const isR2BucketHost = url.includes('r2.cloudflarestorage.com/') && !url.includes('/nh48-photos/');
        let normalized = url;
        if(isR2PathStyle){
          const [, tail] = url.split(PHOTO_PATH_PREFIX);
          normalized = tail ? `${PHOTO_BASE_URL}/${tail}` : url;
        }
        if(isR2BucketHost){
          const bucketTail = url.split('r2.cloudflarestorage.com/')[1];
          if(bucketTail){
            const normalizedTail = bucketTail.replace(/^nh48-photos\//, '');
            normalized = `${PHOTO_BASE_URL}/${normalizedTail}`;
          }
        }
        if(isJsdelivrPhoto || isGithubRawPhoto){
          const [, tail] = url.split('/photos/');
          normalized = tail ? `${PHOTO_BASE_URL}/${tail}` : url;
        }
        if(normalized.startsWith(PHOTO_BASE_URL)){
          return applyImageTransform(normalized);
        }
        return normalized;
      }

      function toTransformedPhotoUrl(url){
        const normalized = normalizePhotoUrl(url);
        if(!normalized) return normalized;
        if(normalized.includes('/cdn-cgi/image/')){
          return normalized;
        }
        return applyImageTransform(normalized);
      }

      let peaks = [];
      let rangesData = {};
      let activeSort = 'range-asc';
      let groupByRangeEnabled = true;

      const UNIT_STORAGE_KEY = 'nh48_units';
      const API_VARIABLES_STORAGE_KEY = 'nh48-catalog-api-variables';
      const GROUP_BY_RANGE_KEY = 'nh48-catalog-group-by-range';
      const UNITS = {
        FEET: 'feet',
        METERS: 'meters'
      };
      let currentUnits = UNITS.FEET;
      let showApiVariables = false;

      const FRIENDLY_LABELS = {
        elevation: 'catalog.card.elevation',
        prominence: 'catalog.card.prominence',
        range: 'catalog.card.range',
        trailType: 'catalog.card.trailType',
        difficulty: 'catalog.card.difficulty',
        exposure: 'catalog.card.exposure'
      };

      const FRIENDLY_LABEL_TEXT = {
        elevation: 'Elevation',
        prominence: 'Prominence',
        range: 'Range',
        trailType: 'Trail Type',
        difficulty: 'Difficulty',
        exposure: 'Exposure'
      };

      const API_LABELS = {
        elevation: 'Elevation (ft)',
        prominence: 'Prominence (ft)',
        range: 'Range / Subrange',
        trailType: 'Trail Type',
        difficulty: 'Difficulty',
        exposure: 'Exposure Level'
      };

      function getCatalogLabel(key){
        if(showApiVariables){
          return API_LABELS[key] || key;
        }
        const i18nKey = FRIENDLY_LABELS[key];
        if(i18nKey){
          const translated = t(i18nKey);
          if(translated && !translated.startsWith('catalog.') && !translated.includes('card.')){
            return translated;
          }
        }
        return FRIENDLY_LABEL_TEXT[key] || key;
      }

      function cleanJSON(raw){
        let cleaned = raw.replace(/:contentReference\[.*?\]\{index=\d+\}/g, '');
        cleaned = cleaned.replace(/\/\*\s*Lines?\s+\d+[\d\-,\s]*omitted\s*\*\//g, '');
        return cleaned;
      }

      async function fetchPeaks(){
        for(let i=0;i<API_URLS.length;i++){
          const url = API_URLS[i];
          try{
            const res = await fetch(url, { mode:'cors' });
            if(!res.ok){
              console.log(`Attempt ${i+1}: Status ${res.status} ${res.statusText}`);
              continue;
            }
            const text = await res.text();
            const cleaned = cleanJSON(text);
            let obj;
            try{
              obj = JSON.parse(cleaned);
            }catch(err){
              console.error(`JSON parse error: ${err.message}`);
              continue;
            }
            const arr = Object.keys(obj).map(slug => {
              const p = obj[slug] || {};
              p.slug = slug;
              p.peakName = p.peakName || p['Peak Name'] || slug;
              return p;
            });
            console.log(`Loaded ${arr.length} peaks from ${url}`);
            trackEvent('catalog_data_loaded', { source: url, count: arr.length });
            return arr;
          }catch(err){
            console.error(`Fetch error: ${err.message || err}`);
            trackEvent('catalog_data_fetch_error', { source: url });
          }
        }
        throw new Error('All API endpoints failed');
      }

      async function fetchRanges(){
        for(const url of RANGE_DATA_URLS){
          try{
            const res = await fetch(url, { mode: 'cors' });
            if(!res.ok) continue;
            const text = await res.text();
            const cleaned = cleanJSON(text);
            const obj = JSON.parse(cleaned);
            if(obj && typeof obj === 'object'){
              return obj;
            }
          }catch(err){
            console.warn(`Failed to fetch ranges from ${url}:`, err);
          }
        }
        throw new Error('All range endpoints failed');
      }

      function normalizeToken(value){
        return String(value || '').trim().toLowerCase();
      }

      function translateSeason(value){
        const key = normalizeToken(value);
        const map = {
          spring: 'season.spring',
          summer: 'season.summer',
          fall: 'season.fall',
          autumn: 'season.autumn',
          winter: 'season.winter'
        };
        return map[key] ? t(map[key]) : value;
      }

      function translateTimeOfDay(value){
        const key = normalizeToken(value);
        const map = {
          sunrise: 'time.sunrise',
          sunset: 'time.sunset',
          morning: 'time.morning',
          afternoon: 'time.afternoon',
          evening: 'time.evening',
          night: 'time.night',
          day: 'time.day',
          dawn: 'time.dawn',
          dusk: 'time.dusk'
        };
        return map[key] ? t(map[key]) : value;
      }

      const TRAIL_TYPE_TRANSLATIONS = {
        'Loop': 'values.trailType.loop',
        'Loop or Out & back': 'values.trailType.loop_or_out_back',
        'Loop or traverse': 'values.trailType.loop_or_traverse',
        'Loop or traverse along ridge': 'values.trailType.loop_or_traverse_along_ridge',
        'Out & back': 'values.trailType.out_back',
        'Out & back  - common.': 'values.trailType.out_back_common',
        'Out & back  - common. or long traverse': 'values.trailType.out_back_common_or_long_traverse',
        'Out & back  - common. or loop with connector trails': 'values.trailType.out_back_common_or_loop_with_connector_trails',
        'Out & back  - common. or small loop including Mt Webster': 'values.trailType.out_back_common_or_small_loop_including_mt_webster',
        'Out & back  - commonly.': 'values.trailType.out_back_commonly',
        'Out & back or loop': 'values.trailType.out_back_or_loop',
        'Out & back or loop  - with Tom and Willey.': 'values.trailType.out_back_or_loop_with_tom_and_willey',
        'Out & back or loop combining trails': 'values.trailType.out_back_or_loop_combining_trails',
        'Out & back or loop options': 'values.trailType.out_back_or_loop_options',
        'Out & back or point-to-point traverse': 'values.trailType.out_back_or_point_to_point_traverse',
        'Out & back or traverse': 'values.trailType.out_back_or_traverse'
      };

      const DIFFICULTY_TRANSLATIONS = {
        'Moderate': 'values.difficulty.moderate',
        'Moderate/Difficult': 'values.difficulty.moderate_difficult',
        'Difficult': 'values.difficulty.difficult',
        'Very Difficult': 'values.difficulty.very_difficult',
        'Very difficult': 'values.difficulty.very_difficult',
        'Extremely Difficult': 'values.difficulty.extremely_difficult'
      };

      function translateTrailType(value){
        if(!value || showApiVariables) return value;
        const raw = String(value);
        const key = raw.startsWith('values.trailType.') ? raw : TRAIL_TYPE_TRANSLATIONS[raw];
        if(!key) return value;
        const translated = t(key);
        return translated && translated !== key && !translated.startsWith('values.') ? translated : value;
      }

      function translateDifficulty(value){
        if(!value || showApiVariables) return value;
        const raw = String(value);
        const key = raw.startsWith('values.difficulty.') ? raw : DIFFICULTY_TRANSLATIONS[raw];
        if(!key) return value;
        const translated = t(key);
        return translated && translated !== key && !translated.startsWith('values.') ? translated : value;
      }

      function translateExposure(value){
        if(!value || showApiVariables) return value;
        const trimmed = String(value).trim();
        if(trimmed.startsWith('values.exposure.')){
          const translated = t(trimmed);
          if(translated && translated !== trimmed && !translated.startsWith('values.exposure')){
            return translated;
          }
          return value;
        }
        const match = trimmed.match(/^(Low to Medium|Low|Medium|High)/i);
        if(!match) return value;
        const normalized = match[1].toLowerCase().replace(/\s+/g, '_');
        const translated = t(`values.exposure.${normalized}`);
        if(!translated || translated.startsWith('values.exposure')) return value;
        return trimmed.replace(match[1], translated);
      }

      function formatElevation(value){
        if(value === undefined || value === null || value === '') return '—';
        const num = Number(value);
        if(!Number.isFinite(num)) return '—';
        if(currentUnits === UNITS.METERS){
          return `${Math.round(num * 0.3048)} m`;
        }
        return `${num} ft`;
      }

      function formatProminence(value){
        return formatElevation(value);
      }

      function setUnits(units, { persist = true } = {}){
        if(!Object.values(UNITS).includes(units)){
          units = UNITS.FEET;
        }
        currentUnits = units;
        const select = document.getElementById('unitsSelect');
        if(select){
          select.value = units;
        }
        if(persist){
          localStorage.setItem(UNIT_STORAGE_KEY, units);
        }
      }

      function setApiVariableLabels(enabled, { persist = true } = {}){
        showApiVariables = Boolean(enabled);
        const toggle = document.getElementById('apiVariablesToggle');
        if(toggle){
          toggle.checked = showApiVariables;
        }
        if(persist){
          localStorage.setItem(API_VARIABLES_STORAGE_KEY, showApiVariables ? 'true' : 'false');
        }
      }

      function syncUnitsWithLanguage(lang){
        if(lang && lang !== 'en'){
          setUnits(UNITS.METERS, { persist: false });
        }else{
          setUnits(UNITS.FEET, { persist: false });
        }
      }

      function setCatalogLoading(isLoading){
        const loadingEl = document.getElementById('catalogLoading');
        const grid = document.getElementById('grid');
        if(loadingEl){
          loadingEl.hidden = !isLoading;
        }
        if(grid){
          grid.hidden = isLoading;
        }
      }

      function buildPhotoAlt(p, photo){
        if(photo && typeof photo === 'object'){
          const explicit = photo.alt && String(photo.alt).trim();
          if(explicit){
            return explicit;
          }
          const season = photo.season ? translateSeason(photo.season) : '';
          const timeOfDay = photo.timeOfDay ? translateTimeOfDay(photo.timeOfDay) : '';
          const text = t('photo.altTemplate', {
            peak: p.peakName,
            season: season ? `${season}` : '',
            timeOfDay: timeOfDay ? `${timeOfDay}` : ''
          }).replace(/\s+/g, ' ').replace(/\s—\s$/, '').trim();
          return text.replace(/\s—\s$/, '').replace(/\s$/, '').replace(/—\s*$/, '').trim();
        }
        return t('photo.altTemplate', { peak: p.peakName, season: '', timeOfDay: '' }).replace(/\s+/g, ' ').replace(/\s—\s$/, '').trim();
      }

      function getPrimaryPhoto(photos){
        if(!Array.isArray(photos) || photos.length === 0) return null;
        const primary = photos.find(photo => photo && typeof photo === 'object' && photo.isPrimary);
        return primary || photos[0];
      }

      function createCard(p){
        const card = document.createElement('article');
        card.className = 'card';

        // Thumbnail
        const placeholder = getPlaceholder();
        let thumbSrc = placeholder;
        let thumbAlt = t('photo.altTemplate', { peak: p.peakName, season: '', timeOfDay: '' }).replace(/\s+/g, ' ').replace(/\s—\s$/, '').trim();
        if (Array.isArray(p.photos) && p.photos.length > 0) {
          const primaryPhoto = getPrimaryPhoto(p.photos);
          thumbAlt = buildPhotoAlt(p, primaryPhoto);
          if (typeof primaryPhoto === 'string') {
            thumbSrc = toTransformedPhotoUrl(primaryPhoto);
          } else if (primaryPhoto && primaryPhoto.url) {
            thumbSrc = toTransformedPhotoUrl(primaryPhoto.url);
          }
        }

        const elev = p['Elevation (ft)'];
        const prom = p['Prominence (ft)'];
        const range = p['Range / Subrange'] || '—';
        const trail = translateTrailType(p['Trail Type']) || '—';
        const difficulty = translateDifficulty(p['Difficulty']) || '—';
        const exposure = translateExposure(p['Exposure Level'] || p['Weather Exposure Rating']) || '—';

        const dataSrc = thumbSrc !== placeholder ? thumbSrc : '';
        card.innerHTML = `
          <div class="thumb">
            <img src="${placeholder}" ${dataSrc ? `data-src="${dataSrc}"` : ''} alt="${thumbAlt}" loading="lazy" decoding="async">
          </div>
          <div class="body">
            <h3>${p.peakName}</h3>
            <div class="card-meta">
              <div class="meta-row"><span class="meta-label">${getCatalogLabel('elevation')}</span><span class="meta-value">${formatElevation(elev)}</span></div>
              <div class="meta-row"><span class="meta-label">${getCatalogLabel('prominence')}</span><span class="meta-value">${formatProminence(prom)}</span></div>
              <div class="meta-row"><span class="meta-label">${getCatalogLabel('range')}</span><span class="meta-value">${range}</span></div>
              <div class="meta-row"><span class="meta-label">${getCatalogLabel('trailType')}</span><span class="meta-value">${trail}</span></div>
              <div class="meta-row"><span class="meta-label">${getCatalogLabel('difficulty')}</span><span class="meta-value">${difficulty}</span></div>
              <div class="meta-row"><span class="meta-label">${getCatalogLabel('exposure')}</span><span class="meta-value">${exposure}</span></div>
            </div>
          </div>`;

        card.addEventListener('click', () => {
          trackEvent('catalog_peak_open', { slug: p.slug, name: p.peakName });
          window.location.href = `/peak/${encodeURIComponent(p.slug)}/`;
        });

        return card;
      }

      function createListItem(p){
        const item = document.createElement('article');
        item.className = 'list-item';

        const placeholder = getPlaceholder();
        let thumbSrc = placeholder;
        let thumbAlt = t('photo.altTemplate', { peak: p.peakName, season: '', timeOfDay: '' }).replace(/\s+/g, ' ').replace(/\s—\s$/, '').trim();
        if (Array.isArray(p.photos) && p.photos.length > 0) {
          const primaryPhoto = getPrimaryPhoto(p.photos);
          thumbAlt = buildPhotoAlt(p, primaryPhoto);
          if (typeof primaryPhoto === 'string') {
            thumbSrc = toTransformedPhotoUrl(primaryPhoto);
          } else if (primaryPhoto && primaryPhoto.url) {
            thumbSrc = toTransformedPhotoUrl(primaryPhoto.url);
          }
        }

        const elev = p['Elevation (ft)'];
        const range = p['Range / Subrange'] || '—';
        const href = `/peak/${encodeURIComponent(p.slug)}/`;

        const dataSrc = thumbSrc !== placeholder ? thumbSrc : '';
        item.innerHTML = `
          <div class="list-thumb">
            <img src="${placeholder}" ${dataSrc ? `data-src="${dataSrc}"` : ''} alt="${thumbAlt}" loading="lazy" decoding="async">
          </div>
          <div class="list-content">
            <div class="list-main">
              <h3>${p.peakName}</h3>
              <div class="list-meta">
                <div>
                  <span class="list-label">${getCatalogLabel('elevation')}</span>
                  <span>${formatElevation(elev)}</span>
                </div>
                <div>
                  <span class="list-label">${getCatalogLabel('range')}</span>
                  <span>${range}</span>
                </div>
              </div>
            </div>
            <a class="list-link" href="${href}">View details →</a>
          </div>
        `;

        item.addEventListener('click', () => {
          trackEvent('catalog_peak_open', { slug: p.slug, name: p.peakName });
          window.location.href = href;
        });

        return item;
      }

      function setupLazyLoading(){
        const imgs = Array.from(document.querySelectorAll('img[data-src]'));
        if(imgs.length === 0) return;

        if (!('IntersectionObserver' in window)) {
          imgs.forEach(img => {
            const real = img.getAttribute('data-src');
            if(real){ img.src = real; img.removeAttribute('data-src'); }
          });
          return;
        }

        const observer = new IntersectionObserver((entries, obs) => {
          entries.forEach(entry => {
            if(entry.isIntersecting){
              const img = entry.target;
              const real = img.getAttribute('data-src');
              if(real){ img.src = real; img.removeAttribute('data-src'); }
              obs.unobserve(img);
            }
          });
        }, { rootMargin: '200px' });
        imgs.forEach(img => observer.observe(img));
      }

      function deferInitialImageLoads(){
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            setupLazyLoading();
          });
        });
      }

      function renderGrid(list){
        const grid = document.getElementById('grid');
        const empty = document.getElementById('emptyMessage');
        grid.innerHTML = '';
        if(!list || list.length === 0){
          empty.hidden = false;
          return;
        }
        empty.hidden = true;
        list.forEach(p => grid.appendChild(createCard(p)));
        deferInitialImageLoads();
      }

      // Return canonical range info { name, id } for a given peak object.
      function getRangeInfo(peak){
        if(!peak || !rangesData || typeof rangesData !== 'object'){
          return { name: 'Other', id: 'other' };
        }
        for(const [slug, range] of Object.entries(rangesData)){
          if(range && Array.isArray(range.peakList) && range.peakList.includes(peak.peakName)){
            return { id: slug, name: range.rangeName || 'Other' };
          }
        }
        return { id: 'other', name: 'Other' };
      }

      function renderGridByRange(list){
        const grid = document.getElementById('grid');
        const empty = document.getElementById('emptyMessage');
        grid.innerHTML = '';
        if(!list || list.length === 0){
          empty.hidden = false;
          return;
        }
        empty.hidden = true;

        const orderedRanges = Object.entries(rangesData || {}).map(([slug, range]) => ({
          id: range.slug,
          slug,
          name: range?.rangeName || slug,
          peaks: Array.isArray(range?.peakList)
            ? list.filter(p => range.peakList.includes(p.peakName))
            : []
        }));

        const unmatchedPeaks = list.filter(p => !orderedRanges.some(range => range.peaks.includes(p)));
        if(unmatchedPeaks.length > 0){
          orderedRanges.push({
            id: 'other',
            slug: 'other',
            name: 'Other',
            peaks: unmatchedPeaks
          });
        }

        const jumpLinksContainer = document.querySelector('#rangeJumpLinks .jump-links');
        if(jumpLinksContainer){
          jumpLinksContainer.innerHTML = '';
          orderedRanges.forEach(range => {
            const link = document.createElement('a');
            link.href = `#range-${range.id}`;
            link.textContent = range.name;
            jumpLinksContainer.appendChild(link);
          });
        }

        orderedRanges.forEach((range, index) => {
          const peakCount = range.peaks.length;

          const section = document.createElement('section');
          section.className = 'range-section';
          section.id = 'range-' + range.id;

          const heading = document.createElement('h2');
          heading.className = 'range-heading';
          heading.innerHTML = `${range.name} <span class="range-count">(${peakCount})</span>`;
          section.appendChild(heading);

          const rangeGrid = document.createElement('div');
          rangeGrid.className = 'range-grid';
          rangeGrid.setAttribute('data-columns', document.getElementById('columnSelect')?.value || '3');

          // Determine sorting function based on activeSort
          const comparator = (a, b) => {
            switch(activeSort){
              case 'name':
                return (a.peakName || '').localeCompare(b.peakName || '');
              case 'elev-asc':
                return (a['Elevation (ft)'] || 0) - (b['Elevation (ft)'] || 0);
              case 'elev-desc':
                return (b['Elevation (ft)'] || 0) - (a['Elevation (ft)'] || 0);
              case 'prom-asc':
                return (a['Prominence (ft)'] || 0) - (b['Prominence (ft)'] || 0);
              case 'prom-desc':
                return (b['Prominence (ft)'] || 0) - (a['Prominence (ft)'] || 0);
              case 'difficulty-asc':
                return (a['Difficulty'] || '').localeCompare(b['Difficulty'] || '');
              case 'difficulty-desc':
                return (b['Difficulty'] || '').localeCompare(a['Difficulty'] || '');
              case 'trail-asc':
                return (a['Trail Type'] || '').localeCompare(b['Trail Type'] || '');
              case 'exposure-asc':
                return (a['Exposure Level'] || a['Weather Exposure Rating'] || '')
                  .localeCompare(b['Exposure Level'] || b['Weather Exposure Rating'] || '');
              default:
                return (a['Range / Subrange'] || '').localeCompare(b['Range / Subrange'] || '');
            }
          };

          // Sort each group with the comparator
          const peaksInRange = range.peaks.sort(comparator);
          peaksInRange.forEach(p => rangeGrid.appendChild(createCard(p)));

          section.appendChild(rangeGrid);
          grid.appendChild(section);

          if(index < orderedRanges.length - 1){
            const divider = document.createElement('div');
            divider.className = 'range-divider';
            grid.appendChild(divider);
          }
        });

        deferInitialImageLoads();
      }

      function renderList(list){
        const grid = document.getElementById('grid');
        const empty = document.getElementById('emptyMessage');
        grid.innerHTML = '';
        if(!list || list.length === 0){
          empty.hidden = false;
          return;
        }
        empty.hidden = true;
        list.forEach(p => grid.appendChild(createListItem(p)));
        deferInitialImageLoads();
      }

      // Build suggestions list, stripping common words
      function updateSuggestions(){
        const list = peaks.map(p => p.peakName.replace(/\b(Mount|Mountain|Peak)\b/gi, '').trim()).filter(Boolean);
        const seen = new Set();
        const unique = [];
        list.forEach(name => {
          const key = name.toLowerCase();
          if(!seen.has(key)){
            seen.add(key);
            unique.push(name);
          }
        });
        const dl = document.getElementById('nameSuggestions');
        dl.innerHTML = unique.sort().map(name => `<option value="${name}"></option>`).join('');
      }

      function sortPeaks(list){
        const arr = list.slice();
        arr.sort((a, b) => {
          switch(activeSort){
            case 'name':
              return (a.peakName || '').localeCompare(b.peakName || '');
            case 'elev-asc':
              return (a['Elevation (ft)'] || 0) - (b['Elevation (ft)'] || 0);
            case 'elev-desc':
              return (b['Elevation (ft)'] || 0) - (a['Elevation (ft)'] || 0);
            case 'prom-asc':
              return (a['Prominence (ft)'] || 0) - (b['Prominence (ft)'] || 0);
            case 'prom-desc':
              return (b['Prominence (ft)'] || 0) - (a['Prominence (ft)'] || 0);
            case 'difficulty-asc':
              return ((a['Difficulty'] || '')).localeCompare((b['Difficulty'] || ''));
            case 'difficulty-desc':
              return ((b['Difficulty'] || '')).localeCompare((a['Difficulty'] || ''));
            case 'range-asc':
              return ((a['Range / Subrange'] || '')).localeCompare((b['Range / Subrange'] || ''));
            case 'trail-asc':
              return ((a['Trail Type'] || '')).localeCompare((b['Trail Type'] || ''));
            case 'exposure-asc':
              return ((a['Exposure Level'] || a['Weather Exposure Rating'] || ''))
                .localeCompare((b['Exposure Level'] || b['Weather Exposure Rating'] || ''));
          }
          return 0;
        });
        return arr;
      }

      function updateDisplay(){
        let list = peaks;

        // Search filter from input
        const searchVal = document.getElementById('searchInput').value.trim().toLowerCase();
        if(searchVal){
          list = list.filter(p => p.peakName && p.peakName.toLowerCase().includes(searchVal));
        }

        list = sortPeaks(list);

        // Show/hide range jump bar based on grouping and view type
        const rangeJumpBar = document.getElementById('rangeJumpLinks');
        if(rangeJumpBar){
          if(groupByRangeEnabled && currentView === 'grid'){
            rangeJumpBar.classList.add('visible');
          }else{
            rangeJumpBar.classList.remove('visible');
          }
        }

        if(currentView === 'list'){
          if(grid){
            grid.classList.remove('range-view');
          }
          renderList(list);
        }else{
          if(groupByRangeEnabled){
            if(grid){
              grid.classList.add('range-view');
            }
            renderGridByRange(list);
          }else{
            if(grid){
              grid.classList.remove('range-view');
            }
            renderGrid(list);
          }
        }
      }

      async function init(){
        const groupToggle = document.getElementById('groupByRangeToggle');
        try{
          setCatalogLoading(true);
          rangesData = await fetchRanges();
          peaks = await fetchPeaks();
          updateSuggestions();
          const savedGroup = localStorage.getItem(GROUP_BY_RANGE_KEY);
          groupByRangeEnabled = savedGroup !== null ? savedGroup === 'true' : true;
          if(groupToggle){
            groupToggle.checked = groupByRangeEnabled;
          }
          updateDisplay();
          trackEvent('catalog_render_complete', { peakCount: peaks.length });
        }catch(err){
          console.error('Error loading peaks:', err);
          trackEvent('catalog_data_failed', { message: err.message });
          const emptyMessage = document.getElementById('emptyMessage');
          if (emptyMessage) {
            emptyMessage.textContent = t('catalog.error');
            emptyMessage.hidden = false;
          }
        }finally{
          setCatalogLoading(false);
        }

        const searchInput = document.getElementById('searchInput');
        if (searchInput) {
          let searchDebounce;
          searchInput.addEventListener('input', () => {
            updateDisplay();
            clearTimeout(searchDebounce);
            searchDebounce = setTimeout(() => {
              trackEvent('catalog_search', { query: searchInput.value.trim().toLowerCase() });
            }, 400);
          });
        }

        const sortSelect = document.getElementById('sortSelect');
        if (sortSelect) {
          sortSelect.addEventListener('change', (e) => {
            activeSort = e.target.value;
            updateDisplay();
            trackEvent('catalog_sort_change', { sort: activeSort });
          });
        }
        const unitsSelect = document.getElementById('unitsSelect');
        if(unitsSelect){
          unitsSelect.addEventListener('change', (e) => {
            setUnits(e.target.value);
            updateDisplay();
            trackEvent('catalog_units_change', { units: e.target.value });
          });
        }
        const apiVariablesToggle = document.getElementById('apiVariablesToggle');
        if(apiVariablesToggle){
          apiVariablesToggle.addEventListener('change', (e) => {
            setApiVariableLabels(e.target.checked);
            updateDisplay();
            trackEvent('catalog_api_variables_toggle', { enabled: e.target.checked });
          });
        }
        if(groupToggle){
          groupToggle.addEventListener('change', (e) => {
            groupByRangeEnabled = e.target.checked;
            localStorage.setItem(GROUP_BY_RANGE_KEY, groupByRangeEnabled ? 'true' : 'false');
            updateDisplay();
            trackEvent('catalog_group_toggle', { enabled: groupByRangeEnabled });
          });
        }
      }

      window.addEventListener('load', init);

      if (window.NH48_I18N && window.NH48_I18N.onLangChange) {
        window.NH48_I18N.onLangChange((lang) => {
          syncUnitsWithLanguage(lang);
          updateDisplay();
          trackEvent('catalog_language_change', { language: lang });
        });
      }

      // Column selector handler
      const columnSelect = document.getElementById('columnSelect');
      const viewSelect = document.getElementById('viewSelect');
      const grid = document.getElementById('grid');
      const groupToggle = document.getElementById('groupByRangeToggle');
      const columnControl = columnSelect ? columnSelect.closest('.control') : null;
      let currentView = 'grid';

      const applyView = (view, { persist = true } = {}) => {
        currentView = view === 'list' ? 'list' : 'grid';
        if(viewSelect){
          viewSelect.value = currentView;
        }
        if(grid){
          grid.setAttribute('data-view', currentView);
        }
        if(columnSelect){
          const disableColumns = currentView === 'list';
          columnSelect.disabled = disableColumns;
          if(columnControl){
            columnControl.classList.toggle('is-disabled', disableColumns);
          }
        }
        if(persist){
          localStorage.setItem('nh48-catalog-view', currentView);
        }
      };
      
      const COLUMN_BREAKPOINT = 1400;
      const validColumns = ['2', '3', '4', '5'];
      let preferredColumns = '4';

      const applyColumns = (columns) => {
        if (columnSelect) {
          columnSelect.value = columns;
        }
        if (grid) {
          grid.setAttribute('data-columns', columns);
        }
        document.querySelectorAll('.range-grid').forEach(rg => {
          rg.setAttribute('data-columns', columns);
        });
      };

      const applyResponsiveColumns = () => {
        const shouldCompact = window.innerWidth < COLUMN_BREAKPOINT;
        const targetColumns = shouldCompact ? '3' : preferredColumns;
        applyColumns(targetColumns);
      };

      // Load saved column preference
      const savedColumns = localStorage.getItem('nh48-catalog-columns');
      if (savedColumns && validColumns.includes(savedColumns)) {
        preferredColumns = savedColumns;
      }
      applyResponsiveColumns();

      const savedView = localStorage.getItem('nh48-catalog-view');
      applyView(savedView || 'grid', { persist: false });

      syncUnitsWithLanguage(window.NH48_I18N ? window.NH48_I18N.getLang() : 'en');

      const savedApiVariables = localStorage.getItem(API_VARIABLES_STORAGE_KEY);
      if(savedApiVariables === 'true'){
        setApiVariableLabels(true, { persist: false });
      }

      const savedGroup = localStorage.getItem(GROUP_BY_RANGE_KEY);
      if(savedGroup === null){
        groupByRangeEnabled = true;
        localStorage.setItem(GROUP_BY_RANGE_KEY, 'true');
      }else{
        groupByRangeEnabled = savedGroup === 'true';
      }
      if(groupToggle){
        groupToggle.checked = groupByRangeEnabled;
      }
      
      columnSelect.addEventListener('change', function() {
        preferredColumns = this.value;
        localStorage.setItem('nh48-catalog-columns', preferredColumns);
        applyResponsiveColumns();
        trackEvent('catalog_columns_change', { columns: preferredColumns });
      });

      window.addEventListener('resize', applyResponsiveColumns);

      viewSelect.addEventListener('change', function() {
        applyView(this.value);
        updateDisplay();
        trackEvent('catalog_view_change', { view: currentView });
      });
    </script>
<script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-app.js";
      import { getAnalytics, logEvent } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-analytics.js";

      const firebaseConfig = {
        apiKey: "AIzaSyCUShYXwxGVEDNzMeIwSFPmDaYeXSqRK4A",
        authDomain: "nh48-info.firebaseapp.com",
        projectId: "nh48-info",
        storageBucket: "nh48-info.firebasestorage.app",
        messagingSenderId: "732743288228",
        appId: "1:732743288228:web:d82d62cae0c3999ee5ad31",
        measurementId: "G-Q9F2W8YB7D"
      };

      const app = initializeApp(firebaseConfig);
      const analytics = getAnalytics(app);

      // Expose globally for app scripts
      window.NH48_INFO_ANALYTICS = {
        analytics,
        logEvent
      };

      // Base page-load event
      logEvent(analytics, "page_loaded", {
        site: "nh48-info",
        page: location.pathname
      });
    </script>
    <div id="footer-placeholder"></div>
  </body>
</html>
