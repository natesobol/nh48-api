<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" href="/favicon.ico" sizes="any">
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32.png">
    <link rel="icon" type="image/png" sizes="48x48" href="/favicon-48x48.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/favicon-96x96.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>White Mountain Trails GeoJSON Editor</title>
    <link rel="icon" type="image/png" href="../WMNF_Trails_API_logo.png">
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      crossorigin=""
    />
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css"
    />
    <link rel="stylesheet" href="../css/geojson_editor.css" />
  </head>
  <body>
    <header class="page-header">
      <div class="title-block">
        <h1>White Mountain Trails GeoJSON Editor</h1>
        <p>View, adjust, and export <code>merged_trails.geojson</code> directly in the browser.</p>
      </div>
      <div class="action-row">
        <button id="loadLocal" class="secondary">Load Local File</button>
        <label for="fileInput" class="file-label">Import GeoJSON<input id="fileInput" type="file" accept="application/geo+json,application/json,.geojson" /></label>
        <button id="reset" class="secondary">Reset</button>
        <button id="download" class="primary">Download Edited GeoJSON</button>
      </div>
    </header>

    <main class="layout">
      <section class="sidebar">
        <div class="status">
          <h2>Status</h2>
          <dl>
            <div>
              <dt>Features loaded</dt>
              <dd id="featureCount">0</dd>
            </div>
            <div>
              <dt>Last action</dt>
              <dd id="lastAction">Waiting for data…</dd>
            </div>
          </dl>
        </div>
        <div class="help">
          <h2>How to use</h2>
          <ol>
            <li>Click <strong>Load Local File</strong> to fetch <code>merged_trails.geojson</code> from this repository.</li>
            <li>Use the draw toolbar to add, edit, or delete trail geometries.</li>
            <li>Click a trail to inspect its properties. Update metadata in the popup form.</li>
            <li>When finished, click <strong>Download Edited GeoJSON</strong> to save your changes.</li>
          </ol>
        </div>

        <div class="details">
          <div class="details__header">
            <h2>Trail details</h2>
            <p>View OpenStreetMap fields for the selected trail. Works even if <code>trail_properties.json</code> is missing.</p>
          </div>
          <div class="details__actions">
            <button id="loadTrailProperties" class="secondary">Load trail_properties.json</button>
          </div>
          <div class="details__body">
            <div class="details__title" id="detailTrailName">Select a trail to see details</div>
            <div class="details__status" id="detailStatus">No trail selected.</div>
            <div class="details__grid" id="detailGrid"></div>
          </div>
        </div>

        <div class="importer">
          <div class="importer__header">
            <h2>Trail Properties (OSM)</h2>
            <p>Bulk-fetch OpenStreetMap metadata by trail name and export a <code>trail_properties.json</code> file.</p>
          </div>

          <div class="importer__controls">
            <label class="input-label" for="trailNames">Trail names to import</label>
            <textarea
              id="trailNames"
              placeholder="One trail name per line. Use 'Populate from map' to gather names from the loaded GeoJSON."
              rows="6"
            ></textarea>
            <div class="importer__buttons">
              <button id="populateNames" class="secondary">Populate from map</button>
              <button id="startImport" class="primary">Import trails (OSM + USFS)</button>
            </div>
          </div>

          <div class="importer__progress">
            <div class="progress-row">
              <progress id="importProgress" value="0" max="100"></progress>
              <span id="progressLabel">0 / 0</span>
            </div>
            <div class="progress-stats">
              <span><strong id="successCount">0</strong> successes</span>
              <span><strong id="rejectCount">0</strong> rejects</span>
            </div>
          </div>

          <div class="importer__actions">
            <button id="downloadProperties" class="secondary">Download trail_properties.json</button>
            <button id="clearProperties" class="secondary">Clear results</button>
          </div>

          <div class="importer__log" id="importLog" aria-live="polite"></div>
          <div class="rejects">
            <h3>Rejected names</h3>
            <ul id="rejectList"></ul>
          </div>
        </div>
      </section>

      <section class="map-panel">
        <div id="map"></div>
      </section>
    </main>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
    <script src="https://unpkg.com/leaflet-geometryutil@0.10.0/src/leaflet.geometryutil.js"></script>
    <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
    <script>
      const map = L.map('map', {
        zoomSnap: 0.25,
        worldCopyJump: true,
      }).setView([44.1602, -71.5003], 9);

      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '&copy; OpenStreetMap contributors',
      }).addTo(map);

      const drawnItems = new L.FeatureGroup();
      map.addLayer(drawnItems);

      const drawControl = new L.Control.Draw({
        draw: {
          polygon: true,
          polyline: true,
          rectangle: false,
          circle: false,
          marker: true,
          circlemarker: false,
        },
        edit: {
          featureGroup: drawnItems,
        },
      });
      map.addControl(drawControl);

      const featureCount = document.getElementById('featureCount');
      const lastAction = document.getElementById('lastAction');

      const trailNamesInput = document.getElementById('trailNames');
      const populateNamesBtn = document.getElementById('populateNames');
      const startImportBtn = document.getElementById('startImport');
      const progressBar = document.getElementById('importProgress');
      const progressLabel = document.getElementById('progressLabel');
      const successCountEl = document.getElementById('successCount');
      const rejectCountEl = document.getElementById('rejectCount');
      const importLog = document.getElementById('importLog');
      const rejectList = document.getElementById('rejectList');
      const downloadPropertiesBtn = document.getElementById('downloadProperties');
      const clearPropertiesBtn = document.getElementById('clearProperties');
      const loadTrailPropertiesBtn = document.getElementById('loadTrailProperties');
      const detailTrailName = document.getElementById('detailTrailName');
      const detailStatus = document.getElementById('detailStatus');
      const detailGrid = document.getElementById('detailGrid');

      let trailProperties = [];
      let rejectedTrails = [];
      let importAbortController = null;
      let selectedTrailName = null;

      const updateCounts = () => {
        featureCount.textContent = drawnItems.getLayers().length;
      };

      const updateLastAction = (message) => {
        lastAction.textContent = message;
      };

      const normalizeName = (name = '') => name.trim().replace(/\s+/g, ' ');

      const toTitleCase = (name) =>
        name
          .toLowerCase()
          .split(/\s+/)
          .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
          .join(' ');

      const slugifyName = (name) =>
        normalizeName(name)
          .toLowerCase()
          .replace(/[^a-z0-9]+/g, '-')
          .replace(/^-+|-+$/g, '');

      const escapeRegex = (value) => value.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

      const generateNameCandidates = (name) => {
        const cleaned = normalizeName(name);
        const withoutTrail = cleaned.replace(/\s*trail$/i, '');
        const hyphenated = cleaned.replace(/\s+/g, '-');
        const deHyphenated = cleaned.replace(/-/g, ' ');
        const compact = cleaned.replace(/[-\s]+/g, '');
        const slug = slugifyName(cleaned);
        const candidates = new Set([
          cleaned,
          toTitleCase(cleaned),
          cleaned.toLowerCase(),
          `${withoutTrail} Trail`,
          `${toTitleCase(withoutTrail)} Trail`,
          hyphenated,
          deHyphenated,
          compact,
          slug,
          `${slug} trail`,
        ]);
        return Array.from(candidates)
          .map((candidate) => normalizeName(candidate))
          .filter(Boolean);
      };

      const logImportMessage = (message, type = 'info') => {
        if (!importLog) return;
        const entry = document.createElement('div');
        entry.className = `log-entry log-entry--${type}`;
        entry.textContent = message;
        importLog.prepend(entry);
      };

      const safeString = (value) => {
        if (value === null || value === undefined) return '';
        if (typeof value === 'object') return JSON.stringify(value);
        return String(value);
      };

      const clearTrailDetails = (message = 'Select a trail to see details') => {
        detailTrailName.textContent = 'Trail details';
        detailStatus.textContent = message;
        detailGrid.innerHTML = '';
      };

      const renderTrailDetails = (record) => {
        if (!record) {
          clearTrailDetails('No matching trail properties found.');
          return;
        }

        selectedTrailName = record.name;
        detailTrailName.textContent = record.name || 'Unnamed trail';
        detailStatus.textContent = '';
        detailGrid.innerHTML = '';

        const entries = Object.entries(record.properties || {});
        if (!entries.length) {
          detailStatus.textContent = 'No properties available for this trail.';
          return;
        }

        entries
          .sort(([a], [b]) => a.localeCompare(b))
          .forEach(([key, value]) => {
            const row = document.createElement('div');
            row.className = 'detail-row';
            const label = document.createElement('span');
            label.className = 'detail-label';
            label.textContent = key;
            const val = document.createElement('span');
            val.className = 'detail-value';
            val.textContent = safeString(value);
            row.append(label, val);
            detailGrid.appendChild(row);
          });
      };

      const findTrailRecordByName = (name) => {
        if (!name) return null;
        const target = normalizeName(name);
        return trailProperties.find((entry) => normalizeName(entry.name) === target) || null;
      };

      const updateProgress = (completed, total) => {
        if (!progressBar) return;
        const percent = total ? Math.round((completed / total) * 100) : 0;
        progressBar.value = percent;
        progressLabel.textContent = `${completed} / ${total}`;
      };

      const renderRejects = () => {
        rejectList.innerHTML = '';
        rejectedTrails.forEach((name) => {
          const li = document.createElement('li');
          li.textContent = name;
          rejectList.appendChild(li);
        });
        rejectCountEl.textContent = rejectedTrails.length;
      };

      const renderSuccessCount = () => {
        successCountEl.textContent = trailProperties.length;
      };

      const parsePropertiesForm = (form) => {
        const inputs = form.querySelectorAll('input, textarea');
        return Array.from(inputs).reduce((acc, input) => {
          acc[input.name] = input.value;
          return acc;
        }, {});
      };

      const featureToPopupContent = (feature = {}, layer) => {
        const props = feature.properties || {};
        const fields = Object.keys(props).length ? Object.keys(props) : ['name'];
        const rows = fields
          .map((key) => {
            const value = props[key] ?? '';
            return `<label>${key}<input name="${key}" value="${value}" /></label>`;
          })
          .join('');

        let meta = '';
        if (layer instanceof L.Polygon || layer instanceof L.Polyline) {
          const latLngs = layer.getLatLngs?.();
          const firstRing = Array.isArray(latLngs) ? latLngs[0] : [];
          if (firstRing && firstRing.length) {
            const area = L.GeometryUtil.geodesicArea(firstRing);
            meta = `<p class="popup-meta">Area: ${area.toFixed(2)} m²</p>`;
          }
        }

        return `
          <form class="popup-form">
            ${rows}
            <label>Notes<textarea name="notes">${props.notes ?? ''}</textarea></label>
            <button type="submit">Save Properties</button>
          </form>
          ${meta}
        `;
      };

      const attachPopup = (feature, layer) => {
        const content = featureToPopupContent(feature, layer);
        layer.bindPopup(content);
        layer.on('popupopen', (event) => {
          const form = event.popup.getElement().querySelector('form');
          form?.addEventListener('submit', (e) => {
            e.preventDefault();
            const updated = parsePropertiesForm(form);
            layer.feature = layer.feature || { type: 'Feature', properties: {}, geometry: {} };
            layer.feature.properties = updated;
            updateLastAction('Updated properties for a feature');
          });
        });
      };

      const geoJsonLayer = L.geoJSON(null, {
        style: () => ({ color: '#4a9eff', weight: 3 }),
        onEachFeature: (feature, layer) => {
          attachPopup(feature, layer);
          drawnItems.addLayer(layer);
        },
      });

      const loadGeoJson = async (source) => {
        try {
          updateLastAction('Loading GeoJSON…');
          const response = await fetch(source);
          if (!response.ok) throw new Error(`Failed to load GeoJSON: ${response.status}`);
          const data = await response.json();
          geoJsonLayer.clearLayers();
          drawnItems.clearLayers();
          geoJsonLayer.addData(data);
          map.fitBounds(drawnItems.getBounds(), { padding: [16, 16] });
          updateCounts();
          updateLastAction(`Loaded ${drawnItems.getLayers().length} features from ${source}`);
        } catch (error) {
          console.error(error);
          updateLastAction(error.message);
          alert(error.message);
        }
      };

      const buildOverpassQuery = (name) => {
        const escaped = escapeRegex(name).replace(/"/g, '\\"');
        const altPattern = escaped.replace(/\s+/g, '\\s+');
        return `
          [out:json][timeout:30];
          (
            way["name"~"^${altPattern}$", i]["highway"~"path|footway"];
            way["alt_name"~"${altPattern}", i]["highway"~"path|footway"];
            relation["name"~"^${altPattern}$", i]["route"~"hiking|foot"];
            relation["alt_name"~"${altPattern}", i]["route"~"hiking|foot"];
          );
          out body;
          >;
          out skel qt;
        `;
      };

      const aggregateTags = (elements = []) => {
        const tags = {};
        elements.forEach((el) => {
          const elTags = el.tags || {};
          Object.entries(elTags).forEach(([key, value]) => {
            if (value === undefined || value === null || value === '') return;
            if (!tags[key] || String(value).length > String(tags[key]).length) {
              tags[key] = value;
            }
          });
        });
        return tags;
      };

      const deriveDifficulty = (tags = {}) => {
        const sacScale = (tags.sac_scale || '').toLowerCase();
        const trailClass = String(tags.trail_class || tags.TRAIL_CLASS || '').trim();
        const classNumber = parseInt(trailClass, 10);

        if (sacScale) {
          if (sacScale.includes('demanding_alpine')) return 'T5';
          if (sacScale.includes('alpine_hiking')) return 'T4';
          if (sacScale.includes('demanding_mountain_hiking')) return 'T3';
          if (sacScale.includes('mountain_hiking')) return 'T2';
          if (sacScale.includes('hiking')) return 'T1';
        }

        if (!Number.isNaN(classNumber)) {
          if (classNumber >= 5) return 'T5';
          if (classNumber === 4) return 'T4';
          if (classNumber === 3) return 'T3';
          if (classNumber === 2) return 'T2';
          if (classNumber === 1) return 'T1';
        }

        return tags.difficulty || null;
      };

      const deriveAllowedUses = (tags = {}) => {
        const uses = new Set();
        const normalized = (value) => (value || '').toString().toLowerCase();
        const allowedTags = normalized(tags.allowed_uses || tags.USES || tags.ALLOWEDUSES || '');

        if (allowedTags) {
          allowedTags
            .split(/[,;\s]+/)
            .map((part) => part.trim())
            .filter(Boolean)
            .forEach((entry) => uses.add(entry));
        }

        if (normalized(tags.foot) !== 'no') uses.add('hiking');
        if (normalized(tags.bicycle) === 'yes' || normalized(tags.bike) === 'yes') uses.add('bicycle');
        if (normalized(tags.horse) === 'yes') uses.add('horse');

        return Array.from(uses).filter(Boolean).join(', ');
      };

      const mergeProperties = (base = {}, fallback = {}) => {
        const merged = { ...base };
        Object.entries(fallback).forEach(([key, value]) => {
          if (merged[key] === undefined || merged[key] === null || merged[key] === '') {
            merged[key] = value;
          }
        });
        return merged;
      };

      const applyFallbackTemplate = (name, properties = {}) => {
        const difficulty = deriveDifficulty(properties) || 'T2';
        const allowedUses = deriveAllowedUses(properties) || 'hiking';
        return {
          trail_name: normalizeName(name),
          distance_miles: null,
          osm_properties: {
            surface: properties.surface || 'trail',
            difficulty,
            trail_visibility: properties.trail_visibility || 'Good',
            width: properties.width || '2-4ft',
            allowed_uses: allowedUses,
            season: properties.season || 'all (unless stated)',
            elevation_gain_ft: properties.elevation_gain_ft ?? null,
            min_elevation_ft: properties.min_elevation_ft ?? null,
            max_elevation_ft: properties.max_elevation_ft ?? null,
            trail_type: properties.trail_type || 'hiking',
            maintainer: properties.maintainer || 'USFS',
            source: properties.source || 'fallback',
          },
        };
      };

      const ensureAssociatedPeaks = (record) => {
        const props = record.properties || {};
        if (!Array.isArray(props.associated_peaks)) {
          const maybeArray = props.associated_peaks ? [props.associated_peaks].flat() : [];
          props.associated_peaks = maybeArray.filter(Boolean);
        }
        record.properties = props;
      };

      const fetchOSMTrail = async (name) => {
        const candidates = generateNameCandidates(name);
        let lastError = null;
        for (const candidate of candidates) {
          try {
            const query = buildOverpassQuery(candidate);
            const response = await fetch('https://overpass-api.de/api/interpreter', {
              method: 'POST',
              body: new URLSearchParams({ data: query }),
              signal: importAbortController?.signal,
            });

            if (!response.ok) {
              throw new Error(`Overpass request failed (${response.status}) for ${candidate}`);
            }

            const payload = await response.json();
            const elements = (payload?.elements || []).filter((el) => el.tags);
            if (elements.length) {
              return { candidate, elements };
            }
          } catch (error) {
            lastError = error;
            console.warn('OSM fetch attempt failed', candidate, error);
          }
        }

        throw lastError || new Error(`No OpenStreetMap data found for ${name}`);
      };

      const fetchUSFSTrail = async (name) => {
        const candidates = generateNameCandidates(name);
        const baseUrl = 'https://apps.fs.usda.gov/arcx/rest/services/EDW/EDW_TrailNFSPublish_01/MapServer/0/query';
        const envelope = '-72.2,42.5,-70.5,45.5';
        let lastError = null;

        for (const candidate of candidates) {
          try {
            const uppercase = candidate.toUpperCase();
            const params = new URLSearchParams({
              f: 'json',
              where: `UPPER(TRAIL_NAME) LIKE '%${uppercase}%' OR UPPER(TRAILNO) LIKE '%${uppercase}%'`,
              outFields: 'TRAIL_NAME,TRAILNO,TRAIL_CLASS,ALLOWEDUSES,USES,MILES,LENGTH,MAINTAINER,REGION',
              geometry: envelope,
              geometryType: 'esriGeometryEnvelope',
              inSR: 4326,
              spatialRel: 'esriSpatialRelIntersects',
              outSR: 4326,
            });

            const response = await fetch(`${baseUrl}?${params.toString()}`, {
              signal: importAbortController?.signal,
            });

            if (!response.ok) throw new Error(`USFS request failed (${response.status}) for ${candidate}`);
            const payload = await response.json();
            const features = payload?.features || [];
            if (features.length) {
              return { candidate, features };
            }
          } catch (error) {
            lastError = error;
            console.warn('USFS fetch attempt failed', candidate, error);
          }
        }

        throw lastError || new Error(`No USFS data found for ${name}`);
      };

      const buildUSFSTrailRecord = (name, features) => {
        const attributes = features[0]?.attributes || {};
        const distance = attributes.MILES ?? attributes.LENGTH ?? null;
        const difficulty = deriveDifficulty(attributes);
        const allowedUses = deriveAllowedUses(attributes);
        return {
          name: normalizeName(attributes.TRAIL_NAME || name),
          properties: {
            trail_no: attributes.TRAILNO || null,
            difficulty,
            allowed_uses: allowedUses,
            distance_miles: distance,
            maintainer: attributes.MAINTAINER || attributes.REGION || 'USFS',
            trail_class: attributes.TRAIL_CLASS || null,
            associated_peaks: [],
            source: 'usfs',
            usfs_feature_count: features.length,
          },
        };
      };

      const buildTrailPropertyRecord = (name, elements) => {
        const tags = aggregateTags(elements);
        const osmIds = elements.map((el) => `${el.type}/${el.id}`);
        const difficulty = deriveDifficulty(tags);
        const allowedUses = deriveAllowedUses(tags);
        return {
          name: normalizeName(name),
          properties: {
            ...tags,
            difficulty,
            allowed_uses: allowedUses,
            associated_peaks: Array.isArray(tags.associated_peaks) ? tags.associated_peaks : [],
            source: 'openstreetmap',
            osm_elements: osmIds,
            osm_element_count: elements.length,
          },
        };
      };

      const persistTrailRecord = (record) => {
        ensureAssociatedPeaks(record);
        const existingIndex = trailProperties.findIndex((entry) => entry.name === record.name);
        if (existingIndex >= 0) {
          trailProperties[existingIndex] = record;
        } else {
          trailProperties.push(record);
        }
        renderSuccessCount();

        if (selectedTrailName && normalizeName(selectedTrailName) === normalizeName(record.name)) {
          renderTrailDetails(record);
        }
      };

      const downloadTrailPropertiesFile = () => {
        if (!trailProperties.length) {
          alert('No trail properties to download yet. Run an import first.');
          return;
        }

        const blob = new Blob([JSON.stringify(trailProperties, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'trail_properties.json';
        link.click();
        URL.revokeObjectURL(url);
        updateLastAction('Downloaded trail_properties.json');
      };

      const clearTrailProperties = () => {
        trailProperties = [];
        rejectedTrails = [];
        importLog.innerHTML = '';
        renderRejects();
        renderSuccessCount();
        updateProgress(0, 0);
        updateLastAction('Cleared imported trail properties');
        clearTrailDetails('Trail properties cleared. Reload or import to view details.');
      };

      const loadTrailPropertiesFromFile = async () => {
        try {
          updateLastAction('Loading trail_properties.json…');
          const response = await fetch('../data/trail_properties.json');
          if (!response.ok) {
            throw new Error(`Could not load trail_properties.json (status ${response.status})`);
          }

          const data = await response.json();
          if (!Array.isArray(data)) {
            throw new Error('trail_properties.json must be an array of trail records.');
          }

          trailProperties = data;
          renderSuccessCount();
          updateLastAction(`Loaded ${trailProperties.length} trail properties from file`);
          if (selectedTrailName) {
            renderTrailDetails(findTrailRecordByName(selectedTrailName));
          }
        } catch (error) {
          console.error('Trail properties load failed:', error);
          updateLastAction(error.message || 'Failed to load trail_properties.json');
          detailStatus.textContent = 'trail_properties.json not available. Continue without it.';
        }
      };

      const gatherNamesFromMap = () => {
        const names = drawnItems
          .getLayers()
          .map((layer) => layer.feature?.properties?.name)
          .filter(Boolean);
        const uniqueNames = Array.from(new Set(names));
        trailNamesInput.value = uniqueNames.join('\n');
        updateLastAction(`Populated ${uniqueNames.length} names from the map`);
      };

      const parseNameList = () => {
        const lines = trailNamesInput.value.split(/\n+/).map((line) => normalizeName(line)).filter(Boolean);
        return Array.from(new Set(lines));
      };

      const importTrailProperties = async () => {
        if (importAbortController) {
          importAbortController.abort();
        }

        const names = parseNameList();
        if (!names.length) {
          alert('Add at least one trail name to import.');
          return;
        }

        importAbortController = new AbortController();
        trailProperties = [];
        rejectedTrails = [];
        importLog.innerHTML = '';
        renderRejects();
        renderSuccessCount();
        updateProgress(0, names.length);

        startImportBtn.disabled = true;
        startImportBtn.textContent = 'Importing…';
        logImportMessage(`Starting multi-source import (OSM → USFS → fallback) for ${names.length} trail names…`);

        for (let index = 0; index < names.length; index++) {
          const name = names[index];
          try {
            let record = null;
            let source = '';

            try {
              const { candidate, elements } = await fetchOSMTrail(name);
              record = buildTrailPropertyRecord(name, elements);
              source = `OSM via “${candidate}” (${elements.length} elements)`;
            } catch (osmError) {
              console.warn('OSM lookup failed, falling back to USFS', osmError);
              try {
                const { candidate, features } = await fetchUSFSTrail(name);
                record = buildUSFSTrailRecord(name, features);
                source = `USFS via “${candidate}” (${features.length} features)`;
              } catch (usfsError) {
                console.warn('USFS lookup failed, applying fallback template', usfsError);
                const template = applyFallbackTemplate(name);
                const fallbackRecord = {
                  name: normalizeName(name),
                  properties: { trail_name: template.trail_name, ...template.osm_properties },
                };
                record = fallbackRecord;
                source = 'fallback template';
              }
            }

            const fallback = applyFallbackTemplate(record.name, record.properties);
            record.properties = mergeProperties({ trail_name: fallback.trail_name, ...record.properties }, fallback.osm_properties);
            ensureAssociatedPeaks(record);
            persistTrailRecord(record);
            logImportMessage(`Imported “${name}” using ${source}.`, 'success');
          } catch (error) {
            rejectedTrails.push(name);
            renderRejects();
            logImportMessage(`Could not import “${name}”: ${error.message}`, 'warn');
          }

          updateProgress(index + 1, names.length);
          await new Promise((resolve) => setTimeout(resolve, 350));
        }

        renderRejects();
        renderSuccessCount();
        startImportBtn.disabled = false;
        startImportBtn.textContent = 'Import trails (OSM + USFS)';
        updateLastAction('Finished importing trail properties');
        importAbortController = null;
      };

      const exportGeoJson = () => {
        const collection = {
          type: 'FeatureCollection',
          features: drawnItems.getLayers().map((layer) => {
            const geo = layer.toGeoJSON();
            geo.properties = layer.feature?.properties || geo.properties || {};
            return geo;
          }),
        };

        const blob = new Blob([JSON.stringify(collection, null, 2)], { type: 'application/geo+json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'merged_trails.edited.geojson';
        link.click();
        URL.revokeObjectURL(url);
        updateLastAction('Downloaded edited GeoJSON');
      };

      const handleFileUpload = (file) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const data = JSON.parse(e.target.result);
            geoJsonLayer.clearLayers();
            drawnItems.clearLayers();
            geoJsonLayer.addData(data);
            map.fitBounds(drawnItems.getBounds(), { padding: [16, 16] });
            updateCounts();
            updateLastAction(`Loaded ${drawnItems.getLayers().length} features from uploaded file`);
          } catch (error) {
            console.error(error);
            updateLastAction('Failed to parse uploaded GeoJSON');
            alert('Could not parse the uploaded GeoJSON file.');
          }
        };
        reader.readAsText(file);
      };

      const handleTrailSelection = (layer) => {
        const name = layer.feature?.properties?.name;
        if (!name) {
          clearTrailDetails('Selected feature has no name.');
          return;
        }

        selectedTrailName = name;
        const record = findTrailRecordByName(name);
        if (record) {
          renderTrailDetails(record);
        } else {
          clearTrailDetails(`No trail_properties entry found for “${name}”.`);
        }
      };

      map.on(L.Draw.Event.CREATED, (event) => {
        const { layer } = event;
        layer.feature = layer.feature || { type: 'Feature', properties: {} };
        attachPopup(layer.feature, layer);
        drawnItems.addLayer(layer);
        updateCounts();
        updateLastAction('Added a new feature');
      });

      map.on(L.Draw.Event.EDITED, () => {
        updateCounts();
        updateLastAction('Edited features');
      });

      map.on(L.Draw.Event.DELETED, () => {
        updateCounts();
        updateLastAction('Deleted features');
      });

      document.getElementById('download').addEventListener('click', exportGeoJson);

      startImportBtn.addEventListener('click', importTrailProperties);
      populateNamesBtn.addEventListener('click', gatherNamesFromMap);
      downloadPropertiesBtn.addEventListener('click', downloadTrailPropertiesFile);
      clearPropertiesBtn.addEventListener('click', clearTrailProperties);

      document.getElementById('fileInput').addEventListener('change', (event) => {
        const file = event.target.files?.[0];
        if (file) handleFileUpload(file);
      });

      document.getElementById('reset').addEventListener('click', () => {
        drawnItems.clearLayers();
        updateCounts();
        updateLastAction('Cleared all features');
      });

      document.getElementById('loadLocal').addEventListener('click', () => loadGeoJson('../data/merged_trails.geojson'));
      loadTrailPropertiesBtn.addEventListener('click', loadTrailPropertiesFromFile);

      drawnItems.on('click', (event) => {
        handleTrailSelection(event.layer);
      });

      // Initial load for convenience
      loadGeoJson('../data/merged_trails.geojson');
      loadTrailPropertiesFromFile();
      clearTrailDetails();
    </script>
  </body>
</html>
