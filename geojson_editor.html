<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WMNF Trails GeoJSON Editor</title>
    <link rel="icon" type="image/png" href="../WMNF_Trails_API_logo.png">
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      crossorigin=""
    />
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css"
    />
    <link rel="stylesheet" href="../css/geojson_editor.css" />
  </head>
  <body>
    <header class="page-header">
      <div class="title-block">
        <h1>WMNF Trails GeoJSON Editor</h1>
        <p>View, adjust, and export <code>merged_trails.geojson</code> directly in the browser.</p>
      </div>
      <div class="action-row">
        <button id="loadLocal" class="secondary">Load Local File</button>
        <label for="fileInput" class="file-label">Import GeoJSON<input id="fileInput" type="file" accept="application/geo+json,application/json,.geojson" /></label>
        <button id="reset" class="secondary">Reset</button>
        <button id="download" class="primary">Download Edited GeoJSON</button>
      </div>
    </header>

    <main class="layout">
      <section class="sidebar">
        <div class="status">
          <h2>Status</h2>
          <dl>
            <div>
              <dt>Features loaded</dt>
              <dd id="featureCount">0</dd>
            </div>
            <div>
              <dt>Last action</dt>
              <dd id="lastAction">Waiting for data…</dd>
            </div>
          </dl>
        </div>
        <div class="help">
          <h2>How to use</h2>
          <ol>
            <li>Click <strong>Load Local File</strong> to fetch <code>merged_trails.geojson</code> from this repository.</li>
            <li>Use the draw toolbar to add, edit, or delete trail geometries.</li>
            <li>Click a trail to inspect its properties. Update metadata in the popup form.</li>
            <li>When finished, click <strong>Download Edited GeoJSON</strong> to save your changes.</li>
          </ol>
        </div>

        <div class="details">
          <div class="details__header">
            <h2>Trail details</h2>
            <p>View OpenStreetMap fields for the selected trail. Works even if <code>trail_properties.json</code> is missing.</p>
          </div>
          <div class="details__actions">
            <button id="loadTrailProperties" class="secondary">Load trail_properties.json</button>
          </div>
          <div class="details__body">
            <div class="details__title" id="detailTrailName">Select a trail to see details</div>
            <div class="details__status" id="detailStatus">No trail selected.</div>
            <div class="details__grid" id="detailGrid"></div>
          </div>
        </div>

        <div class="importer">
          <div class="importer__header">
            <h2>Trail Properties (OSM)</h2>
            <p>Bulk-fetch OpenStreetMap metadata by trail name and export a <code>trail_properties.json</code> file.</p>
          </div>

          <div class="importer__controls">
            <label class="input-label" for="trailNames">Trail names to import</label>
            <textarea
              id="trailNames"
              placeholder="One trail name per line. Use 'Populate from map' to gather names from the loaded GeoJSON."
              rows="6"
            ></textarea>
            <div class="importer__buttons">
              <button id="populateNames" class="secondary">Populate from map</button>
              <button id="startImport" class="primary">Import from OpenStreetMap</button>
            </div>
          </div>

          <div class="importer__progress">
            <div class="progress-row">
              <progress id="importProgress" value="0" max="100"></progress>
              <span id="progressLabel">0 / 0</span>
            </div>
            <div class="progress-stats">
              <span><strong id="successCount">0</strong> successes</span>
              <span><strong id="rejectCount">0</strong> rejects</span>
            </div>
          </div>

          <div class="importer__actions">
            <button id="downloadProperties" class="secondary">Download trail_properties.json</button>
            <button id="clearProperties" class="secondary">Clear results</button>
          </div>

          <div class="importer__log" id="importLog" aria-live="polite"></div>
          <div class="rejects">
            <h3>Rejected names</h3>
            <ul id="rejectList"></ul>
          </div>
        </div>
      </section>

      <section class="map-panel">
        <div id="map"></div>
      </section>
    </main>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
    <script src="https://unpkg.com/leaflet-geometryutil@0.10.0/src/leaflet.geometryutil.js"></script>
    <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
    <script>
      const map = L.map('map', {
        zoomSnap: 0.25,
        worldCopyJump: true,
      }).setView([44.1602, -71.5003], 9);

      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '&copy; OpenStreetMap contributors',
      }).addTo(map);

      const drawnItems = new L.FeatureGroup();
      map.addLayer(drawnItems);

      const drawControl = new L.Control.Draw({
        draw: {
          polygon: true,
          polyline: true,
          rectangle: false,
          circle: false,
          marker: true,
          circlemarker: false,
        },
        edit: {
          featureGroup: drawnItems,
        },
      });
      map.addControl(drawControl);

      const featureCount = document.getElementById('featureCount');
      const lastAction = document.getElementById('lastAction');

      const trailNamesInput = document.getElementById('trailNames');
      const populateNamesBtn = document.getElementById('populateNames');
      const startImportBtn = document.getElementById('startImport');
      const progressBar = document.getElementById('importProgress');
      const progressLabel = document.getElementById('progressLabel');
      const successCountEl = document.getElementById('successCount');
      const rejectCountEl = document.getElementById('rejectCount');
      const importLog = document.getElementById('importLog');
      const rejectList = document.getElementById('rejectList');
      const downloadPropertiesBtn = document.getElementById('downloadProperties');
      const clearPropertiesBtn = document.getElementById('clearProperties');
      const loadTrailPropertiesBtn = document.getElementById('loadTrailProperties');
      const detailTrailName = document.getElementById('detailTrailName');
      const detailStatus = document.getElementById('detailStatus');
      const detailGrid = document.getElementById('detailGrid');

      let trailProperties = [];
      let rejectedTrails = [];
      let importAbortController = null;
      let selectedTrailName = null;

      const updateCounts = () => {
        featureCount.textContent = drawnItems.getLayers().length;
      };

      const updateLastAction = (message) => {
        lastAction.textContent = message;
      };

      const normalizeName = (name) => name.trim().replace(/\s+/g, ' ');

      const toTitleCase = (name) =>
        name
          .toLowerCase()
          .split(/\s+/)
          .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
          .join(' ');

      const generateNameCandidates = (name) => {
        const cleaned = normalizeName(name);
        const withoutTrail = cleaned.replace(/\s*trail$/i, '');
        const candidates = new Set([
          cleaned,
          toTitleCase(cleaned),
          cleaned.toLowerCase(),
          `${withoutTrail} Trail`,
          `${toTitleCase(withoutTrail)} Trail`,
        ]);
        return Array.from(candidates).filter(Boolean);
      };

      const logImportMessage = (message, type = 'info') => {
        if (!importLog) return;
        const entry = document.createElement('div');
        entry.className = `log-entry log-entry--${type}`;
        entry.textContent = message;
        importLog.prepend(entry);
      };

      const safeString = (value) => {
        if (value === null || value === undefined) return '';
        if (typeof value === 'object') return JSON.stringify(value);
        return String(value);
      };

      const clearTrailDetails = (message = 'Select a trail to see details') => {
        detailTrailName.textContent = 'Trail details';
        detailStatus.textContent = message;
        detailGrid.innerHTML = '';
      };

      const renderTrailDetails = (record) => {
        if (!record) {
          clearTrailDetails('No matching trail properties found.');
          return;
        }

        selectedTrailName = record.name;
        detailTrailName.textContent = record.name || 'Unnamed trail';
        detailStatus.textContent = '';
        detailGrid.innerHTML = '';

        const entries = Object.entries(record.properties || {});
        if (!entries.length) {
          detailStatus.textContent = 'No properties available for this trail.';
          return;
        }

        entries
          .sort(([a], [b]) => a.localeCompare(b))
          .forEach(([key, value]) => {
            const row = document.createElement('div');
            row.className = 'detail-row';
            const label = document.createElement('span');
            label.className = 'detail-label';
            label.textContent = key;
            const val = document.createElement('span');
            val.className = 'detail-value';
            val.textContent = safeString(value);
            row.append(label, val);
            detailGrid.appendChild(row);
          });
      };

      const findTrailRecordByName = (name) => {
        if (!name) return null;
        const target = normalizeName(name);
        return trailProperties.find((entry) => normalizeName(entry.name) === target) || null;
      };

      const updateProgress = (completed, total) => {
        if (!progressBar) return;
        const percent = total ? Math.round((completed / total) * 100) : 0;
        progressBar.value = percent;
        progressLabel.textContent = `${completed} / ${total}`;
      };

      const renderRejects = () => {
        rejectList.innerHTML = '';
        rejectedTrails.forEach((name) => {
          const li = document.createElement('li');
          li.textContent = name;
          rejectList.appendChild(li);
        });
        rejectCountEl.textContent = rejectedTrails.length;
      };

      const renderSuccessCount = () => {
        successCountEl.textContent = trailProperties.length;
      };

      const parsePropertiesForm = (form) => {
        const inputs = form.querySelectorAll('input, textarea');
        return Array.from(inputs).reduce((acc, input) => {
          acc[input.name] = input.value;
          return acc;
        }, {});
      };

      const featureToPopupContent = (feature = {}, layer) => {
        const props = feature.properties || {};
        const fields = Object.keys(props).length ? Object.keys(props) : ['name'];
        const rows = fields
          .map((key) => {
            const value = props[key] ?? '';
            return `<label>${key}<input name="${key}" value="${value}" /></label>`;
          })
          .join('');

        let meta = '';
        if (layer instanceof L.Polygon || layer instanceof L.Polyline) {
          const latLngs = layer.getLatLngs?.();
          const firstRing = Array.isArray(latLngs) ? latLngs[0] : [];
          if (firstRing && firstRing.length) {
            const area = L.GeometryUtil.geodesicArea(firstRing);
            meta = `<p class="popup-meta">Area: ${area.toFixed(2)} m²</p>`;
          }
        }

        return `
          <form class="popup-form">
            ${rows}
            <label>Notes<textarea name="notes">${props.notes ?? ''}</textarea></label>
            <button type="submit">Save Properties</button>
          </form>
          ${meta}
        `;
      };

      const attachPopup = (feature, layer) => {
        const content = featureToPopupContent(feature, layer);
        layer.bindPopup(content);
        layer.on('popupopen', (event) => {
          const form = event.popup.getElement().querySelector('form');
          form?.addEventListener('submit', (e) => {
            e.preventDefault();
            const updated = parsePropertiesForm(form);
            layer.feature = layer.feature || { type: 'Feature', properties: {}, geometry: {} };
            layer.feature.properties = updated;
            updateLastAction('Updated properties for a feature');
          });
        });
      };

      const geoJsonLayer = L.geoJSON(null, {
        style: () => ({ color: '#4a9eff', weight: 3 }),
        onEachFeature: (feature, layer) => {
          attachPopup(feature, layer);
          drawnItems.addLayer(layer);
        },
      });

      const loadGeoJson = async (source) => {
        try {
          updateLastAction('Loading GeoJSON…');
          const response = await fetch(source);
          if (!response.ok) throw new Error(`Failed to load GeoJSON: ${response.status}`);
          const data = await response.json();
          geoJsonLayer.clearLayers();
          drawnItems.clearLayers();
          geoJsonLayer.addData(data);
          map.fitBounds(drawnItems.getBounds(), { padding: [16, 16] });
          updateCounts();
          updateLastAction(`Loaded ${drawnItems.getLayers().length} features from ${source}`);
        } catch (error) {
          console.error(error);
          updateLastAction(error.message);
          alert(error.message);
        }
      };

      const buildOverpassQuery = (name) => {
        const escaped = name.replace(/"/g, '\\"');
        return `
          [out:json][timeout:30];
          (
            way["name"="${escaped}"]["highway"~"path|footway"]; 
            relation["name"="${escaped}"]["route"~"hiking|foot"]; 
          );
          out body;
          >;
          out skel qt;
        `;
      };

      const aggregateTags = (elements = []) => {
        const tags = {};
        elements.forEach((el) => {
          const elTags = el.tags || {};
          Object.entries(elTags).forEach(([key, value]) => {
            if (value === undefined || value === null || value === '') return;
            if (!tags[key] || String(value).length > String(tags[key]).length) {
              tags[key] = value;
            }
          });
        });
        return tags;
      };

      const fetchOSMTrail = async (name) => {
        const candidates = generateNameCandidates(name);
        let lastError = null;
        for (const candidate of candidates) {
          try {
            const query = buildOverpassQuery(candidate);
            const response = await fetch('https://overpass-api.de/api/interpreter', {
              method: 'POST',
              body: new URLSearchParams({ data: query }),
              signal: importAbortController?.signal,
            });

            if (!response.ok) {
              throw new Error(`Overpass request failed (${response.status}) for ${candidate}`);
            }

            const payload = await response.json();
            const elements = (payload?.elements || []).filter((el) => el.tags);
            if (elements.length) {
              return { candidate, elements };
            }
          } catch (error) {
            lastError = error;
            console.warn('OSM fetch attempt failed', candidate, error);
          }
        }

        throw lastError || new Error(`No OpenStreetMap data found for ${name}`);
      };

      const buildTrailPropertyRecord = (name, elements) => {
        const tags = aggregateTags(elements);
        const osmIds = elements.map((el) => `${el.type}/${el.id}`);
        return {
          name: normalizeName(name),
          properties: {
            ...tags,
            source: 'openstreetmap',
            osm_elements: osmIds,
            osm_element_count: elements.length,
          },
        };
      };

      const persistTrailRecord = (record) => {
        const existingIndex = trailProperties.findIndex((entry) => entry.name === record.name);
        if (existingIndex >= 0) {
          trailProperties[existingIndex] = record;
        } else {
          trailProperties.push(record);
        }
        renderSuccessCount();

        if (selectedTrailName && normalizeName(selectedTrailName) === normalizeName(record.name)) {
          renderTrailDetails(record);
        }
      };

      const downloadTrailPropertiesFile = () => {
        if (!trailProperties.length) {
          alert('No trail properties to download yet. Run an import first.');
          return;
        }

        const blob = new Blob([JSON.stringify(trailProperties, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'trail_properties.json';
        link.click();
        URL.revokeObjectURL(url);
        updateLastAction('Downloaded trail_properties.json');
      };

      const clearTrailProperties = () => {
        trailProperties = [];
        rejectedTrails = [];
        importLog.innerHTML = '';
        renderRejects();
        renderSuccessCount();
        updateProgress(0, 0);
        updateLastAction('Cleared imported trail properties');
        clearTrailDetails('Trail properties cleared. Reload or import to view details.');
      };

      const loadTrailPropertiesFromFile = async () => {
        try {
          updateLastAction('Loading trail_properties.json…');
          const response = await fetch('../data/trail_properties.json');
          if (!response.ok) {
            throw new Error(`Could not load trail_properties.json (status ${response.status})`);
          }

          const data = await response.json();
          if (!Array.isArray(data)) {
            throw new Error('trail_properties.json must be an array of trail records.');
          }

          trailProperties = data;
          renderSuccessCount();
          updateLastAction(`Loaded ${trailProperties.length} trail properties from file`);
          if (selectedTrailName) {
            renderTrailDetails(findTrailRecordByName(selectedTrailName));
          }
        } catch (error) {
          console.error('Trail properties load failed:', error);
          updateLastAction(error.message || 'Failed to load trail_properties.json');
          detailStatus.textContent = 'trail_properties.json not available. Continue without it.';
        }
      };

      const gatherNamesFromMap = () => {
        const names = drawnItems
          .getLayers()
          .map((layer) => layer.feature?.properties?.name)
          .filter(Boolean);
        const uniqueNames = Array.from(new Set(names));
        trailNamesInput.value = uniqueNames.join('\n');
        updateLastAction(`Populated ${uniqueNames.length} names from the map`);
      };

      const parseNameList = () => {
        const lines = trailNamesInput.value.split(/\n+/).map((line) => normalizeName(line)).filter(Boolean);
        return Array.from(new Set(lines));
      };

      const importTrailProperties = async () => {
        if (importAbortController) {
          importAbortController.abort();
        }

        const names = parseNameList();
        if (!names.length) {
          alert('Add at least one trail name to import.');
          return;
        }

        importAbortController = new AbortController();
        trailProperties = [];
        rejectedTrails = [];
        importLog.innerHTML = '';
        renderRejects();
        renderSuccessCount();
        updateProgress(0, names.length);

        startImportBtn.disabled = true;
        startImportBtn.textContent = 'Importing…';
        logImportMessage(`Starting OpenStreetMap import for ${names.length} trail names…`);

        for (let index = 0; index < names.length; index++) {
          const name = names[index];
          try {
            const { candidate, elements } = await fetchOSMTrail(name);
            const record = buildTrailPropertyRecord(name, elements);
            persistTrailRecord(record);
            logImportMessage(`Imported “${name}” via candidate “${candidate}” with ${elements.length} OSM elements.`, 'success');
          } catch (error) {
            rejectedTrails.push(name);
            renderRejects();
            logImportMessage(`Could not import “${name}”: ${error.message}`, 'warn');
          }

          updateProgress(index + 1, names.length);
          await new Promise((resolve) => setTimeout(resolve, 350));
        }

        renderRejects();
        renderSuccessCount();
        startImportBtn.disabled = false;
        startImportBtn.textContent = 'Import from OpenStreetMap';
        updateLastAction('Finished importing OpenStreetMap trail properties');
        importAbortController = null;
      };

      const exportGeoJson = () => {
        const collection = {
          type: 'FeatureCollection',
          features: drawnItems.getLayers().map((layer) => {
            const geo = layer.toGeoJSON();
            geo.properties = layer.feature?.properties || geo.properties || {};
            return geo;
          }),
        };

        const blob = new Blob([JSON.stringify(collection, null, 2)], { type: 'application/geo+json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'merged_trails.edited.geojson';
        link.click();
        URL.revokeObjectURL(url);
        updateLastAction('Downloaded edited GeoJSON');
      };

      const handleFileUpload = (file) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const data = JSON.parse(e.target.result);
            geoJsonLayer.clearLayers();
            drawnItems.clearLayers();
            geoJsonLayer.addData(data);
            map.fitBounds(drawnItems.getBounds(), { padding: [16, 16] });
            updateCounts();
            updateLastAction(`Loaded ${drawnItems.getLayers().length} features from uploaded file`);
          } catch (error) {
            console.error(error);
            updateLastAction('Failed to parse uploaded GeoJSON');
            alert('Could not parse the uploaded GeoJSON file.');
          }
        };
        reader.readAsText(file);
      };

      const handleTrailSelection = (layer) => {
        const name = layer.feature?.properties?.name;
        if (!name) {
          clearTrailDetails('Selected feature has no name.');
          return;
        }

        selectedTrailName = name;
        const record = findTrailRecordByName(name);
        if (record) {
          renderTrailDetails(record);
        } else {
          clearTrailDetails(`No trail_properties entry found for “${name}”.`);
        }
      };

      map.on(L.Draw.Event.CREATED, (event) => {
        const { layer } = event;
        layer.feature = layer.feature || { type: 'Feature', properties: {} };
        attachPopup(layer.feature, layer);
        drawnItems.addLayer(layer);
        updateCounts();
        updateLastAction('Added a new feature');
      });

      map.on(L.Draw.Event.EDITED, () => {
        updateCounts();
        updateLastAction('Edited features');
      });

      map.on(L.Draw.Event.DELETED, () => {
        updateCounts();
        updateLastAction('Deleted features');
      });

      document.getElementById('download').addEventListener('click', exportGeoJson);

      startImportBtn.addEventListener('click', importTrailProperties);
      populateNamesBtn.addEventListener('click', gatherNamesFromMap);
      downloadPropertiesBtn.addEventListener('click', downloadTrailPropertiesFile);
      clearPropertiesBtn.addEventListener('click', clearTrailProperties);

      document.getElementById('fileInput').addEventListener('change', (event) => {
        const file = event.target.files?.[0];
        if (file) handleFileUpload(file);
      });

      document.getElementById('reset').addEventListener('click', () => {
        drawnItems.clearLayers();
        updateCounts();
        updateLastAction('Cleared all features');
      });

      document.getElementById('loadLocal').addEventListener('click', () => loadGeoJson('../data/merged_trails.geojson'));
      loadTrailPropertiesBtn.addEventListener('click', loadTrailPropertiesFromFile);

      drawnItems.on('click', (event) => {
        handleTrailSelection(event.layer);
      });

      // Initial load for convenience
      loadGeoJson('../data/merged_trails.geojson');
      loadTrailPropertiesFromFile();
      clearTrailDetails();
    </script>
  </body>
</html>
