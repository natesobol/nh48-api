<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!-- Favicons - ICO format preferred for Google compatibility -->
<link rel="icon" href="/favicons/favicon.ico" sizes="48x48">
<link rel="icon" type="image/x-icon" href="/favicons/favicon.ico">
<link rel="shortcut icon" href="/favicons/favicon.ico">
<link rel="icon" type="image/x-icon" sizes="16x16" href="/favicons/favicon-16x16.ico">
<link rel="icon" type="image/x-icon" sizes="32x32" href="/favicons/favicon-32x32.ico">
<link rel="icon" type="image/x-icon" sizes="48x48" href="/favicons/favicon-48x48.ico">
<link rel="icon" type="image/x-icon" sizes="96x96" href="/favicons/favicon-96x96.ico">
<!-- PNG fallbacks for browsers that prefer PNG -->
<link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32.png">
<link rel="icon" type="image/png" sizes="48x48" href="/favicons/favicon-48x48.png">
<link rel="icon" type="image/png" sizes="96x96" href="/favicons/favicon-96x96.png">
<link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
<link rel="manifest" href="/manifest.json">
<title>Virtual Hike of NH’s 4,000‑Footers – NH48</title>
<meta name="description" content="Take a virtual hike across New Hampshire’s 4,000‑foot peaks.  Explore interactive 3D models, photos and route information without leaving home.">
<link rel="canonical" href="https://nh48.info/virtual_hike.html">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "WebPage",
  "name": "Virtual Hike of NH’s 4,000‑Footers",
  "url": "https://nh48.info/virtual_hike.html",
  "description": "Interactive virtual hike across all 48 of New Hampshire’s 4,000‑foot mountains."
}
</script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/cesium/1.109.0/Widgets/widgets.min.css" rel="stylesheet">
<link rel="stylesheet" href="css/virtual_hike.css">
<link rel="stylesheet" href="/css/quick-browse-footer.css">
<script src="/js/quick-browse-footer.js" defer></script>
</head>
<body>
<div id="toolbar">
  <h2 id="trailName">Virtual Hike</h2>
  <button id="playBtn">Fly Trail</button>
  <button id="clearBtn">Clear Markers</button>
</div>
<div id="cesiumContainer"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/cesium/1.109.0/Cesium.min.js"></script>
<script>
// Helper to get query parameters
function getQueryParam(name) {
  const params = new URLSearchParams(window.location.search);
  return params.get(name);
}

// Main async function to initialize the virtual hike
async function init() {
  const trail = getQueryParam('trail');
  const decoded = trail ? decodeURIComponent(trail) : '';
  document.getElementById('trailName').textContent = decoded ? decoded + ' — Virtual Hike' : 'Virtual Hike';

  // Create the Cesium viewer
  const viewer = new Cesium.Viewer('cesiumContainer', {
    terrainProvider: Cesium.createWorldTerrain(),
    animation: false,
    timeline: false,
    sceneModePicker: false,
    baseLayerPicker: false,
    navigationHelpButton: false,
    geocoder: false,
    homeButton: false,
    infoBox: false,
    fullscreenButton: false,
    selectionIndicator: false
  });

  // Store user-added markers
  const userMarkers = [];

  // Add click handler to add markers
  const handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
  handler.setInputAction(function(click) {
    const cartesian = viewer.scene.pickPosition(click.position);
    if (Cesium.defined(cartesian)) {
      const marker = viewer.entities.add({
        position: cartesian,
        point: {
          pixelSize: 8,
          color: Cesium.Color.YELLOW,
          outlineColor: Cesium.Color.BLACK,
          outlineWidth: 1
        }
      });
      userMarkers.push(marker);
    }
  }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

  // Clear button to remove all markers
  document.getElementById('clearBtn').addEventListener('click', function() {
    userMarkers.forEach(entity => viewer.entities.remove(entity));
    userMarkers.length = 0;
  });

  // Load the GeoJSON trail data from the bundled copy first, then fall back to mirrors
  const geoUrls = [
    'data/merged_trails.geojson',
    'https://cdn.jsdelivr.net/gh/natesobol/nh48-api@main/data/merged_trails.geojson',
    'https://raw.githubusercontent.com/natesobol/nh48-api/main/data/merged_trails.geojson',
    'https://unpkg.com/natesobol/nh48-api@main/data/merged_trails.geojson'
  ];
  let geoData;
  for (const url of geoUrls) {
    try {
      const res = await fetch(url, {cache: 'no-cache'});
      if (res.ok) {
        geoData = await res.json();
        break;
      }
    } catch {
      continue;
    }
  }
  if (!geoData) {
    alert('Failed to load trail data.');
    return;
  }

  // Filter features by name
  const features = geoData.features.filter(f => {
    const name = f.properties && f.properties.name;
    return name && name === decoded;
  });
  if (features.length === 0) {
    alert('Trail not found: ' + decoded);
    return;
  }

  // Create a GeoJsonDataSource for the selected trail
  const dataSource = await Cesium.GeoJsonDataSource.load(
    {type: 'FeatureCollection', features: features},
    {
      clampToGround: true,
      stroke: Cesium.Color.ORANGERED,
      strokeWidth: 4
    }
  );
  viewer.dataSources.add(dataSource);

  // Fly to the trail when the page loads
  viewer.flyTo(dataSource.entities, {duration: 3});

  // Play button: fly along the trail path
  document.getElementById('playBtn').addEventListener('click', function() {
    let positions;
    const entity = dataSource.entities.values[0];
    if (entity.polyline && entity.polyline.positions) {
      positions = entity.polyline.positions.getValue(Cesium.JulianDate.now());
    } else if (entity.polygon) {
      positions = entity.polygon.hierarchy.getValue(Cesium.JulianDate.now()).positions;
    }
    if (!positions || positions.length === 0) {
      alert('No positions found for this trail.');
      return;
    }
    // Create a set of sampled positions to fly through
    const total = positions.length;
    const flyPositions = [];
    for (let i = 0; i < total; i += Math.floor(total/100) || 1) {
      flyPositions.push(positions[i]);
    }
    let index = 0;
    function flyNext() {
      if (index >= flyPositions.length) return;
      viewer.camera.flyTo({
        destination: flyPositions[index],
        orientation: {
          heading: viewer.camera.heading,
          pitch: viewer.camera.pitch,
          roll: viewer.camera.roll
        },
        duration: 1.0,
        complete: function() {
          index++;
          flyNext();
        }
      });
    }
    flyNext();
  });
}

init();
</script>
<!-- Quick browse footer injected from /pages/footer.html via quick-browse-footer.js -->


</body>
</html>
